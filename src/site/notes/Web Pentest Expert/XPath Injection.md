---
{"dg-publish":true,"permalink":"/web-pentest-expert/x-path-injection/"}
---


**XPath**, **XML** verileri için bir sorgu dilidir. Kullanıcı girdisi doğru şekilde filtrelenmezse, **SQL Injection** benzeri **XPath Injection** güvenlik açıkları oluşabilir.


## XPath Temelleri

XPath'e giriş yapabilmek için öncelikle XPath terminolojisinde bir temel oluşturmamız gerekir. Bunu yapmak için aşağıdaki XML dokümanını ele alalım:

```xml
<?xml version="1.0" encoding="UTF-8"?>
  
<academy_modules>  
  <module>
    <title>Web Attacks</title>
    <author>21y4d</author>
    <tier difficulty="medium">2</tier>
    <category>offensive</category>
  </module>

  <!-- this is a comment -->
  <module>
    <title>Attacking Enterprise Networks</title>
    <author co-author="LTNB0B">mrb3n</author>
    <tier difficulty="medium">2</tier>
    <category>offensive</category>
  </module>
</academy_modules>
```


Bir XML dokümanı genellikle XML versiyonunu ve kodlamasını belirten ==XML  declaration== (bildirimi) ile başlar. Yukarıdaki XML dokümanında, XML bildirimi `<?xml version=“1.0” encoding=“UTF-8”?>` şeklindedir. Bildirim atlanırsa, XML parser'ı `1.0` versiyonunu ve `UTF-8` kodlamasını varsayar.

Bir **XML** dokümanındaki veri, **root element node** olarak adlandırılan en üst **node**'dan oluşan bir **tree** yapısında biçimlendirilir. Bizim örneğimizde bu **academy_modules** node'udur. XML'deki temel **node** türleri şunlardır:

1. **Root Element Node**: En üst **node** (**academy_modules**).
2. **Element Nodes**: **module**, **title** gibi **nodes**.
3. **Attribute Nodes**: **co-author="LTNB0B"**, **difficulty="medium"** gibi **attributes**.
4. **Comment Nodes**: `<!-- this is a comment -->` gibi **comments**.
5. **Text Nodes**: **Web Attacks**, **LTNB0B** gibi **element** veya **attribute nodes**'tan gelen karakter verileri.
6. **Namespace Nodes**: (Bu örnekte ele alınmayan, **namespace** tanımlayan **nodes**).
7. **Processing Instruction Nodes**: (Belirli processing talimatları içeren **nodes**).

XML dokümanları bir tree yapısı oluşturduğundan, her element ve attribute node'u tam olarak bir ==parent node'a== sahipken, her element node'u keyfi sayıda ==child node'a== sahip olabilir. Aynı parent'e sahip node'lara ==sibling node'lar== denir. Tüm ==ancestor (ata)== node'ları veya ==descendant (torun) node'lar==ı belirlemek için tree'yi belirli bir node'dan yukarı veya aşağı doğru gezebiliriz.

```
<academy_modules>  
  <module>
    <title>Web Attacks</title>
    <author>21y4d</author>
    <tier difficulty="medium">2</tier>
    <category>offensive</category>
  </module>
</academy_modules>
```


- **Parent Node**: `<module>` elementi, `<title>`, `<author>`, `<tier>`, `<category>` elementlerinin **parent node**'udur.
- **Child Nodes**: `<module>`'ün **child nodes**'ları: `<title>`, `<author>`, `<tier>`, `<category>`.
- **Sibling Nodes**: `<title>`, `<author>`, `<tier>`, `<category>` aynı **parent node**'a (**module**) sahip olduğu için **sibling nodes**'dır.
- **Ancestor Nodes**: `<title>` elementinin **ancestor nodes**'ları **module** ve **academy_modules**.
- **Descendant Nodes**: `<module>` elementinin **descendant nodes**'ları **title, author, tier, category**.


## Nodes

Artık XPath'in temel terminolojisini tartıştığımıza göre, query syntax'ına geçebiliriz. Bu modülde, sadece kısaltılmış syntax'ı tartışacağız. XPath syntax hakkında daha fazla ayrıntı için [W3C specification](https://www.w3.org/TR/xpath-3/)'a bakın.

Her XPath sorgusu XML dokümanında bir dizi node seçer. Bir sorgu, başlangıç noktasını işaret eden bir ==context node'dan== itibaren değerlendirilir. Bu nedenle, context node'a bağlı olarak, aynı sorgu farklı sonuçlara sahip olabilir. Burada, nodların seçilmesi için XPath sorgularının temel durumlarına genel bir bakış sunulmaktadır:

|**Query**|**Açıklama**|
|---|---|
|`module`|Context node’un **module** olan tüm **child node**'larını seç|
|`/`|**Document root node**'u seç|
|`//`|Context node’un **descendant node**'larını seç|
|`.`|**Context node**'u seç|
|`..`|**Context node**'un **parent node**'unu seç|
|`@difficulty`|**Context node**'un **difficulty attribute node**'unu seç|
|`text()`|**Context node**'un tüm **text node child node**'larını seç|

Bu temel durumları daha karmaşık sorgular oluşturmak için kullanabiliriz. Context node'a bağlı olarak sorgu sonucunun belirsizliğini önlemek için, sorgumuzu document root'tan başlatabiliriz:

| **Query**                                  | **Açıklama**                                                                                      |
| ------------------------------------------ | ------------------------------------------------------------------------------------------------- |
| `/academy_modules/module`                  | **academy_modules node**'unun tüm **module child node**'larını seç                                |
| `//module`                                 | Tüm **module node**'larını seç                                                                    |
| `/academy_modules//title`                  | **academy_modules node**'un **descendant node**'u olan tüm **title node**'larını seç              |
| `/academy_modules/module/tier/@difficulty` | Belirtilen path altındaki tüm **tier element node**'larının **difficulty attribute node**'unu seç |
| `//@difficulty`                            | Tüm **difficulty attribute node**'larını seç                                                      |

Not: Bir sorgu // ile başlıyorsa, sorgu context node'da değil document root'ta değerlendirilir.


## Predicates (Koşullu filtreler)

**Predicates**, bir **XPath query**'sinden gelen sonucu **SQL query**'lerindeki **WHERE clause** gibi filtreler. **Predicates**, **XPath query**'nin bir parçasıdır ve köşeli parantez `[]` içinde bulunur. İşte bazı **predicate** örnekleri:

| Query                                    | Açıklama                                                                                                                 |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `/academy_modules/module[1]`             | `academy_modules` node'unun ilk `module` child node'unu seç                                                              |
| `/academy_modules/module[position()=1]`  | Yukarıdaki sorgu ile aynı                                                                                                |
| `/academy_modules/module[last()]`        | `academy_modules` node'unun son `module` child node'unu seç                                                              |
| `/academy_modules/module[position()<3]`  | `academy_modules` node'unun ilk iki `module` child node'unu seç                                                          |
| `//module[tier=2]/title`                 | `tier` element node'u `2` olan tüm `module` node'larının `title` element node'unu seç                                    |
| `//module/author[@co-author]/../title`   | `author` element node'u `co-author` attribute node'una sahip olan tüm `module` node'larının `title` element node'unu seç |
| `//module/tier[@difficulty="medium"]/..` | `tier` element node'u `difficulty="medium"` attribute node'una sahip olan tüm `module` node'larını seç                   |


Predicates aşağıdaki operandları destekler:

|Operand|Explanation|
|---|---|
|`+`|Addition|
|`-`|Subtraction|
|`*`|Multiplication|
|`div`|Division|
|`=`|Equal|
|`!=`|Not Equal|
|`<`|Less than|
|`<=`|Less than or Equal|
|`>`|Greater than|
|`>=`|Greater than or Equal|
|`or`|Logical Or|
|`and`|Logical And|
|`mod`|Modulus|

## Wildcards & Union

Bazen bir path içindeki node türüyle ilgilenmeyiz. Bu durumda aşağıdaki wildcard'lardan birini kullanabiliriz:

| Sorgu  | Açıklama                                |
| ------ | --------------------------------------- |
| node() | Herhangi bir node ile eşleşir           |
| *      | Herhangi bir element node ile eşleşir   |
| @*     | Herhangi bir attribute node ile eşleşir |

Bu joker karakterleri aşağıdaki gibi sorgular oluşturmak için kullanabiliriz:

| Query                    | Explanation                                                                          |
| ------------------------ | ------------------------------------------------------------------------------------ |
| `//*`                    | Dokümandaki tüm element node'larını seçer                                            |
| `//module/author[@*]/..` | Author element node'unda herhangi bir attribute node'u bulunan tüm module'leri seçer |
| `/*/*/title`             | Doküman root'undan tam iki seviye aşağıda bulunan tüm title node'larını seçer        |
Not: `*` wildcard'ı herhangi bir node ile eşleşir ancak `//` gibi descendants (torunlar) ile eşleşmez. Bu nedenle, sorgumuzda doğru miktarda wildcard belirtmemiz gerekir. Örnek XML belgemizde, `/*/*/title` sorgusu tüm modül title'larını döndürür, ancak `/*/title` sorgusu hiçbir şey döndürmez.

Son olarak, birden fazla XPath sorgusunu union operatörü ile birleştirebiliriz `|` aşağıdaki gibi:

| Query                                                            | Explanation                                           |
| ---------------------------------------------------------------- | ----------------------------------------------------- |
| `//module[tier=2]/title/text() \| //module[tier=3]/title/text()` | 2 ve 3 katmanlarındaki tüm modüllerin title'ını seçin |



# XPath - Authentication Bypass

Artık XPath query syntax hakkında temel bir fikre sahip olduğumuza göre XPath injection ile başlayalım. XPath injection'ları, SQL injection'larına benzer şekilde, web kimlik doğrulamasını atlamak için silah olarak kullanılabilir. Bu bölümde böyle bir senaryoyu tartışacağız.


## Temel

XPath enjeksiyonu yoluyla authentication bypass'larını keşfetmeye ve kullanmaya girişmeden önce, XPath sorguları yoluyla authentication'ın nasıl uygulanabileceğini tartışmamız gerekir. Örnek olarak, kullanıcı verilerini aşağıdaki gibi depolayan bir XML dokümanı düşünelim:

```xml
<users>
	<user>
		<name first="Kaylie" last="Grenvile"/>
		<id>1</id>
		<username>kgrenvile</username>
		<password>P@ssw0rd!</password>
	</user>
	<user>
		<name first="Admin" last="Admin"/>
		<id>2</id>
		<username>admin</username>
		<password>admin</password>
	</user>
	<user>
		<name first="Academy" last="Student"/>
		<id>3</id>
		<username>htb-stdnt</username>
		<password>Academy_student!</password>
	</user>
</users>
```

Authentication gerçekleştirmek için web uygulaması aşağıdaki gibi bir XPath query çalıştırabilir:

```xpath
/users/user[username/text()='htb-stdnt' and password/text()='Academy_student!']
```

Güvenlik açığı bulunan PHP kodu, username ve password'ü önceden sterilize etmeden sorguya ekler:

```php
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . $_POST['password'] . "']";
$results = $xml->xpath($query);
```


XPath sorgusunun her zaman ==true== olarak değerlendirileceği şekilde bir username ve password inject ederek kimlik doğrulamayı atlatmayı hedefliyoruz. Bunu, username ve password olarak `' or '1'='1` değerlerini enjekte ederek başarabiliriz. Ortaya çıkan XPath sorgusu aşağıdaki gibi görünür:

```xpath
/users/user[username/text()='' or '1'='1' and password/text()='' or '1'='1']
```

Predicate ==true== olarak değerlendirildiğinden, sorgu XML dokümanındaki tüm ==user== element node'larını döndürür. Dolayısıyla, ilk kullanıcı olarak oturum açmış oluruz. Örnek dokümanımızda bu, ==kgrenvile== kullanıcısıdır. Ancak, en yüksek izinleri almak için ==admin== kullanıcısı olarak oturum açmak istersek ne olur? Bu durumda, `admin' or '1'='1` şeklinde bir username ve password için rastgele bir değer girmemiz gerekir. Bu şekilde, ortaya çıkan XPath sorgusu aşağıdaki gibi görünür:

```xpath
/users/user[username/text()='admin' or '1'='1' and password/text()='abc']
```

Yukarıdaki sorgu, `or` koşulu nedeniyle doğru şifreyi sağlamadan admin kullanıcısı olarak giriş yapmamıza olanak tanır.

## Exploitation

Gerçek dünya senaryolarında, şifreler genellikle hash'lenir. Ayrıca, geçerli bir kullanıcı adı bilmeyebiliriz, bu nedenle yukarıda belirtilen payload'ları kullanamayız. Neyse ki, bu tür durumlarda kimlik doğrulamasını atlatmak için daha gelişmiş injection payload'ları kullanabiliriz. Aşağıdaki örneği göz önünde bulunduralım:

```xml
<users>
	<user>
		<name first="Kaylie" last="Grenvile"/>
		<id>1</id>
		<username>kgrenvile</username>
		<password>8a24367a1f46c141048752f2d5bbd14b</password>
	</user>
	<user>
		<name first="Admin" last="Admin"/>
		<id>2</id>
		<username>obfuscatedadminuser</username>
		<password>21232f297a57a5a743894a0e4a801fc3</password>
	</user>
	<user>
		<name first="Academy" last="Student"/>
		<id>3</id>
		<username>htb-stdnt</username>
		<password>295362c2618a05ba3899904a6a3f5bc0</password>
	</user>
</users>
```

Bu durumda, savunmasız PHP kodu aşağıdaki gibi görünebilir:

```php
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . md5($_POST['password']) . "']";
$results = $xml->xpath($query);
```


Password, sorguya eklenmeden önce hash'lendiği için, `' or '1'='1'` username ve password enjeksiyon yapıldığında aşağıdaki sorgu oluşacaktır:

```xpath
/users/user[username/text()='' or '1'='1' and password/text()='59725b2f19656a33b3eed406531fb474']
```

Bu sorgu herhangi bir node döndürmez, bu nedenle kimlik doğrulamayı bu şekilde atlayamayız. Ayrıca geçerli bir kullanıcı adı da bilmiyoruz, bu yüzden şu ana kadar tartışılan payload'lar ile kimlik doğrulamayı atlayamayız.

İlk olarak, XPath sorgusunun true döndürmesini sağlayarak tüm kullanıcı node'larının dönmesini ve böylece ilk kullanıcı olarak giriş yapmamızı sağlamak için kullanıcı adına bir "double or" koşulu enjekte edebiliriz. Örnek bir payload `' or true() or '` şeklinde olabilir ve bu, aşağıdaki sorguya neden olur:

```xpath
/users/user[username/text()='' or true() or '' and password/text()='59725b2f19656a33b3eed406531fb474']
```

Sorgunun değerlendirilme şekli nedeniyle, "double or" koşulu sorgunun evrensel olarak true döndürmesine neden olur ve bu şekilde kimlik doğrulama atlanır. Ancak, daha önce tartışıldığı gibi, daha fazla ayrıcalık elde etmek için belirli bir kullanıcı olarak giriş yapmak isteyebiliriz.

Bunu yapmanın bir yolu, tüm kullanıcıları konumlarına göre tek tek denemektir. Bu, aşağıdaki payload ile gerçekleştirilebilir: `' or position()=2 or '`, bu da aşağıdaki sorguya neden olur:

```xpath
/users/user[username/text()='' or position()=2 or '' and password/text()='59725b2f19656a33b3eed406531fb474']
```

Bu yalnızca ikinci kullanıcı node'unu döndürecektir. Konumu artırarak tüm kullanıcılar üzerinde tek tek gezinip aradığımız kullanıcıyı bulana kadar deneme yapabiliriz. Gerçek dünya senaryolarında milyonlarca kullanıcı olabileceğinden, bu manuel teknik çok hızlı bir şekilde uygulanamaz hale gelecektir. Bunun yerine, kullanıcı adının bir kısmını biliyorsak belirli kullanıcıları arayabiliriz. Bunun için aşağıdaki payload'ı kullanabiliriz: `' or contains(.,'admin') or '`, bu da aşağıdaki sorguya neden olur:

```xpath
/users/user[username/text()='' or contains(.,'admin') or '' and password/text()='59725b2f19656a33b3eed406531fb474']
```

Bu sorgu, herhangi bir descendants (torununda) admin string'ini içeren tüm kullanıcı node'larını döndürür. Kullanıcı adı node'u kullanıcı node'unun bir child'ı olduğundan, bu, kullanıcı adında admin substring'ini içeren tüm kullanıcıları döndürür.


# XPath - Data Exfiltration (Veri Sızıntısı)

Önceki bölümde XPath enjeksiyonu kullanarak kimlik doğrulamayı atlamayı tartıştığımıza göre, bu bölümde veri sızıntısı (data exfiltration) üzerine odaklanacağız. Özellikle, UNION based SQL enjeksiyonlarına benzer teknikler kullanarak XPath sorgularını manipüle edip XML dokümanlarında keyfi verilere nasıl erişebileceğimizi tartışacağız.


## Simple Data Exfiltration

Basit bir temel senaryoda XPath enjeksiyonu yoluyla data exfiltrasyonu göstermek için, San Francisco'daki caddeler hakkında data sorgulamamızı sağlayan bir web uygulamasını ele alalım. Bir search query girebilir ve uzun ya da kısa bir sokak adı arasında seçim yapabiliriz. Web uygulaması San Francisco'da sorgumuzla eşleşen tüm sokakları görüntüler:

![Pasted image 20250213013246.png](/img/user/Pasted%20image%2020250213013246.png)

İsteğe baktığımızda, arama sorgusunun `q` GET parametresinde gönderildiğini, uzun/kısa sokak adı seçimimizin ise `f` GET parametresinde iletildiğini görebiliriz:

![Pasted image 20250213015659.png](/img/user/Pasted%20image%2020250213015659.png)



Web uygulaması, search sorgumuzu bir substring olarak içeren tüm sokakları döndürür. f parametresi, eşleşen sokakların hangi özellikteki tam sokak adının veya kısaltılmış bir versiyonunun görüntüleneceğini kontrol ediyor gibi görünüyor. Bu, iki node adı ortaya çıkarır: ==fullstreetname== ve ==streetname==. XPath injection güvenlik açıklarından başarılı bir şekilde faydalanmak için, SQL injection güvenlik açıklarından faydalanırken yapılana benzer şekilde, web uygulaması tarafından sorgulanan XPath sorgusunun ve beraberindeki XML dokümanının yapısını anlamaya/tasvir etmeye çalışmak çok önemlidir.

Web uygulamasının davranışından, gerçekleştirilen XPath sorgusu hakkında bilgi çıkarabiliriz. XML dokümanında element node'larının isimlerini bilmediğimiz için, yolu a, b, c ve d gibi tek karakterli placeholder isimleriyle göstereceğiz:

```xpath
/a/b/c/[contains(d/text(), 'BAR')]/fullstreetname
```

Not: XML şemasının derinliğinin yukarıda gösterildiği gibi üç (/a/b/c) olup olmadığını bilmiyoruz. Şema derinliğinin nasıl belirleneceğini bir sonraki bölümde tartışacağız.

Bu durumda, GET parametresi `q` içinde sağladığımız search string, `contains` fonksiyonu kullanılarak sokak adını filtreleyen predicate'nin içine yerleştirilir. Ardından, GET parametresi `f`, web uygulamasının eşleşen tüm sokaklardan hangi özelliği görüntüleyeceğini belirler, bu nedenle sorgunun sonuna eklenir.