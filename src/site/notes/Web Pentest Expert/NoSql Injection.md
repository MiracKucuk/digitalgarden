---
{"dg-publish":true,"permalink":"/web-pentest-expert/no-sql-injection/"}
---

Birçok uygulama parolalar, e-posta adresleri veya yorumlar gibi verileri depolamak için veritabanlarını kullanır. En popüler veritabanı motoru ilişkiseldir (örneğin Oracle ve MySQL). Ancak son on yılda, NoSQL veritabanları olarak da bilinen ilişkisel olmayan veritabanları giderek daha yaygın hale gelmiştir ve MongoDB şu anda en çok kullanılan 5. veritabanı motorudur (Kasım 2022 itibariyle).

![Pasted image 20241206175737.png](/img/user/resimler/Pasted%20image%2020241206175737.png)

Dört ana NoSQL veritabanı türü vardır ve hepsi verileri benzer şekilde tablolarda, satırlarda ve sütunlarda depolayan ilişkisel veritabanlarının aksine, NoSQL veritabanlarının verileri depolama şekli farklı kategoriler ve uygulamalar arasında önemli ölçüde farklılık gösterir.

![Pasted image 20241206180933.png](/img/user/resimler/Pasted%20image%2020241206180933.png)

Bu modülde, en popüler NoSQL veritabanı olduğu için yalnızca MongoDB'ye odaklanacağız.


### Introduction to MongoDB

MongoDB document-oriented bir veritabanıdır, yani veriler field ve değerlerden oluşan doküman koleksiyonlarında saklanır. MongoDB'de bu belgeler [BSON](https://bsonspec.org/) (Binary JSON) olarak kodlanır. Bir MongoDB veritabanında saklanabilecek bir belge örneği şöyledir:

![Pasted image 20241206182913.png](/img/user/resimler/Pasted%20image%2020241206182913.png)

Burada belgenin alanlarını (“type”, “price”) ve ilgili değerlerini (“Granny Smith”, “0.65”) görebiliriz. _id alanı MongoDB tarafından bir belgenin primer anahtarı olarak kullanılmak üzere ayrılmıştır ve tüm koleksiyon boyunca benzersiz olmalıdır.


### MongoDB'ye Bağlanma
Bir MongoDB veritabanı ile komut satırından etkileşim kurmak için connection string'i geçerek mongosh'u kullanabiliriz. 27017/tcp'nin MongoDB için varsayılan port olduğunu unutmayın.

![Pasted image 20241206183048.png](/img/user/resimler/Pasted%20image%2020241206183048.png)

Hangi veritabanlarının var olduğunu bu şekilde kontrol edebiliriz:

![Pasted image 20241206183113.png](/img/user/resimler/Pasted%20image%2020241206183113.png)


### Creating a Database

MongoDB, siz o veritabanında ilk kez veri depolayana kadar bir veritabanı oluşturmaz. use komutunu kullanarak academy adında yeni bir veritabanına “ switch ” yapabiliriz:

![Pasted image 20241206183345.png](/img/user/resimler/Pasted%20image%2020241206183345.png)

Show collections ile bir veritabanındaki tüm koleksiyonları listeleyebiliriz.


### Veri Ekleme

Bir veritabanı oluşturmaya benzer şekilde, MongoDB yalnızca bu koleksiyona ilk kez bir belge eklediğinizde bir koleksiyon oluşturur . Bir koleksiyona çeşitli şekillerde veri ekleyebiliriz.

Apples koleksiyonuna şu şekilde tek bir belge ekleyebiliriz:

![Pasted image 20241206183555.png](/img/user/resimler/Pasted%20image%2020241206183555.png)

Ve apples koleksiyonuna bu şekilde birden fazla belge ekleyebiliriz:

![Pasted image 20241206183627.png](/img/user/resimler/Pasted%20image%2020241206183627.png)


### Veri Seçme

Diyelim ki Granny Smith elmalarının fiyatını kontrol etmek istedik. Bunu yapmanın bir yolu, eşleştirmek istediğimiz alanları ve değerleri içeren bir belge belirtmektir:

![Pasted image 20241206183703.png](/img/user/resimler/Pasted%20image%2020241206183703.png)

Ya da belki koleksiyondaki tüm belgeleri listelemek istedik. Bunu boş bir belge geçirerek yapabiliriz (tüm belgelerin bir alt kümesi olduğu için):

![Pasted image 20241206183732.png](/img/user/resimler/Pasted%20image%2020241206183732.png)

Türü 'G' ile başlayan ve fiyatı 0,70'den az olan tüm elmaları bulmak gibi daha gelişmiş sorgular yapmak istersek,[ sorgu operatörlerinin](https://www.mongodb.com/docs/manual/reference/operator/query/) bir kombinasyonunu kullanmamız gerekir. MongoDB'de birçok sorgu operatörü vardır, ancak en yaygın olanlardan bazıları şunlardır:

![Pasted image 20241206184457.png](/img/user/resimler/Pasted%20image%2020241206184457.png)

![Pasted image 20241206184550.png](/img/user/resimler/Pasted%20image%2020241206184550.png)
![Pasted image 20241206184604.png](/img/user/resimler/Pasted%20image%2020241206184604.png)

https://www.mongodb.com/docs/manual/reference/operator/query/where/

Daha önceki örneğe dönecek olursak, türü 'G' ile başlayan ve fiyatı 0,70'ten az olan tüm elmaları seçmek istersek, bunu yapabiliriz:

![Pasted image 20241206184643.png](/img/user/resimler/Pasted%20image%2020241206184643.png)
![Pasted image 20241206184648.png](/img/user/resimler/Pasted%20image%2020241206184648.png)

Alternatif olarak, aynı sonucu elde etmek için $where operatörünü kullanabiliriz:

![Pasted image 20241206184705.png](/img/user/resimler/Pasted%20image%2020241206184705.png)

Find sorgularındaki verileri sıralamak istiyorsak, bunu sort fonksiyonunu ekleyerek yapabiliriz. Örneğin, azalan sırada fiyata göre sıralanmış ilk iki elmayı seçmek istiyorsak, bunu şu şekilde yapabiliriz:

![Pasted image 20241206184733.png](/img/user/resimler/Pasted%20image%2020241206184733.png)

Sıralama düzenini tersine çevirmek isteseydik -1 (Azalan) yerine 1 (Artan) kullanırdık. Sonundaki .limit(2)'ye dikkat edin, bu da döndürülecek sonuç sayısına bir sınır koymamızı sağlar.


### Updating Documents
Güncelleme işlemleri bir filtre ve bir güncelleme işlemi alır. Filtre, güncelleyeceğimiz dokümanları seçer ve güncelleme işlemi bu dokümanlar üzerinde gerçekleştirilir. Sorgu operatörlerine benzer şekilde MongoDB'de güncelleme operatörleri vardır. En sık kullanılan [güncelleme operatörü](https://www.mongodb.com/docs/manual/reference/operator/update/#std-label-update-operators-processing-order) $set'tir ve belirtilen alanın değerini günceller.

Enflasyon nedeniyle Granny Smith elmalarının fiyatının 0,65'ten 1,99'a yükseldiğini düşünün. Belgeyi güncellemek için şunu yapmamız gerekir:

![Pasted image 20241206184853.png](/img/user/resimler/Pasted%20image%2020241206184853.png)

Tüm elmaların fiyatlarını aynı anda artırmak istiyorsak, $inc operatörünü kullanabilir ve bunu yapabiliriz:

![Pasted image 20241206184908.png](/img/user/resimler/Pasted%20image%2020241206184908.png)

$set operatörü mevcut bir belgedeki belirli alanları güncellememizi sağlar, ancak belgeyi tamamen değiştirmek istiyorsak bunu replaceOne ile aşağıdaki gibi yapabiliriz:

![Pasted image 20241206184940.png](/img/user/resimler/Pasted%20image%2020241206184940.png)


### Removing Documents

Bir belgeyi kaldırmak, belge seçmeye çok benzer. Bir sorgu iletiriz ve eşleşen belgeler kaldırılır. Diyelim ki fiyatı 0,80'den az olan elmaları kaldırmak istedik:

![Pasted image 20241206185020.png](/img/user/resimler/Pasted%20image%2020241206185020.png)

Şimdiye kadar, NoSQL veritabanları ve MongoDB'nin nasıl kullanılacağı hakkında temel bir anlayışa sahip olmalısınız. Aşağıdaki bölüm NoSQL enjeksiyon saldırılarının bazı temellerini kapsayacaktır.


### Introduction to NoSQL Injection

Kullanıcı girdisi önce uygun şekilde sterilize edilmeden bir NoSQL sorgusuna dahil edildiğinde, NoSQL enjeksiyonu meydana gelebilir. Bir saldırgan sorgunun bir kısmını kontrol edebilirse, mantığı bozabilir ve sunucunun istenmeyen eylemleri gerçekleştirmesini / istenmeyen sonuçları döndürmesini sağlayabilir . NoSQL'in SQL gibi standartlaştırılmış bir sorgu dili olmadığından, NoSQL enjeksiyon saldırıları çeşitli NoSQL uygulamalarında farklı görünür.


### Scenario (Node.JS)
Kullanıcı bilgilerini depolamak için MongoDB kullanan bir Express / Node.JS web sunucusu hayal edelim. Bu sunucu, bir kullanıcının bilgilerini kullanıcı adından almanızı sağlayan /api/v1/getUser endpoint'ine sahiptir.

![Pasted image 20241206185203.png](/img/user/resimler/Pasted%20image%2020241206185203.png)
![Pasted image 20241206185213.png](/img/user/resimler/Pasted%20image%2020241206185213.png)

[[Kodun detaylı açıklaması . \|Kodun detaylı açıklaması . ]]

[Not](https://restfulapi.net/http-methods/): Pratikte bu muhtemelen /api/v1/getUser/username gibi bir GET isteği olacaktır, ancak basitlik adına burada bir POST

Bu endpoint'in kullanım amacı şu şekildedir:

![Pasted image 20241206192359.png](/img/user/resimler/Pasted%20image%2020241206192359.png)

/api/v1/getUser endpoint'ini {“username” gövdesi ile gönderdik: “gerald1992"} ve sunucu bunu tam sorguyu oluşturmak için kullandı db.users.find({kullanıcıadı: “gerald1992”}) ve sonuçları bize döndürdü.

Sorun, sunucunun herhangi bir filtre veya kontrol olmaksızın kullanıcı adı sorgusu olarak verdiğimiz her şeyi körü körüne kullanmasıdır. Aşağıda NoSQL enjeksiyonuna karşı savunmasız olan bir kod örneği bulunmaktadır:

![Pasted image 20241206192824.png](/img/user/resimler/Pasted%20image%2020241206192824.png)

![Pasted image 20241206192848.png](/img/user/resimler/Pasted%20image%2020241206192848.png)


### NoSQL Enjeksiyon Türleri

SQL enjeksiyonuna aşina iseniz, karşılaşabileceğimiz çeşitli enjeksiyon sınıflarına zaten aşina olacaksınız demektir:

* ==In-Band== : Saldırgan bir NoSQL enjeksiyonundan yararlanmak ve sonuçları almak için aynı iletişim kanalını kullanabildiğinde. Yukarıdaki senaryo buna bir örnektir.
* ==Blind (Kör)== : Saldırganın NoSQL enjeksiyonundan doğrudan sonuç alamadığı, ancak sunucunun nasıl yanıt verdiğine bağlı olarak sonuçları çıkarabildiği durumdur
* ==Boolean== : Boolean based, blind injections'ın bir alt sınıfıdır ve saldırganların sunucuyu bir sorguyu değerlendirmeye ve True ya da False olması durumunda bir sonuç ya da diğerini döndürmeye zorlayabildiği bir tekniktir
* ==Time-Based:== Time-based, blind injection'ların diğer bir alt sınıfıdır ve saldırganların sunucuyu yanıt vermeden önce, genellikle sorgunun True veya False olarak değerlendirilip değerlendirilmediğini belirtmek için belirli bir süre bekletmesidir.

NoSQL enjeksiyonunun temellerini açıkladıktan sonra, biraz daha derinlemesine örneklere geçelim.


### Bypassing Authentication


#### MangoMail
Bu bölümde, MangoMail'i ele alacağız. Bu web uygulaması bir kimlik doğrulama bypass'ına karşı savunmasızdır .

Web sayfasında bir oturum açma portalı var ve başka bir şey yok; muhtemelen bu dahili bir web posta hizmeti.

![Pasted image 20241206194130.png](/img/user/resimler/Pasted%20image%2020241206194130.png)

Formu test verileriyle dolduracağız ve talebi BurpSuite ile keseceğiz. Bu sürece zaten aşina olduğunuz varsayılmaktadır.

![Pasted image 20241206194158.png](/img/user/resimler/Pasted%20image%2020241206194158.png)

POST isteğinde, test verileriyle doldurulmuş olan URL kodlu e-posta ve şifre parametrelerini görüyoruz. Şaşırtıcı olmayan bir şekilde, bu giriş denemesi başarısız oluyor

Server tarafında , bu parametrelerin aktarıldığı kimlik doğrulama fonksiyonu aşağıdaki gibi görünür:

![Pasted image 20241206194329.png](/img/user/resimler/Pasted%20image%2020241206194329.png)

Server'ın herhangi bir şey yapmadan önce e-posta ve şifrenin hem verilmiş hem de boş olup olmadığını kontrol ettiğini görebiliriz. Bu doğrulandıktan sonra, local olarak çalışan bir MongoDB örneğine bağlanır ve ardından verilen e-posta ve parola çiftine sahip bir kullanıcı olup olmadığını görmek için mangomail'i sorgular:

![Pasted image 20241206194536.png](/img/user/resimler/Pasted%20image%2020241206194536.png)
![Pasted image 20241206194541.png](/img/user/resimler/Pasted%20image%2020241206194541.png)

Sorun şu ki, hem e-posta hem de kullanıcı adı, MongoDB sorgusuna sanitize edilmeden aktarılan kullanıcı kontrollü girdilerdir. Bu da bizim (saldırganlar olarak) sorgunun kontrolünü ele geçirebileceğimiz anlamına geliyor.

Bu modülün ilk bölümünde birçok query operator tanıtıldı ve bu query üzerinde nasıl değişiklik yapabileceğinize dair bir fikriniz olabilir. Şu anda, bu query'nin herhangi bir document ile eşleşmesini sağlamasını istiyoruz, çünkü bu, eşleştiği bir kullanıcı olarak kimlik doğrulamamızı sağlar.

Bunu başarmanın basit bir yolu, hem email hem de password için $ne query operator'ünü kullanarak, bildiğimiz bir şeyle eşleşmeyen değerleri eşleştirmektir. Daha açık bir şekilde ifade etmek gerekirse, email'in '[email protected]' ile eşleşmediği **ve** password'ün 'test' ile eşleşmediği bir query oluşturmak istiyoruz.

![Pasted image 20241206194757.png](/img/user/resimler/Pasted%20image%2020241206194757.png)

Not : **`$ne` (Not Equal)**, MongoDB'de bir **query operator**'dür ve belirli bir alandaki değerlerin verilen değere eşit **olmamasını** sağlar. Yani, sorgu sırasında belirttiğiniz koşula uymayan kayıtları bulur.

![Pasted image 20241206194902.png](/img/user/resimler/Pasted%20image%2020241206194902.png)

![Pasted image 20241206195159.png](/img/user/resimler/Pasted%20image%2020241206195159.png)

Payload : [$ne]

![Pasted image 20241206195404.png](/img/user/resimler/Pasted%20image%2020241206195404.png)

Form parametrelerini güncellediğimizde ve isteği ilettiğimizde, kimlik doğrulamayı başarıyla atladığımızı görmeliyiz .

![Pasted image 20241206195428.png](/img/user/resimler/Pasted%20image%2020241206195428.png)


### Alternatif Sorgular

![Pasted image 20241206195521.png](/img/user/resimler/Pasted%20image%2020241206195521.png)

![Pasted image 20241206195534.png](/img/user/resimler/Pasted%20image%2020241206195534.png)

Bunu URL kodlu forma uyarlayabilir, isteği yeniden gönderebilir ve kimlik doğrulamayı tekrar atlayabiliriz.

![Pasted image 20241206195552.png](/img/user/resimler/Pasted%20image%2020241206195552.png)

![Pasted image 20241206195859.png](/img/user/resimler/Pasted%20image%2020241206195859.png)
![Pasted image 20241206195903.png](/img/user/resimler/Pasted%20image%2020241206195903.png)

İşe yarayabilecek diğer bazı payloadlar şunlardır:

![Pasted image 20241206200010.png](/img/user/resimler/Pasted%20image%2020241206200010.png)

![Pasted image 20241206200042.png](/img/user/resimler/Pasted%20image%2020241206200042.png)

![Pasted image 20241206200058.png](/img/user/resimler/Pasted%20image%2020241206200058.png)

Bunun yanı sıra, aynı etkiyi elde etmek için operatörleri karıştırabilir ve eşleştirebilirsiniz. Sorgu operatörlerini daha iyi anlamak için biraz zaman ayırmak, NoSQL enjeksiyonunu vahşi ortamda kullanmaya çalıştığınızda size yardımcı olacaktır.



### In-Band Data Extraction

### Teori

Geleneksel SQL veritabanlarında, in-band veri çıkarma güvenlik açıkları genellikle tüm veritabanının dışarı sızmasına yol açabilir. Ancak MongoDB'de, ilişkisel olmayan bir veritabanı olduğundan ve sorgular belirli koleksiyonlar üzerinde gerçekleştirildiğinden, saldırılar (genellikle) enjeksiyonun uygulandığı koleksiyonla sınırlıdır.


### MangoSearch
Bu bölümde, MangoSearch'e bir göz atacağız . Bu uygulama in-band data extraction'a karşı savunmasızdır .

Web sitesinin kendisi çok basit:
Wikipedia'dan bir alıntı.
Bir Mango resmi.
Çeşitli mango türleri hakkında gerçekleri bulabileceğiniz bir arama alanı.

![Pasted image 20241206200405.png](/img/user/resimler/Pasted%20image%2020241206200405.png)

Bu bölümde, hangi talebin gönderildiğini ve ne tür bilgilerin döndürüldüğünü görmek için önerilen türlerden birini aramayı deneyebiliriz.

![Pasted image 20241206200505.png](/img/user/resimler/Pasted%20image%2020241206200505.png)

![Pasted image 20241206200554.png](/img/user/resimler/Pasted%20image%2020241206200554.png)

Sunucu tarafında, yapılan istek muhtemelen `$_GET['q']` ile eşleşen bir ada sahip belgeleri bulmak için veritabanını şu şekilde sorgulayacaktır:

![Pasted image 20241206200913.png](/img/user/resimler/Pasted%20image%2020241206200913.png)
![Pasted image 20241206200921.png](/img/user/resimler/Pasted%20image%2020241206200921.png)

Koleksiyondaki tüm türler için bilgileri listelemek istiyoruz ve back-end'in girdimizi nasıl işlediğine dair varsayımımızın doğru olduğunu varsayarsak, her şeyi bu şekilde eşleştirecek bir RegEx sorgusu kullanabiliriz:

![Pasted image 20241206200950.png](/img/user/resimler/Pasted%20image%2020241206200950.png)

Yeni isteği gönderdikten sonra, tüm mango türlerinin ve bunlara karşılık gelen gerçeklerin listelendiğini görmeliyiz.

![Pasted image 20241206201005.png](/img/user/resimler/Pasted%20image%2020241206201005.png)


### Alternative Queries

`name: {$ne: 'doesntExist'}` : doesntExist öğesinin hiçbir belge adıyla eşleşmediğini varsayarsak, bu tüm belgelerle eşleşecektir.

`name: {$gt: ''}` : Bu, adı boş bir stringden 'daha büyük' olan tüm belgelerle eşleşir

`name: {$gte: ''}` : Bu, adı boş bir string'den 'büyük veya eşit' olan tüm belgelerle eşleşir

`name: {$lt: '~'}` : Bu, ismin ilk karakterini bir Tilde karakteriyle karşılaştırır ve 'less' ise eşleşir. Bu her zaman çalışmaz, ancak bu durumda çalışır, çünkü Tilde yazdırılabilir en büyük ASCII değeridir ve koleksiyondaki tüm adların ASCII karakterlerinden oluştuğunu biliyoruz.

`name: {$lte: '~'}` : Yukarıdaki ile aynı mantık, ancak ek olarak adı ~ ile başlayan belgelerle eşleşir.



### Blind Data Extraction

### MangoPost

Sonraki iki bölümde MangoPost'a bakacağız. Bu web sitesi, veri çıkarmak için kullanacağımız Blind NoSQL enjeksiyonuna karşı savunmasızdır

Web sayfası, bir takip numarası girebileceğiniz ve gönderi hakkında bilgi alabileceğiniz basit bir paket takip uygulamasıdır

![Pasted image 20241206211020.png](/img/user/resimler/Pasted%20image%2020241206211020.png)

Bilinen bir takip numarasını (32A766??) arayabilir ve sunucuya ne gönderildiğini ve ne tür bilgiler aldığımızı görmek için talebi kesebiliriz.

İstek, girdiğimiz trackingNum değerini gönderir ve başka bir şey göndermez. Önceki iki örnekte olduğu gibi URL kodlu veri değil de bir JSON nesnesi gönderilmesi dikkat çekicidir.

![Pasted image 20241206211116.png](/img/user/resimler/Pasted%20image%2020241206211116.png)

Form gönderildiğinde sayfanın yenilenmediğini veya herhangi bir yere yönlendirilmediğini fark edebilirsiniz. Bunun nedeni, form verilerini bir JSON nesnesine dönüştüren, XMLHttpRequest ile bir POST isteği gönderen ve ardından sayfadaki trinfo öğesini güncelleyen sayfadaki bir JavaScript komut dosyasıdır. CTRL-U tuşlarına basarak veya viewsource:http://SERVER_IP:PORT/index.php adresine giderek görüntüleyebiliriz.

![Pasted image 20241206211222.png](/img/user/resimler/Pasted%20image%2020241206211222.png)

Paketleri ararken gönderdiğimiz tek bilginin trackingNum olduğunu bildiğimize göre, backend'de çalıştırılan sorgunun buna benzer bir şey olduğunu varsayabiliriz:

![Pasted image 20241206211310.png](/img/user/resimler/Pasted%20image%2020241206211310.png)

Buradaki NoSQL enjeksiyonu zaten açık olmalıdır. Bazı paketlerin takip bilgilerini döndürmek için daha önce ele aldığımız teknikleri kullanabiliriz

Ancak bu bölüm için trackingNum'un ne olduğunu öğrenmek istiyoruz. trackingNum bize döndürülen bilgilere dahil edilmediği için bunu doğrudan bulamayız. Ancak yapabileceğimiz şey, sunucunun bizim için değerlendireceği bir dizi “doğru/yanlış” isteği göndermektir.

Örneğin, sunucuya $ne: 'x' ile eşleşen bir trackingNum olup olmadığını sorabiliriz ve sunucu paket bilgisi ile yanıt verir.

![Pasted image 20241206211610.png](/img/user/resimler/Pasted%20image%2020241206211610.png)

Aynı şekilde, sunucuya $eq: 'x' ile eşleşen bir trackingNum olup olmadığını sorabiliriz ve beklendiği gibi sunucu bize böyle bir paket olmadığını söyleyecektir.

![Pasted image 20241206211636.png](/img/user/resimler/Pasted%20image%2020241206211636.png)

Bu noktada, sunucuya verdiğimiz rastgele bir sorguyla eşleşen bir trackingNum olup olmadığını sorabileceğimizi ve sunucunun bize evet ya da hayır diyeceğini biliyoruz. Buna oracle diyoruz. İstediğimiz bilgiyi doğrudan alamayız (trackingNum), ancak bilgiyi dolaylı olarak sızdırmak için sunucunun yanıtlarını kullanarak keyfi sorgular sağlayabiliriz.

Not : 

- **`$eq: 'x'`:** Sadece `field = 'x'` olan kayıtları bulur.
- **`$ne: 'x'`:** `field ≠ 'x'` olan kayıtları bulur ve daha geniş bir arama yapar.

Bu yüzden `$eq` ile sorguladığınızda bulamadığınız bir kaydı `$ne` ile bulabilirsiniz, çünkü `$ne` daha esnektir.


### Franz'ın Takip Numarasının Sızdırılması

Bu bölümün başlarında 32A766?? takip numarasını kullanmıştık. Şimdi bu numarayı bilmediğimiz takdirde nasıl sızdırabileceğimize bakalım.

İlk sorgumuz için `{“trackingNum”:{“$regex”:“^.*”}}` gönderebiliriz. ve tüm belgelerle eşleşecektir. Bize geri dönen belge Franz Pflaumenbaum'a gönderilmiştir. Koleksiyonda birden fazla paket olabilir, bu nedenle aynı paketten bilgi sızdırdığımızdan emin olmak için doğru paketi hedeflediğimizden emin olmak için sunucunun yanıtında Franz Pflaumenbaum'u arayacağız.
![Pasted image 20241206212006.png](/img/user/resimler/Pasted%20image%2020241206212006.png)

Bir sonraki sorgumuzda, trackingNum'ın 0 ile başlayıp başlamadığını görmek için {“trackingNum”:`{“$regex”:“^0.*”}}` göndereceğiz. Bu, Bu takip numarası mevcut değil sonucunu döndürür, bu da koleksiyonda 0 ile başlayan hiçbir takip numarası olmadığı anlamına gelir, bu yüzden bunu sayabiliriz

Ardından, `{“trackingNum”:{“$regex”:“^3.*”}}` değerine ulaşana kadar bunu 1, 2 ile tekrarlayacağız. Franz'ın paket bilgilerini döndürür. Artık takip numarasının 3 ile başladığını biliyoruz.

![Pasted image 20241206212116.png](/img/user/resimler/Pasted%20image%2020241206212116.png)

İkinci haneye geçelim. “`trackingNum“:{”$regex“:”^30.*“}}` isteği Bu takip numarası mevcut değil, bu yüzden ikinci rakamın 0 olmadığını biliyoruz, ancak Franz'ın paket bilgilerini döndüren `{”trackingNum“:{”$regex“:”^32.*"}}` isteğine ulaşana kadar karakterleri denemeye devam edebiliriz, bu da takip numarasındaki bir sonraki karakterin 2 olduğu anlamına gelir.

![Pasted image 20241206212228.png](/img/user/resimler/Pasted%20image%2020241206212228.png)

Tüm paket numarası dökülene kadar bu işleme devam edebiliriz. Paket numarasının yalnızca rakamlar değil harfler de içerdiğine dikkat edin. Bir stringin sonunu işaretlemek için düzenli ifadeye bir dolar işareti ( $ ) eklenir, bu nedenle bu durumda trackingNum'ın tamamının döküldüğünü doğrulayabiliriz.

![Pasted image 20241206212321.png](/img/user/resimler/Pasted%20image%2020241206212321.png)

![Pasted image 20241206212326.png](/img/user/resimler/Pasted%20image%2020241206212326.png)


### Blind Data Extraction'ın Otomatikleştirilmesi


### Scenario

Blind injection yoluyla manuel olarak veri ayıklamak çok hızlı bir şekilde sıkıcı hale gelir. Neyse ki, bu çok kolay bir şekilde otomatikleştirilebilir, o yüzden bunu yapalım.

Franz'ın paketi için trackingNum'u zaten dump ettik, bu yüzden bu bölüm için yeni bir hedef kullanacağız. HTB{... takip numarası ile bmdyy adresine gönderilmiş bir paket var ve biz bunu dökeceğiz.

![Pasted image 20241206224644.png](/img/user/resimler/Pasted%20image%2020241206224644.png)

Eğer zaten biraz Python(3) biliyorsanız bu süper, ancak bu bölüm bilmeseniz bile anlayabileceğiniz kadar basit olmalıdır.


### Senaryonun Geliştirilmesi

Yapacağımız ilk şey 'oracle'ı sorgulamak için bir fonksiyon oluşturmaktır.

![Pasted image 20241206224803.png](/img/user/resimler/Pasted%20image%2020241206224803.png)

Bu fonksiyon /index.php adresine bir POST isteği gönderir ve trackingNum değerini istediğimiz sorguya ayarlar. Daha sonra yanıtın bmdyy metnini içerip içermediğini kontrol eder, bu da sorgumuzun hedef paketimizle eşleştiğini gösterir.

Bilinen yanıtları test eden bir çift [assert](https://www.tutorialspoint.com/python/python_assertions.htm) deyimi ile oracle fonksiyonunun amaçlandığı gibi çalışıp çalışmadığını doğrulayabiliriz. Bu durumda, X diye bir takip numarası olmadığını biliyoruz, dolayısıyla oracle'ın trackingNum: “X” . Ayrıca, bir HTB{.* takip numarası olduğunu biliyoruz, bu nedenle oracle fonksiyonunun True döndürdüğünü doğrulayabiliriz.

![Pasted image 20241206224938.png](/img/user/resimler/Pasted%20image%2020241206224938.png)

Bunu çalıştırırsak ve her şey doğru ayarlanmışsa, çıktı olmaması gerekir. Eğer bir çıktı alıyorsanız, büyük olasılıkla kodunuzda bir yazım hatası vardır (bu örnekte olduğu gibi, B yerine küçük harf b):

![Pasted image 20241206225959.png](/img/user/resimler/Pasted%20image%2020241206225959.png)

Oracle fonksiyonunu hazırladıktan ve doğru çalıştığını doğruladıktan sonra, takip numarasını gerçekten dump etmek için çalışmaya devam edebiliriz.

Bu bölüm için, takip numarasının aşağıdaki formatla eşleştiğini varsayabiliriz:
{ #HTB}
\ {[0-9a-f]{32}\}$ diğer adıyla HTB{ ardından 32 karakter [ 0-9a-f ] ardından a } . Bunu bilerek, aramamızı yalnızca bu karakterlerle sınırlayabilir ve alacağı istek sayısını önemli ölçüde azaltabiliriz.

![Pasted image 20241206230055.png](/img/user/resimler/Pasted%20image%2020241206230055.png)
![Pasted image 20241206230102.png](/img/user/resimler/Pasted%20image%2020241206230102.png)

Bu kod RegEx sorguları oluşturacak ve tüm karakterler bilinene kadar her seferinde bir karakter dumb için oracle'ı kullanacaktır. Kod tamamlandığında, takip numarasının doğru olduğunu başka bir assert ile doğrulayabilir ve yazdırabiliriz:

![Pasted image 20241206230129.png](/img/user/resimler/Pasted%20image%2020241206230129.png)


### The finished script
Her şeyi bir araya getirdiğinizde, tamamlanan komut dosyası şöyle görünmelidir:

![Pasted image 20241206230200.png](/img/user/resimler/Pasted%20image%2020241206230200.png)
![Pasted image 20241206230204.png](/img/user/resimler/Pasted%20image%2020241206230204.png)

Bu script çalıştırıldığında takip numarası başarıyla dökülmelidir. Alfabe ( 0- 9a-f ) çok küçük olduğundan, işlem çok hızlı ilerler; bu durumda, sadece yaklaşık 20 saniye sürer.

![Pasted image 20241206230227.png](/img/user/resimler/Pasted%20image%2020241206230227.png)


### Server-Side JavaScript Injection

NoSQL'e özgü bir enjeksiyon türü JavaScript Enjeksiyonudur. Bu, bir saldırganın sunucunun veritabanı context'inde keyfi JavaScript çalıştırmasını sağlayabildiği durumdur. JavaScript enjeksiyonu elbette senaryoya bağlı olarak in-band, blind ya da out-of-band olabilir. Bunun hızlı bir örneği, kullanıcı adı/şifre kombinasyonlarını kontrol etmek için $where sorgusunu kullanan bir sunucu olabilir:

![Pasted image 20241206230420.png](/img/user/resimler/Pasted%20image%2020241206230420.png)

Bu durumda, kullanıcı girdisi `$where` tarafından değerlendirilen JavaScript sorgusunda kullanılır ve JavaScript enjeksiyonuna yol açar. Bir saldırgan burada birçok şey yapabilir. Örneğin, kimlik doğrulamasını atlamak için kullanıcı adı ve parola olarak `“ || ‘’==”` geçebilir, böylece sunucu `db.users.find({$where: 'this.username == “” || “”==“” && this.password == “” || “”==“”'})` öğesini değerlendirerek her belgenin döndürülmesine ve muhtemelen saldırganın döndürülen kullanıcılardan biri olarak oturum açmasına neden olabilir


### MangoOnline

Bu bölümde, dördüncü web uygulaması olan MangoOnline'a bakacağız. Bu uygulama Server-Side JavaScript Injection'a karşı savunmasızdır.

Sitenin kendisi sadece bir giriş formu ve bakılacak başka bir şey yok

![Pasted image 20241206230747.png](/img/user/resimler/Pasted%20image%2020241206230747.png)


### Authentication Bypass

Formu rastgele verilerle doldurabilir ve daha iyi bir görünüm elde etmek için oturum açma isteğini engelleyebiliriz. İstek, kimlik doğrulama bypass bölümündeki MangoMail için olana benziyor.

![Pasted image 20241206230907.png](/img/user/resimler/Pasted%20image%2020241206230907.png)

Bununla birlikte, daha önce olduğu gibi aynı kimlik doğrulama atlama yöntemlerini denersek, ne yazık ki hiçbirinin çalışmadığını fark edeceğiz. Bu noktada, sunucunun $where sorgusu çalıştırması durumunda bazı SSJI payload'larının çalışıp çalışmadığını kontrol etmek isteyebiliriz, bu da aşağıdaki gibi görünebilir:

![Pasted image 20241206230956.png](/img/user/resimler/Pasted%20image%2020241206230956.png)

Bu örnek için, kullanıcı adını `“ || true || ‘’==”` olarak ayarlayabiliriz, bu da this.username ve this.password ne olursa olsun sorgu deyiminin her zaman True döndürmesiyle sonuçlanacaktır.

![Pasted image 20241206231025.png](/img/user/resimler/Pasted%20image%2020241206231025.png)

Bu sadece değerlendirilen JavaScript olduğundan, tarayıcımızdaki geliştirici konsolunu kullanarak ifadenin her zaman true döndürmesi gerektiğini doğrulayabiliriz:

![Pasted image 20241206231047.png](/img/user/resimler/Pasted%20image%2020241206231047.png)

Beklendiği gibi, this.username ve this.password tanımsız olsa bile ifade True döndürür. Bu onay ile, gerekli karakterleri URL ile kodlamaya dikkat ederek bu “kullanıcı adı” ve rastgele bir parola ile oturum açmayı deneyebiliriz.

![Pasted image 20241206231139.png](/img/user/resimler/Pasted%20image%2020241206231139.png)

Bu, $where sorgusu tüm belgelerde True döndürdüğü için kimlik doğrulamayı tamamen atlayabilmemizle sonuçlanmalıdır.

Payload : `" || true || " == "`

![Pasted image 20241206231430.png](/img/user/resimler/Pasted%20image%2020241206231430.png)

Giriş yaptığımız kişinin (hangi belgeyle eşleştiysek) gerçek kullanıcı adının görüntülenmediğine dikkat edin. Bunun yerine kullandığımız SSJI payload'u görüntülenir.


### Blind Data Extraction

Böylece, Server-Side Javascript Injection ile kimlik doğrulamayı atlayabileceğimizi kanıtladık ve giriş yaptığımız kullanıcının kullanıcı adının bize verilmediğini tespit ettik, şimdi bu bilgiyi çıkarmaya çalışalım!

Bunu yapmak için gereken adımlar temelde Blind Data Extraction ve Automating Blind Data Extraction bölümlerindeki adımlarla aynıdır, sadece farklı sözdizimine sahiptir.

İlk istek olarak, payload'u kullanabiliriz: `“ || (this.username.match('^.*')) || “”==”` ile `^.*`  eşleşen bir kullanıcı adı olduğunu doğrulamak için. Bunun true döndürmesi (oturum açmamız) beklenir, bu yüzden daha çok bir sağlık kontrolüdür.

![Pasted image 20241206231650.png](/img/user/resimler/Pasted%20image%2020241206231650.png)

Daha sonra, kullanıcı adının ilk karakterinin ne olduğunu aşağıdaki gibi payload'larla tahmin etmeye başlayabiliriz: `“ || (this.username.match('^a.*')) || “”==”` . Böyle bir kullanıcı adı yoksa, `^a.*` ile olduğu gibi, uygulama oturum açmada başarısız olur

![Pasted image 20241206231742.png](/img/user/resimler/Pasted%20image%2020241206231742.png)

Biraz denedikten sonra, payload: `“ || (this.username.match('^H.*')) || “”==”` bizi oturum açar, yani `^H.*` ile eşleşen bir kullanıcı adı vardır.

![Pasted image 20241206231828.png](/img/user/resimler/Pasted%20image%2020241206231828.png)

Bu adımlara devam ederek, tüm kullanıcı adını dökebiliriz


### **Server-Side JavaScript Enjeksiyonunu Otomatikleştirme**

### Developing the Script
