---
{"dg-publish":true,"permalink":"/web-pentest-expert/ldap-injection/"}
---


# Introduction to LDAP Injection

Lightweight Directory Access Protocol (LDAP), Active Directory (AD) gibi dizin sunucularına erişmek için kullanılan bir protokoldür. Özellikle, LDAP sorguları dizin sunucularından bilgi alabilir. Web uygulamaları, kimlik doğrulama veya veri alma amacıyla AD veya diğer dizin servisleriyle entegrasyon için LDAP kullanabilir. Kullanıcı girdisi LDAP sorgularına uygun sanitizasyon olmadan eklenirse, LDAP Injection güvenlik açıkları ortaya çıkabilir.


## LDAP Temelleri

Önemli LDAP terminolojisini belirleyerek başlayalım:

* Bir ==Directory Server (DS)==, verilerin depolanma şekli farklı olsa da, bir veritabanı sunucusuna benzer şekilde verileri depolayan varlıktır. Bir DS örneği [OpenLDAP](https://www.openldap.org/)'dir
* Bir LDAP Entry'si bir varlık için veri tutar ve üç ana bileşenden oluşur:
	* ==Distinguished Name (DN)==, birden fazla ==Relative Distinguished Names== (RDN)'den oluşan giriş için benzersiz bir tanımlayıcıdır. Her RDN key-value çiftlerinden oluşur. Örnek bir DN, virgülle ayrılmış üç RDN'den oluşan ==uid=admin,dc=hackthebox,dc=com=='dur 
	* Veri depolayan Multiple ==Attributes== (Çoklu Öznitelikler). Her attribute, bir attribute type ve bir dizi değerden oluşur
	* Birden fazla ==Object Classes==, belirli bir object türüyle ilgili olan attribute türlerinden oluşur, örneğin Person veya Grup.

#### LDAP Search Filter Syntax
LDAP arama sorguları  ==search filters== (arama filtreleri) olarak adlandırılır. Bir arama filtresi, her biri parantez () içinde yer alması gereken birden fazla bileşenden oluşabilir. Her temel bileşen, bir ==attribute==, bir ==operand== ve aranacak bir ==değerden (value)== oluşur. LDAP, aşağıdaki temel operand'ları tanımlar:

| İsim             | Operand | Örnek          | Açıklama                                                                                 |
| ---------------- | ------- | -------------- | ---------------------------------------------------------------------------------------- |
| Eşitlik          | =       | (name=Kaylie)  | Kaylie değerine sahip bir name attribute içeren tüm girişleri eşleştirir.                |
| Büyük-Eşit       | >=      | (uid>=10)      | uid özelliği 10'a eşit veya daha büyük olan tüm girişleri eşleştirir.                    |
| Küçük-Eşit       | <=      | (uid<=10)      | uid özelliği 10'a eşit veya daha küçük olan tüm girişleri eşleştirir.                    |
| Yaklaşık Eşleşme | ~=      | (name~=Kaylie) | Kaylie değerine yaklaşık olarak sahip bir name özelliği içeren tüm girişleri eşleştirir. |

Not: LDAP spesifikasyonu, yaklaşık eşleşmenin nasıl uygulanması gerektiğini tanımlamaz. Bu, farklı LDAP uygulamaları arasında tutarsızlıklara yol açar ve aynı arama filtresi farklı sonuçlar verebilir.

Daha karmaşık arama filtreleri oluşturmak için LDAP ayrıca aşağıdaki kombinasyon operandlarını da destekler:

| İsim  | Operatör | Örnek                          | Örnek Açıklama                                                                                                           |
| ----- | -------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |
| Ve    | (&()())  | & (name=Kaylie)(title=Manager) | Kaylie değeri olan bir name attribute ve Manager değeri olan bir title attribute içeren tüm kayıtları eşleştirir         |
| Veya  | (        | ()())                          | Kaylie değerine sahip bir name attribute veya Manager değerine sahip bir title attribute içeren tüm girdileri eşleştirir |
| Değil | (!())    | !(name=Kaylie)                 | Kaylie değeri olmayan bir name özelliği içeren tüm kayıtları eşleştirir                                                  |

Not: And ve Or filtreleri ikiden fazla bağımsız değişkeni destekler. Örneğin, `(&(attr1=a)(attr2=b)(attr3=c)(attr4=d))` geçerli bir arama filtresidir.

Ayrıca, True ve False değerlerini şu şekilde görüntüleyebiliriz:

|Name|Filter|
|---|---|
|True|`(&)`|
|False|`(\|)`|

Son olarak, LDAP wildcard olarak yıldız işaretini destekler, böylece aşağıdaki gibi wildcard arama filtreleri tanımlayabiliriz:

| Örnek        | Örnek Açıklama                                                            |
| ------------ | ------------------------------------------------------------------------- |
| `(name=*)`   | Bir name attribute'u içeren tüm kayıtları eşleştirir                      |
| `(name=K*)`  | K ile başlayan bir name attribute'u içeren tüm kayıtları eşleştirir       |
| `(name=*a*)` | İçerisinde a bulunan bir name attribute'u içeren tüm kayıtları eşleştirir |

Search filtreleri hakkında daha fazla bilgi için RFC 4515'e göz atın.


#### Common Attribute Types

İşte arayabileceğimiz bazı yaygın attribute  türleri. Liste kapsamlı değildir. Ayrıca, LDAP sunucu örnekleri, arama filtrelerinde kullanılabilecek özel attribute türleri uygulayabilir.

|Attribute Type|Description|
|---|---|
|`cn`|Full Name|
|`givenName`|First name|
|`sn`|Last name|
|`uid`|User ID|
|`objectClass`|Object type|
|`distinguishedName`|Distinguished Name|
|`ou`|Organizational Unit|
|`title`|Title of a Person|
|`telephoneNumber`|Phone Number|
|`description`|Description|
|`mail`|Email Address|
|`street`|Address|
|`postalCode`|Zip code|
|`member`|Group Memberships|
|`userPassword`|User password|
LDAP attribute türlerine ayrıntılı bir genel bakış için [RFC 2256](https://www.rfc-editor.org/rfc/rfc2256.txt)'ya göz atın.


# LDAP - Authentication Bypass

Artık LDAP search filtrelerinin nasıl çalıştığı hakkında temel bir fikrimiz olduğuna göre LDAP injection ile başlayalım. LDAP injection'ın temel bir örneği web kimlik doğrulamasını atlamaktır. Önceki bölümde tartışıldığı gibi, LDAP web uygulamalarında AD kullanıcılarının kimlik doğrulamasını etkinleştirmek için yaygın olarak kullanılır. Bu nedenle, birçok web uygulaması LDAP kimlik doğrulamasını destekler.


## Temeller

Web kimlik doğrulamasını atlamak için LDAP enjeksiyonunun exploit edilmesini tartışmadan önce, kimlik doğrulama için kullanılan bir search filtresinin neye benzeyebileceğini tartışalım. Kimlik doğrulama işleminin username ve password kontrol etmesi gerektiğinden, aşağıdaki gibi bir LDAP search filtresi kullanılabilir:

```ldap
(&(uid=admin)(userPassword=password123))
```

Dizin sunucusunun yapılandırmasına bağlı olarak, gerçek arama filtresi farklı attribute türlerini sorgulayabilir. Örneğin, kullanıcı adı `cn` attribute türü ile karşılaştırılabilir.


## Exploitation

Aşağıdaki laboratuvarı başlatırken, bir OpenLDAP sunucusuyla entegre edilmiş bir login işlemi uygulayan basit bir web uygulaması görebiliriz:

![Pasted image 20250213163610.png](/img/user/resimler/Pasted%20image%2020250213163610.png)

Web uygulaması LDAP entegrasyonunu bize bildirdiğinden, kimlik doğrulamasını geçmek için arama filtresine ne enjekte edebileceğimizi düşünelim. Çünkü yıldız işareti bir ==wildcard== karakteri olarak işlenir, bu yüzden gerçek şifreyi belirtmeden değeri eşleştirmek için şifre alanına enjekte edebiliriz. Ardından, kimlik doğrulamasını o kullanıcı için geçmek amacıyla geçerli bir kullanıcı adı belirtebiliriz. Eğer kullanıcı adı olarak ==admin== ve şifre olarak * belirtirsek, web uygulaması aşağıdaki LDAP arama filtresini çalıştırır:

```ldap
(&(uid=admin)(userPassword=*))
```

İsteği gönderdiğimizde, backend'in bizi oturum açma sonrası sayfasına yönlendirdiğini görebiliriz, bu da kimlik doğrulamayı başarıyla atladığımızı ve admin kullanıcısı olarak oturum açtığımızı gösterir:

![Pasted image 20250213164022.png](/img/user/resimler/Pasted%20image%2020250213164022.png)

Geçerli bir kullanıcı adı bilmiyorsak, kullanıcı adı alanına da bir joker karakter ekleyerek aşağıdaki LDAP arama filtresini elde edebiliriz:

```ldap
(&(uid=*)(userPassword=*))
```

Bu arama filtresi, ==uid== ve ==userPassword== attribute'ine sahip tüm girdileri eşleştirir, böylece mevcut tüm kullanıcılarla eşleşir. Bu durumda, büyük olasılıkla sonuç listesindeki ilk kullanıcı olarak oturum açacağız:

![Pasted image 20250213164328.png](/img/user/resimler/Pasted%20image%2020250213164328.png)

Son olarak, geçerli bir kullanıcı adının yalnızca bir substring'ini biliyorsak, örneğin admin kullanıcı adlarının rastgele karakterler eklenerek gizlendiği bir durumda, aşağıdaki gibi bir arama filtresi ile sonuç listesini daraltmak için kullanıcı adı alanında bir substring belirtebiliriz:

```ldap
(&(uid=admin*)(userPassword=*))
```

Bu arama filtresi, admin stringi ile başlayan bir uid alanı içeren tüm girişlerle eşleşir, böylece yukarıda açıklanan şaşırtma işlemini atlayarak admin kullanıcısı için başarılı bir oturum açma atlamasına yol açar:

![Pasted image 20250213164809.png](/img/user/resimler/Pasted%20image%2020250213164809.png)



#### Bypassing Authentication without Wildcards

Birçok durumda, aynı sonuca ulaşmanın farklı yollarını bilmek faydalıdır. Bu, karşılaştığımız potansiyel savunma önlemlerini aşmamıza olanak tanır. Örneğin, bazı durumlarda, bir yıldız işareti web uygulaması tarafından blacklist'e alınmış olabilir, bu yüzden yukarıda bahsedilen yöntemle kimlik doğrulamasını geçemeyiz. Neyse ki, wildcard karakterleri kullanmayan başka bir kimlik doğrulama geçiş yöntemi de vardır. Arama filtresini öyle değiştirirsek ki, şifre kontrolü başarısız olsa da arama filtresi yine de bir kullanıcı döndürsün, kimlik doğrulamasını geçebiliriz.

Örneğin, `admin)(|(&` kullanıcı adını ve `abc` şifresini belirtirsek, web uygulaması aşağıdaki arama filtresini kullanır:

```ldap
(&(uid=admin)(|(&)(userPassword=abc)))
```

Inject ettiğimiz payload nedeniyle, search filtresi, evrensel true operandını (`&`) ve false kullanıcı şifresini (`userPassword=abc`) içeren ek bir or (veya) ifadesi içeriyor. Şifre kontrolü, doğru şifreyi bilmediğimiz için false döner. Ancak, or ifadesinin ilk operandı evrensel olarak doğru olduğundan, or ifadesi de true döner. Böylece, yalnızca geçerli bir kullanıcı adı belirtmemiz yeterlidir, bu sayede wildcard karakteri kullanmadan kimlik doğrulamasını başarılı bir şekilde geçeriz.

![Pasted image 20250213165316.png](/img/user/resimler/Pasted%20image%2020250213165316.png)


# LDAP - Data Exfiltration & Blind Exploitation

Bir önceki bölümde LDAP injection kullanarak kimlik doğrulamayı nasıl atlayacağımızı tartıştığımıza göre, bu bölümde data exfiltrasyonuna odaklanacağız. LDAP aramasının sonucu bize gösterilmese bile, blind SQL enjeksiyonları için kullanılana benzer bir metodoloji ile veri sızdırmak hala mümkündür.

Tıpkı XPath enjeksiyonunda olduğu gibi, LDAP'de sleep fonksiyonu yoktur, bu nedenle web uygulaması tarafından sorgunun herhangi bir sonuç döndürüp döndürmediğini bize bildiren bir göstergeye ihtiyacımız vardır. Bu bize biraz bilgi sızdırır, bu da görüntülenmeden veri sızdırmamızı sağlar.

## Data Exfiltration

Web uygulamasının sonuçları bize gösterdiği bir senaryoda, belirtilen attribute'e sahip tüm girdileri eşleştirmek için bir wildcard enjekte edebileceğimizden data exfiltrasyonu basittir. Aşağıdaki gibi bir arama filtresi düşünün, burada kullanıcı adını uid attribute'e girebiliriz:


```ldap
(&(uid=admin)(objectClass=account))
```

Kullanıcı adı olarak sadece bir wildcard karakteri verirsek, arama filtresi aşağıdaki gibi olacağından web uygulaması tüm hesaplarla ilgili ayrıntıları görüntüleyecektir:

```ldap
(&(uid=*)(objectClass=account))
```

Bir arama filtresinin ==or== cümlesine bir payload enjekte edebilirsek aynı etkiyi elde edebiliriz. Bunun gibi bir arama filtresi düşünün:

```ldap
(|(objectClass=organization)(objectClass=device))
```

Bu arama filtresi tüm organizasyon ve cihaz girişleriyle eşleşir. Payload'umuz ikinci objectClass attribute'üne inject edilirse, search filter aşağıdaki gibi görünecek şekilde bir joker karakter enjekte ederek backend'i tüm girdileri sızdırmaya zorlayabiliriz:

```ldap
(|(objectClass=organization)(objectClass=*))
```

Bu nedenle, web uygulamasının arama filtresinin sonuçlarını bize göstermesi koşuluyla veri sızıntısı basittir.


## Blind Exploitation

Şimdi LDAP enjeksiyon açıklarının blind exploitation'ının daha gelişmiş ve gerçekçi durumlarını tartışalım. Aşağıdaki laboratuvarı başlatırken, önceki bölümdeki laboratuvarın biraz değiştirilmiş bir versiyonunu görebiliriz. Giriş yapmaya çalıştığımızda, admin önceki bölümdeki LDAP enjeksiyonu hakkında bilgilendirilmiş gibi görünüyor, bu nedenle site bakım modunda:

![Pasted image 20250213170134.png](/img/user/resimler/Pasted%20image%2020250213170134.png)

Ancak, geçersiz kimlik bilgileri sağlarsak web uygulaması farklı yanıt verir:

Dizin sunucusundan veri sızdırmak için yanıttaki bu farktan yararlanabiliriz. Kimlik doğrulama için kullanılan arama filtresinin aşağıdakine benzediğini unutmayın:

```ldap
(&(uid=htb-stdnt)(password=p@ssw0rd))
```

Parola olarak bir wildcard sağlayarak web uygulamasının LDAP enjeksiyonuna karşı hala savunmasız olduğunu doğrulayabiliriz:

![Pasted image 20250213170225.png](/img/user/resimler/Pasted%20image%2020250213170225.png)

Artık substring arama filtreleri ekleyerek parolayı karakter karakter brute-force edebiliriz. Parolayı a* olarak ayarlayarak ilk karakterle başlayabiliriz, bu da aşağıdaki arama filtresiyle sonuçlanır:

```ldap
(&(uid=htb-stdnt)(password=a*))
```

Bu search filtresi, kullanıcının şifresi a ile başlıyorsa veri döndürür, aksi takdirde döndürmez. Girişin başarılı olup olmadığını belirlemek için web uygulamasını gözlemleyebiliriz. Bizim durumumuzda, başarısız olmuştur:

![Pasted image 20250213170308.png](/img/user/resimler/Pasted%20image%2020250213170308.png)

Şimdi parolanın ilk karakterini belirlemek için tüm alfabe boyunca (rakamlar ve özel karakterler dahil) döngü yapmamız gerekiyor. Bizim durumumuzda, bu p'dir:

![Pasted image 20250213170321.png](/img/user/resimler/Pasted%20image%2020250213170321.png)

Şimdi arama filtresini aşağıdaki gibi değiştirerek ikinci karakteri brute-force yapabiliriz:

```ldap
(&(uid=htb-stdnt)(password=p@*))
```

Bizim durumumuzda, ikinci karakter bir @ karakteridir:

![Pasted image 20250213170354.png](/img/user/resimler/Pasted%20image%2020250213170354.png)

Şimdi, daha fazla karakter bulunmayana kadar bu işlemi recursive olarak tekrarlamamız gerekiyor, yani şifrenin tamamını ele geçirdik:

![Pasted image 20250213170426.png](/img/user/resimler/Pasted%20image%2020250213170426.png)

Ayrıca, farklı attribute'lerden veri sızdırmak da mümkündür. Örnek olarak, kullanıcımızın description attribute'a hedef alacağız. Eğer `htb-stdnt)(|(description=*` şeklinde bir kullanıcı adı ve invalid şeklinde bir şifre gönderirsek, ortaya çıkan arama filtresi aşağıdaki gibi olacaktır:

```ldap
(&(uid=htb-stdnt)(|(description=*)(password=invalid)))
```

Sağlanan parola yanlış olduğundan, enjekte edilen `or` cümlemiz yalnızca ==description== attribute için koşul doğruysa true döndürür. Bu artık, ==description== attribute'unu karakter karakter brute-force etmek için yukarıda tartışıldığı gibi aynı metodolojiyi uygulamamızı sağlar:

![Pasted image 20250213170649.png](/img/user/resimler/Pasted%20image%2020250213170649.png)


Not: Çoğu LDAP attribute'u büyük/küçük harf duyarsızdır. Bu nedenle, doğru harf büyük/küçük kullanımını gerektiren durumlarda, örneğin şifreler için, bunu brute-force  ile denememiz gerekebilir.

Belirttiğimiz kullanıcının herhangi bir attribute 'unu hedefleyebilir ve exfiltrate edebiliriz. Dahası, bir wildcard belirterek entry'mizde hangi attribute'ların bulunduğunu bile belirleyebiliriz. Geçerli attribute'lar için web uygulaması olumlu yanıt verir:

![Pasted image 20250213170902.png](/img/user/resimler/Pasted%20image%2020250213170902.png)

Ancak, web uygulaması geçersiz attributes için olumsuz yanıt verir:

![Pasted image 20250213170921.png](/img/user/resimler/Pasted%20image%2020250213170921.png)

Not: Blind XPath injection exploitation'a benzer şekilde, verileri bizim için dışarı sızdıracak bir script yazmanız önerilir.


# LDAP Injection Önleme

LDAP enjeksiyon açıklarından yararlanmanın farklı yollarını tartıştıktan sonra, bunları nasıl önleyeceğimizi tartışalım.


## Genel Açıklamalar

Web uygulamalarında SQL veritabanlarının yaygın kullanımı nedeniyle birçok web geliştiricisi SQL enjeksiyonu güvenlik açıklarının farkında olsa da, LDAP enjeksiyonu çok daha nadir bir güvenlik açığı türüdür ve bu nedenle bu konuda daha az farkındalık vardır. Bu nedenle, basit karşı önlemler olmasına rağmen, web uygulamalarında LDAP bütünleştirmesi kullanıldığında LDAP injection güvenlik açıkları potansiyel olarak mevcuttur. LDAP enjeksiyonu güvenlik açıklarını önlemek için aşağıdaki özel karakterlerden kaçınılması gerekir:

- **Parantez (** karakteri `\28` olarak kaçış karakteriyle işaretlenmelidir.
- **Parantez )** karakteri `\29` olarak kaçış karakteriyle işaretlenmelidir.
- **Yıldız `*` karakteri `\2a` olarak kaçış karakteriyle işaretlenmelidir.
- Ters eğik çizgi `\`  karakteri `\5c` olarak kaçış karakteriyle işaretlenmelidir.
- **Null byte** `\00` olarak kaçış karakteriyle işaretlenmelidir.


## PHP Example

Birçok dilde, LDAP escaping işlemini bizim için gerçekleştiren ön tanımlı işlevler vardır. PHP'de bu fonksiyon ldap_escape olarak adlandırılır. [Buradaki](https://www.php.net/manual/en/function.ldap-escape.php) belgelere göz atın.

Örnek olarak, LDAP injection'a karşı savunmasız olan aşağıdaki basitleştirilmiş kodu ele alalım:

```php
// ldap connection
const LDAP_HOST = "localhost";
const LDAP_PORT = 389;
const LDAP_DC = "dc=example,dc=htb";
const LDAP_DN = "cn=ldapuser,dc=example,dc=htb";
const LDAP_PASS = "ldappassword";

// connect to server
$conn = ldap_connect(LDAP_HOST, LDAP_PORT);
if (!$conn) {
    exit('LDAP connection failed');
}

// bind operation
ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);
$bind = ldap_bind($conn, LDAP_DN, LDAP_PASS);
if (!$bind) {
    exit('LDAP bind failed');
}

// search operation
$filter = '(&(cn=' . $_POST['username'] . ')(userPassword=' . $_POST['password'] . '))';
$search = ldap_search($conn, LDAP_DC, $filter);
$entries = ldap_get_entries($conn, $search);

if ($entries['count'] > 0) {
    // successful login
    <SNIP>
} else {
    // login failed
    <SNIP>
}
```

Arama işleminde, web uygulaması kullanıcı girdisini herhangi bir sterilizasyon yapmadan ekler, bu da son birkaç bölümde gördüğümüz ve exploit ettiğimiz gibi LDAP injection'a yol açar. Bunu önlemek için, kullanıcı girdisini arama filtresine eklerken `ldap_escape` fonksiyonunu çağırmamız yeterlidir. İlgili kod satırı bu nedenle aşağıdaki gibi görünmelidir:

```php
$filter = '(&(cn=' . ldap_escape($_POST['username']) . ')(userPassword=' . ldap_escape($_POST['password']) . '))';
```


## Best Practices

Uygun sterilizasyon LDAP enjeksiyonunu tamamen önlese de, bir web uygulamasında LDAP kullanıldığında izlememiz gereken bazı en iyi uygulamalar daha vardır. İlk olarak, DS'ye bağlanmak için kullanılan hesaba, spesifik görevimiz için arama işlemini gerçekleştirmek için gereken en az ayrıcalıkları vermeliyiz. Bu, bir LDAP enjeksiyonu açığı durumunda bir saldırganın erişebileceği veri miktarını sınırlar.

Ayrıca, kimlik doğrulama için LDAP kullanıldığında, bir arama işlemi gerçekleştirmek yerine kullanıcı tarafından sağlanan kimlik bilgileriyle bir bind işlemi gerçekleştirmek daha güvenlidir. DS, bir bind işlemi gerçekleştirirken kimlik bilgilerini kontrol ettiğinden, kimlik doğrulama işlemini bizim için gerçekleştirmesi için DS'ye devrediyoruz. Bu şekilde, LDAP enjeksiyonunun gerçekleşebileceği bir LDAP arama filtresi yoktur. Bunu yapmak için yukarıdaki örnek kodumuzu aşağıdaki gibi değiştirmemiz gerekir:

```php
// ldap connection
const LDAP_HOST = "localhost";
const LDAP_PORT = 389;
const LDAP_DC = "dc=example,dc=htb";

// user credentials
$dn = "cn=" . ldap_escape($_POST['username'], "", LDAP_ESCAPE_DN) . ",dc=example,dc=htb";
$pw = $_POST['password'];

// connect to server
$conn = ldap_connect(LDAP_HOST, LDAP_PORT);
if (!$conn) {
    exit('LDAP connection failed');
}

// bind operation
ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);
$bind = ldap_bind($conn, $dn, $pw);
if ($bind) {
    // successful login
    <SNIP>
} else {
    // login failed
    <SNIP>
}
```

Son olarak, anonim bind olarak da adlandırılan anonim kimlik doğrulama, DS'de devre dışı bırakılmalıdır, böylece yalnızca kimliği doğrulanmış kullanıcılar herhangi bir işlem gerçekleştirebilir.
