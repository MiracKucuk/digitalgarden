---
{"dg-publish":true,"permalink":"/web-pentest-expert/parameter-logic-bugs/"}
---

Web uygulama testlerinde, güvenlik açıklarını veya hataları test ederken ve belirlerken genellikle kuralları ve teknikleri takip ederiz. Ancak, bazı hatalar ''logic bugs'' kategorisine girer ve bu hataları tespit etmek oldukça zordur çünkü bu hatalar temel olarak mantık hatalarından kaynaklanır.

Karmaşıklıklarına rağmen, mantık hatalarının kapsamlı bir şekilde anlaşılması, bunların tanımlanması için kılavuzlar oluşturmamızı sağlar. Ayrıca, web uygulaması geliştirme sırasında güvenli bir kodlama metodolojisine bağlı kalmak, mantık hatalarını ortadan kaldırmaya veya azaltmaya yardımcı olarak mantık hataları olmayan sağlam uygulamaların oluşturulmasını sağlayabilir.

Bu konu kulağa kafa karıştırıcı ve bunaltıcı gelebileceğinden, mantık hatalarını açıklayarak başlayalım ve onları daha iyi anlamak için bazı örnekler üzerinden gidelim.


## What are Logic Bugs?

Logic Bugs, bir uygulamanın kullanıcı girdisini veya etkileşimlerini işleme biçimindeki istenmeyen kusurlardır. Çökmelere neden olabilen yaygın hataların veya kod yürütülmesine yol açan yaygın güvenlik açıklarının aksine, mantık hataları bir uygulamanın normal koşullar altında nasıl davrandığını değiştirir.

Örneğin, ücretli özelliklere sahip bir uygulama düşünün. Uygulamanın kodundaki bir mantık hatası yanlışlıkla bu özelliklere ödeme yapılmadan erişilmesine izin verebilir. Uygulamanın akışındaki mantık hataları genellikle uygulamanın normal kullanımı yoluyla istismar edilebilirken (örn. yalnızca front-end), parametreyle ilgili mantık hataları genellikle istismar için özel araçlar gerektirir.

Bu tür kusurlar doğrudan güvenlik açığı oluşturmaz, uygulamayı çökerten veya bir arızaya neden olan açık hatalar da olmaz, daha ziyade yararlanabileceğimiz istenmeyen bir davranışa neden olurlar. Bu hatalar normal uygulama kullanımı sırasında gizli kalabilir ve görünürde hiçbir soruna yol açmayabilir. Uygulama mükemmel bir şekilde çalışabilir ve kusurlarını yalnızca geliştiricinin ilk tasarım sırasında dikkate almamış olabileceği belirli koşullar altında ortaya çıkarabilir. Bu doğal incelik, mantık hatalarının tespit edilmesini özellikle zorlaştırır. Ayrıca, mantık hatalarının bir uygulamanın akışını ve davranışını etkilediğini anlamak ve bunları çökmelere veya arızalara neden olan sorunlardan ayırmak çok önemlidir.

Otomatik araçların avantajları olsa da, mantık hatalarını tespit etmek benzersiz bir zorluk teşkil eder, çünkü genellikle bir uygulamanın kod tabanı ve tasarımındaki karmaşık mantığı tam olarak kavramakta, ayrıştırmakta ve birbirine bağlamakta zorlanırlar. Ancak, Yapay Zeka (AI) alanındaki son gelişmelerle birlikte bu durum yakında değişebilir.

Mantık hatalarını tespit etmeye yönelik en güvenilir yaklaşım, insan uzmanlığı ve mantığına dayanmaya devam etmektedir. Bu beceriler, kod tabanı incelemeleri ve statik testler de dahil olmak üzere bu modül boyunca keşfedeceğimiz rehberlik ve uygulamalarla birlikte, mantık hatalarını etkili bir şekilde belirleme ve ele alma arayışımızda çok önemlidir.


### Önemsiz Bir Örnek

![Pasted image 20241218225116.png](/img/user/resimler/Pasted%20image%2020241218225116.png)

Yukarıdaki, oldukça komik olsa da temel bir Logic Bug örneğidir. Muhtemelen etkisi tam olarak anlaşılmadan yazılan tek bir kod satırı bu hataya yol açmıştır. Geliştiriciler şifre veritabanı parametresi için unique() anahtar kelimesini kullanmış olabilirler, bu da her kullanıcının şifresinin diğerlerinden farklı olmasını gerektirir! Bu anahtar kelime genellikle e-postalar ve kullanıcı adları için kullanılır, çünkü bu tür parametrelerin benzersiz olması gerekir. Ancak, bu durumda, ister bir aksilik ister kasıtlı olsun, bu mantık hatasına neden oldu.

Ayrıca, uygulama ayrıntılı loglama ile yapılandırılmış olmalıdır, çünkü front-end kullanıcılarına daha genel bir hata göstermek yerine (örn. Parola benzersiz değil) doğrudan veritabanı hatasını gösteriyor gibi görünmektedir. Bu basit örnek bize mantık hatalarının özünü, küçük aksilikler nedeniyle nasıl ortaya çıktıklarını ve hassas işlevlerde bulunduklarında ne kadar etkili olabileceklerini göstermektedir “bu durumda başka bir kullanıcının şifresini açığa çıkarmak”.


### Gerçek Dünyadan Bir Örnek ( Piyasaya Sürülmemiş iPhone'lar)

Not: Web sitesinin kimliğini korumak için bazı gerçekleri ve savunmasız bileşenleri değiştireceğim; ancak fikir ve konsept aynı olmalıdır.

Karşılaştığım ilk web mantık hatası örneklerinden biri, elektronik ürünler satan bir çevrimiçi e-mağazadaydı (örneğin, Amazon, Walmart veya Target). iPhone 4'ün bizim bölgemizde piyasaya sürülmesine bir gün kalmıştı (o zamanlar piyasaya sürme işlemini daha uzun bir süreye yayıyorlardı) ve ürün sayfasında 'sepete ekle' düğmesi yerine yalnızca 'çok yakında' ifadesi yer alıyordu. Şahsen, ne zaman bir web uygulamasını mantık hatalarına karşı test etmeye çalışsam, her zaman 'Acaba ne olurdu...' diye başlarım ve bu yüzden bir şekilde bu 'yayınlanmamış' ürünü alışveriş sepetine eklemeyi başarırsam satın alma işlemini tamamlayıp tamamlayamayacağımı merak ettim.

'Yayınlanmamış' iPhone'u alışveriş sepetine eklemek basit bir client-side bypass işlemiydi. Başka bir ürün eklerken GET isteğindeki productId'yi değiştirdim ve yerine yayınlanmamış iPhone'un ürün kimliğini ekledim. Sepete eklendikten sonra, sepette “çok yakında” ibaresi yerine her bir iPhone seçeneği için mevcut miktarlar gösterildi. Sonuç olarak, istediğim iPhone konfigürasyonunu seçtim ve “mağazadan teslim al” seçeneğini seçtim çünkü “teslimat” seçenekleri yanlış görünüyordu, muhtemelen web uygulamasının “piyasaya sürülmemiş bir ürünü” işleyememesinden kaynaklanıyordu. Aşağıda saldırının genel akışını gösteren bir diyagram yer almaktadır:

![Pasted image 20241218225712.png](/img/user/resimler/Pasted%20image%2020241218225712.png)

Ödeme düğmesine tıkladığımda, back-end sunucusunun bu hatayı ele alacağından ve bana ürünün 'stokta olmadığı' veya 'temin edilemediği' bilgisini vereceğinden emindim. Ancak, sürpriz bir şekilde ödeme ayrıntıları sayfasına yönlendirildim ve satın alma işlemini tamamladım. Yine de siparişi otomatik olarak iptal edeceklerini düşünmüştüm. Ancak, iPhone ertesi gün piyasaya sürüldükten sonra, bir teslim alma randevusu ve bir satın alma onayı aldım. Böylece, bu hata iPhone 4'ü (benim bölgemde) piyasaya çıkış tarihinden önce satın alınabilir hale getirdi.

Ürünü teslim almadan önce bu olaydan bahsettim, ancak ödemesi yapıldığı için ürünün bana ait olduğunu bildirdiler. Sonuç olarak, bekleme sırasını atladım ve siparişi piyasaya sürülmeden önce verdim. Bu hatayı derhal bildirdim ve bir düzeltme önerdim. Ancak, çoğu zaman olduğu gibi, bu hatayı gidermek için herhangi bir adım atılmadı. Niyetim her zaman potansiyel mantık hatalarını tespit etmek ve bildirmekti, bunları kişisel kazanç için kullanmak değildi.


## Logic Bugs CVEs

iPhone 4 örneği mantık hatalarının sadece bir yönünü göstermektedir: çok daha fazlasını kapsayabilir ve daha önemli bir etkiye sahip olabilirler. Örneğin, macOS sistemleri, yalnızca kullanıcının izniyle kod yürütülmesine izin veren güçlü Code Execution korumasıyla tanınır. Bununla birlikte, 2021 yılında bir [security researcherlar,](https://objective-see.org/blog/blog_0x6A.html) saldırganların komut dosyalarını (#!) ile başlatarak ve bir yorumlayıcı (ör. /bin/bash) tanımlamayarak bu korumaları kolayca atlatmalarını sağlayan temel bir mantık hatası tespit etti.

![Pasted image 20241218233948.png](/img/user/resimler/Pasted%20image%2020241218233948.png)

Apple, System Policy yorumlayıcı olmadan komut dosyalarını işleyecek şekilde programlamamış ve bunları güvenli kabul etmiştir. Bu mantık hatası, Apple cihazlarında Code Execution korumasının atlanmasına olanak sağlamıştır. Ancak CVE-2021-30853, bu tür baypasları gerçekleştiren tek mantık hatası değildi. Bu 2014 yazısında ifşa edilen bir başka mantık hatası da aynı türden bir baypasla sonuçlanmıştır.

Hepsi mantığa dayandığından, web uygulamaları, mobil uygulamalar, işletim sistemleri, oyunlar veya şimdiye kadar geliştirilmiş herhangi bir bilgisayar programı sınırsız mantık hatası örneği içerebilir çünkü mantıkları her zaman kusurlu olabilir.


### Mantık Hatalarının Etkisi

Modül boyunca göreceğimiz gibi, mantık hatalarının etkisi küçük rahatsızlıklardan mali kayıplara, hesap ele geçirmeye, hizmet reddine, ayrıcalık yükseltmeye ve hatta uzaktan kod çalıştırmaya kadar değişebilir.

Birçok mantık hatası, yürürlükte olan belirli bir 'genellikle istenmeyen' güvenlik önlemi nedeniyle istismar edilemez olabilir. Bu tür durumlar için, kullanıcı rahatsızlığı dışında önemli bir etki olmayacaktır. Bununla birlikte, genel bir kural olarak, bir mantık hatasının etkisi, kusurlu fonksiyonun ve ilgili verilerin hassasiyeti ve önemi ile doğrudan ilişkilidir. Her zaman hassas işlevlerdeki veya ürün satın alma ya da kod yürütme gibi hassas verilerdeki mantık hatalarıyla ilgileniriz.

Bu modülün sonunda, kusurlu mantık tasarımının genellikle kritik mantık hatalarına yol açan güvensiz kodlama uygulamalarından kaynaklandığı sonucuna varacağız.


### Mantık Hatası Türleri

Şimdiye kadar mantık hataları hakkında temel bir anlayışa sahip olmalıyız. Bu bölümde farklı mantık hatalarını nasıl kategorize edebileceğimizi tartışacak, bunları tanımlamak için metodolojimizi tartışacak ve modülle birlikte takip etmek için lokal bir ortam kuracağız.

Mantık hatalarının, enjeksiyonlar veya kimlik doğrulama kusurları gibi diğer web güvenlik açıkları türleri kadar kapsamlı bir şekilde araştırılmadığını ve incelenmediğini belirtmek önemlidir. Bu nedenle, bu modülü yazarken, mantık hataları için yeni bir kategorizasyon ve tanımlama metodolojisi bulmamız gerekti; bu da çok sayıda mantık hatası raporunu, araştırma makalesini ve kendi deneyimlerimizi incelememizi ve gözden geçirmemizi gerektirdi. Bu tür çabaların sektörü mantık hataları konusundaki araştırmaları ilerletmeye yönlendireceğini ve burada oluşturduğumuz kategorizasyon ve metodolojilerin de buna yardımcı olacağını umuyoruz.

Mantık hatasının ne olduğu ve farklı türleri hakkında net bir tanıma sahip olmak, bu modül için çok önemlidir, çünkü neyin hata olarak nitelendirileceğini açıkça tanımlamamıza olanak tanır. Öyleyse, mantık hatalarının farklı nedenlerini tartışarak başlayalım ve ardından her birini kendi hata türüne göre kategorize edelim.



### Mantık Hatalarının Nedenleri

Şimdiye kadar gördüklerimizden, mantık hatalarının yalnızca web uygulamalarında değil, herhangi bir mantık içeren uygulamalarda bulunabileceğini biliyoruz. Bu, mantık hatalarının temelde her tür uygulamada bulunabileceği anlamına gelir.

Ayrıca, otomatik araçların mantık hatalarını tespit etmekte neden genellikle az ya da hiç değer sağlamadığını da anlayabiliyoruz. Bunun nedeni, bu hataların mantık tasarımındaki bir kusurdan kaynaklanmasıdır ve araçların böyle bir sorunu tespit edebilmek için uygulamanın mantığını ve tasarımını tamamen anlaması gerekmesidir. Aynı nedenle, Web Uygulama Güvenlik Duvarları (WAF) ve Antivirüs yazılımları gibi araçlar genellikle bu tür zafiyetlere karşı koruma sağlayamaz, çünkü mantık hatalarını istismar eden kötü niyetli davranışlar genellikle normal uygulama kullanımına benzer şekilde görünür.

Peki, mantık hatalarına tam olarak ne sebep olur? Tahmin edebileceğiniz gibi, tüm mantık hatalarının tek bir nedeni yoktur, ancak belirli kötü kodlama uygulamaları genellikle bu tür hatalara yol açar.

Mantık hatalarının belki de en önemli nedeni zayıf bir uygulama mantığı tasarımına sahip olmaktır. Ancak sağlam bir uygulama mantığı tasarlamak söylemek yapmaktan çok daha kolaydır, çünkü bunu yapmak için tüm uygulamanın akışını ve sürecini iyi anlamak gerekir. Modül boyunca, mantık hatalarından kaçınmak için daha sağlam bir mantık tasarımı oluşturmaya yardımcı olacak farklı ipuçları ve yöntemler sunacağız.

Zayıf bir mantık tasarımı, uygulamamızın belirli türdeki 'beklenmedik' girdileri veya koşulları nasıl ele alacağını bilmediği ve bir mantık hatasına yol açan yanlış eylemi/fonksiyonu varsayılan olarak seçebileceği anlamına gelebilir. Birçok geliştirici, uygulama mantığını yalnızca kullanım amacına uygun olarak tasarlama hatasına düşmekte ve kullanıcıların gerçekte neler yapabileceğini ya da kullanıcı eylemlerinin diğer olası sonuçlarını dikkate almamaktadır.

Zayıf bir mantık tasarımı, her olası senaryo ve girdi türünün uygun şekilde test edilmemesinden veya uygulamanın diğer girdi türlerini veya beklenmedik koşulları ele almak için varsayılan bir yola sahip olacak şekilde programlanmamasından da kaynaklanabilir. Örneğin, bir geliştirici belirli bir girdi türü için bir switch deyimi kullanabilir, ancak belirli bir durum için varsayılan bir yöntem kullanmaz. Ya da bir geliştirici if ve else if deyimlerini kullanabilir ancak genel bir else deyimine sahip olmayabilir. Bu, belirli hata türlerini yakalamak ancak genel bir catch deyimine sahip olmamak gibi kodlamanın diğer birçok alanında bulunabilir.

Zayıf mantık tasarımına ek olarak, diğer faktörler de mantık hatalarına yol açabilir. Buna bir örnek, web uygulamalarında front-end ve back-end mantığı arasında eşitlik olmamasıdır, bu da mantık iyi tasarlanmış olsa bile mantık hatalarına neden olabilir. Mantık hatalarının başka birçok nedeni vardır ve modül boyunca bunlardan bazılarını tartışacağız.


## Logic Bugs Types

Mantık hatalarını farklı türlere ayırmak için yukarıda belirtilen nedenleri göz önünde bulundurmamız gerekir. Birçok çevrimiçi kaynak ve araştırma makalesi, her tür web güvenlik açığını (örneğin enjeksiyonlar, dosya yüklemeleri, IDOR'lar, LFI, vb) da mantık hatası olarak kabul etmektedir. Bu temelde doğru olsa da, bir dosya yükleme güvenlik açığı bile bir mantık hatası olarak kabul edilebileceğinden (yükleme mantığı belirli dosya türlerini engellemediğinden), bu rotayı izlemeyeceğiz. Bu tür güvenlik açıkları genellikle enjeksiyonlar gibi zayıf filtrelemelerden ya da zayıf kullanıcı erişim kontrolü gibi zayıf yapılandırmalardan kaynaklanır. Bu nedenle, bu tür güvenlik açıklarını kendi tanımımıza göre mantık hataları olarak değerlendirmeyeceğiz.

Bunun yerine, esas olarak zayıf bir mantık tasarımının neden olduğu güvenlik açıklarına odaklanacağız. Ayrıca, bunu iki tür Mantık Hatasına ayıracağız: parametre manipülasyonu ve akış bypassları. Bu modülde, yalnızca aşağıdaki türlere sahip olan Parametre Manipülasyonu mantık hatalarına odaklanacağız:



### Parameter Logic Bugs

![Pasted image 20241218235618.png](/img/user/resimler/Pasted%20image%2020241218235618.png)

### Akış Mantığı Hataları

![Pasted image 20241218235630.png](/img/user/resimler/Pasted%20image%2020241218235630.png)

Bu kategorizasyon mantık hatalarının çoğunu kapsamalıdır. Çeşitli mantık hataları raporlarını inceledik ve çoğunun her zaman yukarıdaki kategorilerden birine girdiğini gördük. Bir sonraki bölümde, bu modül boyunca izleyeceğimiz metodolojiyi ve senaryoyu gözden geçireceğiz.

# Module Methodology

Şimdi, az önce tanımladığımız farklı türdeki mantık hatalarını belirlemek ve incelemek için bu modül boyunca kullanacağımız metodolojiyi ve bunu açıklamak için izleyeceğimiz senaryoyu tartışalım.

## Methodology

Bu modülde izleyeceğimiz metodoloji, Whitebox Pentesting'e Giriş modülünde tanımlanan ve dört ana adıma ayrılan Whitebox Pentesting Süreci ile oldukça benzerdir:

1. `Code Review`
2. `Local Testing`
3. `Proof of Concept`
4. `Patching & Remediation`

Her bir mantık hatası türünü ayrıntılı olarak açıklayarak başlayacağız ve nasıl görünebileceğine dair gerçek bir örnek vereceğiz. Ardından, yukarıdaki metodolojiyi/süreci aşağıdaki gibi takip edeceğiz:

![Pasted image 20241219003020.png](/img/user/resimler/Pasted%20image%2020241219003020.png)

Farklı mantık hatası türlerini tartışmaya başlamadan önce, bu modül boyunca izleyeceğimiz senaryoya hızlıca bir göz atalım.

Not: Savunmacı bir güvenli kodlama modülü olarak ana hedefimiz mantık hatalarını tespit etmek ve yamamaktır. Yine de bazı güvenlik açıklarından nasıl yararlanabileceğimizi (saldırabileceğimizi) göstereceğiz, ancak bu bizim birincil hedefimiz değil, bu nedenle mantık hatasının neden var olduğunu anlamak için gerekli olanlar dışında çok fazla saldırı detayına girmeyeceğiz.


## Scenario

Gerçek dünyadaki Mantık Hatalarını tam olarak anlamak ve alıştırmaları ve modül materyalini iyice kavramak için, aşina olduğumuz ve tutarsızlıklarını tanımlamak için kolayca gezinebileceğimiz tamamen gerçek dünya web uygulamasına ihtiyacımız var. Bu modülü alan herkesin aşina olduğundan emin olabileceğimiz bir web uygulaması var: Hack The Box Academy!

![Pasted image 20241219003153.png](/img/user/resimler/Pasted%20image%2020241219003153.png)


Yukarıdaki, hem front-end'i hem de back-end'i (ilgilenenler için MERN stack kullanarak) sıfırdan yeniden inşa ettiğimiz bir Academy replikasıdır. Oldukça büyük bir kod tabanına sahip gerçekçi bir demo oluşturmak için çok çaba sarf ettik, böylece önceki bölümde tanımlanan tüm farklı Mantık Hatası türlerini savunmasız hedef olarak Academy ile gösterebiliriz.

Hepimiz “gerçek” Akademi'nin nasıl çalıştığını biliyoruz, bu nedenle bu bize bir mantık hatasının nasıl görüneceği konusunda çok net bir karşılaştırma sağlayacaktır, çünkü sağlam mantık tasarımı (gerçek akademi) ile zayıf mantık tasarımını (kopya akademi) karşılaştırabiliriz.

![Pasted image 20241219003333.png](/img/user/resimler/Pasted%20image%2020241219003333.png)

![Pasted image 20241219003337.png](/img/user/resimler/Pasted%20image%2020241219003337.png)

Not: Bu Akademi replikasında kullanılan geliştirme frameworkleri gerçek Akademi ile aynı değildir (örneğin, Gerçek Akademi PHP kullanırken bu JS kullanmaktadır). Elbette bunun örneklerin gerçekçiliği üzerinde herhangi bir etkisi olmayacaktır, çünkü biz esas olarak geliştirme framework'ü ile alakasız olan uygulama mantığı ile ilgileniyoruz, çünkü bu sorunlar hangi framework'ü kullandığımızdan bağımsız olarak ortaya çıkabilir.

Güvenli bir kodlama modülü olarak, her alıştırmayla birlikte kaynak kodunu da vereceğiz, böylece çeşitli alıştırmalardan geçerken daha sonra açıklayacağımız metodolojiyi takip edebilirsiniz. Tüm Mantık Hatası örnekleri için aynı hedef web uygulamasını kullanacak olsak da, her biri farklı bir Mantık Hatasını sergilemek için biraz farklı yapılandırılacaktır. Bu nedenle, her yeni mantık hatası türünün kaynak kodunu indirdiğinizden emin olun.

ÖNEMLİ: Modül boyunca çeşitli alıştırmalar ve zorluklar önereceğiz ve bunların her birini yapmanızı şiddetle tavsiye ediyoruz. Hepsini tamamlayamasanız bile, genellikle aynı şeyleri kapsayan bölüm talimatlarını takip etmeden önce bunları çözmeye çalışarak kod inceleme yeteneklerinizi büyük ölçüde geliştireceksiniz, böylece çalışmanızı karşılaştırabilir ve neyi kaçırdığınızı ve çalışmanızı nerede geliştirebileceğinizi görebilirsiniz.

Soru :  Kod tabanını incelemeye ve test etmeye başlamadan önce modülün web uygulamasına aşina olmak için yukarıdaki alıştırmayı kullanmaktan çekinmeyin. Yeni bir kullanıcı kayıt olurken, varsayılan olarak kaç küp alırsınız? Not: Web uygulamasının ölçeği göz önüne alındığında, alıştırmaların başlaması bir dakika kadar sürebilir.



# Setting Up

Modül boyunca VSCode ve bazı eklentilerini kullanacağız, bunlar gelecekteki kod inceleme ve whitebox pentesting alıştırmalarınızda da yardımcı olacaktır. Kullanacağımız ana eklentiler şunlardır:

- [RapidAPI](https://marketplace.visualstudio.com/items?itemName=RapidAPI.vscode-rapidapi-client)
- [Docker for VScode](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)

Modül boyunca test edeceğimiz web uygulaması MERN stack (Mongo, Express, React, Node) kullanmaktadır. Tüm bu araçları ve teknolojileri kendi makinenizde ayarlama ve ardından her alıştırma için yeniden yapılandırma zahmetinden kaçınmak istedik.

Bu nedenle, her alıştırma için web uygulamasının hem front-end hem de back-end kodlarının yanı sıra Mongo veritabanının ve diğer her şeyin kurulumunu içeren ayrı bir Docker görüntüsü oluşturduk. Bu aynı zamanda web uygulamasında kolay hata ayıklama ve testlerimizde herhangi bir şeyin ters gitmesi durumunda kolay yeniden başlatma/sıfırlama imkanı sağlıyor.

Bu nedenle, yukarıdaki araçlara ek olarak, lütfen makinenizde Docker kurulumu ve yüklemesi yaptığınızdan emin olun.

Not: Web uygulamalarını Docker'lamak öğrenilmesi gereken önemli bir beceridir, bu nedenle bu fırsatı nasıl yapıldığını öğrenmek ve gelecekteki whitebox pentesting alıştırmalarınızda kullanmak için kullanabilirsiniz. Daha büyük web uygulamaları için başka bir seçenek de üretim sunucusunun bir test VM kopyasını kurmaktır, ancak bu genellikle çok çaba gerektirir ve başka bir yere kolayca dağıtılamaz.

## Running Locally

Yukarıdaki araçları kurup çalıştırdıktan sonra, bu bölümün sonunda verilen zip arşivini indirebilir, içeriğini çıkarabilir ve ardından VScode kullanarak Dosya>Klasörü Aç seçeneğini kullanarak veya terminal üzerinden ./validation_logic_disparity koduyla klasörü açabilirsiniz.

Bu işlem tamamlandıktan sonra, VSCode içinde Docker dosyasını açabilir, açılan pencereye sağ tıklayabilir ve Build Image'ı seçebilirsiniz. Bu sizden imaj için bir tag girmenizi isteyecektir, böylece klasör adının varsayılan değerini koruyabilir ya da bu modül altındaki tüm alıştırmalar için ortak bir host kullanabilirsiniz (örn. application_logic_flaws:validation_logic_disparity). Bunu yaptıktan sonra docker imajı oluşturulmaya başlayacak ve bu işlem makinenize ve internet hızınıza bağlı olarak 5-15 dakika sürecektir.

![build_docker_image.gif](/img/user/resimler/build_docker_image.gif)


Derleme tamamlandığında, yeni imajı sağdaki VSCode Sidebar'da IMAGES altında Docker simgesinde bulabilirsiniz. Üzerine sağ tıklayıp Run (Çalıştır) seçeneğini seçtiğinizde image başlayacaktır. Her şeyin yüklenmesi için birkaç saniye bekleyin ve ardından tarayıcınızla http://localhost:5000/ adresini ziyaret edin ve Docker dosyasında sağlanan kimlik bilgileriyle oturum açın, çünkü bu kullanıcının kendi kullanıcısı altında eklenen küpler veya ödeme kartları gibi bazı ayrıcalıkları olabilir. Bazı testler ve alıştırmalar kendi kullanıcınızı oluşturmanızı gerektirebilir, bu da başka bir seçenektir.

![[run_docker_container.gif\|run_docker_container.gif]]


İpucu: VSCode içinde bir pencerede görüntülenecek olan back-end sunucu hata mesajları gibi günlüklere göz atmak için Interactively Run'ı da seçebilirsiniz.



## Local Testing

Whitebox pentesting sürecinin bir parçası olarak, önceki bölümde belirtildiği gibi genellikle local test ve debugging yapmamız gerekir. Neyse ki, yeni kurduğumuz Docker image'leri aynı zamanda kodumuzun kolaylıkla debug edilmesini sağlıyor. Tek yapmamız gereken VSCode sidebar'ında Run and Debug sekmesine gitmek ve Docker metninin yanındaki Run simgesine tıklamak: Node'a ekle. Docker görüntüsü zaten debug için yapılandırıldığından, bu hata ayıklama için web uygulamamıza eklenecektir ve VSCode'un alt çubuğu artık debug modunda olduğumuzu belirtmek için kırmızı olmalıdır. Ayrıca, üzerine geldiğiniz session butonlarını kullanarak debug oturumunu duraklatabilir, yeniden başlatabilir ve bu oturumdan çıkabilirsiniz.

![debug_docker_container.gif](/img/user/resimler/debug_docker_container.gif)

İlerleyen bölümlerde, lokal testlerimizde debug işlemini nasıl kullanacağımıza dair daha fazla ayrıntıya değineceğiz. Ancak örnek olarak, breakpoint eklemek istediğimiz dosyayı açarak breakpoint ekleyebiliriz ve herhangi bir satıra gidip satır numarasına tıklayarak bir breakpoint ekleyebiliriz. Şimdi, kod bu satıra ulaştığında, uygulama o noktada kesilmeli ve durmalıdır, böylece her şeyi inceleyebilir ve ardından yürütmeye devam edebiliriz.

Not: VSCode'da açılan kod dosyalarını kullanarak kesme noktaları ayarlayabilsek de, herhangi bir kod değişikliğinin çalışan konteynere yansıtılmayacağını unutmamak önemlidir. Bu modülde yapmamız gereken bir şey olmasa da, çalışan bir konteynerde kodu değiştirmeniz gerekirse, Docker sekmesine gidin, CONTAINERS altında çalışan imajı bulun, ardından genişletmek ve dosyalarını göstermek için üzerine tıklayabilirsiniz. Web uygulama dosyalarını /app altında bulabilir ve VSCode içinde herhangi birini açmak ve değiştirmek için sağ tıklayıp Aç'ı seçebilirsiniz.

Lokal testlerimiz boyunca değiştirmemiz ve debug etmemiz gerekebilecek bir diğer şey de veritabanıdır. Bunu yapmak için VSCode'da Docker sekmesine gidebilir, CONTAINERS altında çalışan imajımızı bulabilir, üzerine sağ tıklayabilir ve Attach Shell'i seçebiliriz; bu VSCode'da yeni bir pencere terminali açmalı ve bizi çalışan konteyner içinde bir shell'e bırakmalıdır. Şimdi, basitçe mongosh komutunu çalıştırabiliriz ve veritabanımıza erişimi olan bir MongoDB shell'ine sahip olmalıyız.

![[use_mongodb_shell.gif\|use_mongodb_shell.gif]]

Not: Bu modül, MongoDB'yi ve temel komutların nasıl çalıştırılacağını zaten bildiğinizi ve MongoDB'nin NodeJS ile temel kullanımını anladığınızı varsayar. Eğer değilseniz, kendinizi alıştırmak için çevrimiçi olarak hızlıca okuyabilir veya MongoDB'yi tanıtan ve nasıl kullanılacağı hakkında kısa bir bilgi veren NoSQL Injection'a Giriş modülüne göz atabilirsiniz.


## Application Structure

İlk konumuza geçmeden önce, test edeceğimiz uygulamanın genel yapısına hızlıca bir göz atmakta fayda var. İşe src/src/app.js dosyasını açıp inceleyerek başlayabiliriz.

Uygulamanın bazı dosyaları ve kütüphaneleri içe aktararak başladığını göreceğiz. Bundan sonra, uygulama diğer yapılandırmalarla birlikte Node/Express'i kuruyor, ayrıca bodyparser ve CORS'u ayarlıyor.

```js
const app = express();
const port = parseInt(process.env.PORT || "5000");
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// set up body parser and cors
app.use(bodyParser.json());
app.use(cors());

// serve public assets
app.use(express.static(path.resolve(__dirname, "public")));
```
Ardından, uygulama app.use() ile main API middleware'i kurar ve her rota için routes dosyasını belirtir. Ardından, 404 ve genel uygulama hatalarını ele alır.

```js
// set up API routes
app.use("/api/auth", authRoutes);
<SNIP>

// forward all other requests to react app, so react router can handle them 'will handle 404 errors'
app.use((req, res, next) => {
  res.sendFile(path.resolve(__dirname, "public", "index.html"));
});

// handle 404 errors
app.use((req, res, next) => {
  res.status(404).json({
    message: "Could not find this route.",
  });
});

// handle next() errors and general errors
app.use((error, req, res, next) => {
   <SNIP>
});
```

Son olarak, MongoDB bağlantısını kurar ve başlangıçta belirtilen portu dinlemeye başlar. Her kod bloğunun tam olarak ne yaptığı hakkında daha iyi bir fikir edinmek için yorumları okuyabiliriz.

```js
// start the Express server & db connection
set("strictQuery", false);
connect(process.env.DB_URL ?? "", {
  dbName: process.env.DB_NAME,
  user: process.env.DB_USER,
  pass: process.env.DB_PASS,
})
  .then(() => {
   <SNIP>
});
```

Dolayısıyla, odaklanmamız gereken ana şey API'ler ve bunların rota middleware'leridir. Bunlardan authRoutes gibi herhangi birine CMD/CTRL ile tıklayabiliriz ve VSCode bunu ilgili dosyasında açmalıdır.

```js
const router = express.Router();

// secure private routes for content (use req.user in private controllers)
router.use(verifyToken);
router.get("/update_token", updateUserToken);
```

Rotalar middleware'ini incelersek, her bir alt rotayı /update_token to updateUserToken gibi belirli bir fonksiyona bağladığını görürüz, ilerleyen bölümlerde yapacağımız gibi daha fazla inceleme yapmak için CMD/CTRL'ye de tıklayabiliriz.

Kodda gezinmek için biraz zaman ayırın ve nasıl çalıştığına kendinizi alıştırın. Genel olarak, en çok ilgileneceğimiz dosyalar /controllers'ın yanı sıra /routes ve /models altındadır.

Bununla birlikte, bu uygulamayı çalıştırabilmeli ve hatalarını ayıklayabilmeli ve genel yapısı hakkında genel bir fikre sahip olmalısınız. Bir sonraki bölümde, ilk konumuzla başlayacağız ve olası sorunları ve mantık hatalarını belirlemek için kodu gözden geçireceğiz.

Soru :  'src/src/controllers/modules-controllers.js' dosyasında '24' satırında bir breakpoint ayarlayın. Ardından, web uygulamasının ana sayfasında, ayrıntılarını görüntülemek için 'Akademiye Giriş' modülüne tıklayın. Bu, uygulamayı breakpoint'inizde kesmelidir. Bu noktada 'module.isNew' değeri nedir?




### Validation Logic Disparity (Doğrulama Mantığı Eşitsizliği)

Parametre Manipülasyonu mantık hataları öncelikle kullanıcı girdisinin uygulamanın buna nasıl tepki vereceğini etkileyecek şekilde doğrudan değiştirilmesinden kaynaklanır. Bu nedenle, modül boyunca kullanıcı girdisine ve uygulama mantığının bunu farklı koşullar altında nasıl ele aldığına odaklanacağız.

Hem front-end hem de back-end üzerinde aynı doğrulamaların uygulanmamasından kaynaklanan ve bir eşitsizliğe yol açan Validation Logic Disparity logic bug'ları ile başlayacağız. Böyle bir eşitsizlik, daha sonra göreceğimiz gibi, eşitsizliğin nerede meydana geldiğine bağlı olarak “ front-end veya back-end'de eksik” çeşitli mantık hatalarına neden olabilir.


## Client-Side Logic vs Server-Side **Logic**

Günümüzde modern web ve mobil uygulamaların çoğu, kullanıcının beklenen girdiyi geçmesini sağlamak ve girdi doğrulama eksikliğinden kaynaklanabilecek çeşitli güvenlik açıklarından kaçınmak için girdi doğrulama filtreleri kullanmaktadır. Kötü niyetli istekleri önlemek için back-end'de ve daha iyi bir kullanıcı deneyimi sağlamak ve back-end'in beklenen formatı karşılamadığı için reddedebileceği isteklerin sayısını azaltmak için front-end/ client-side'da gerekli olduğundan, geliştiricilerin bu filtreleri her iki tarafta da uygulaması gerekir.

Sadece client tarafı doğrulama filtrelerine güvenmenin güvenli olmadığının da farkındayız, çünkü saldırganlar genellikle doğrudan back-end'e saldırabilir ve bu da uygun girdi doğrulaması uygulanmadığı takdirde savunmasız kalabilir. Ancak, hem client tarafı hem de server tarafı girdi doğrulaması uygularsa, bu kodun her zaman tip manipülasyonuna karşı güvende olacağı anlamına gelir mi?

Cevap hayır. Her iki taraf arasında 1'e 1 eşitlik olmadığında sorunlar ortaya çıkabilir. Bu, front-end ve back-end'in aynı doğrulama filtrelerini uygulamadığı veya back-end'in front-end tarafından uygulanan doğrulamalara ve filtrelere güvendiği ve onaylamak için bunları yeniden uygulamadığı anlamına gelir. Her iki tarafta da herhangi bir doğrulama filtresi eksikse, bu bir eşitsizliğe yol açacaktır.

Örneğin, giriş bölümünde bahsettiğim Unreleased iPhones vakası tam olarak bu sorundan muzdaripti. Front-end'de alışveriş sepetine bir ürün eklediğimizde, back-end'e kullanıcının alışveriş sepetine (muhtemelen cihazlar ve kullanıcı oturumları arasında kalıcılık için veritabanında saklanan) belirli bir productId eklemesini talep eden bir istek gönderir. Eminim ki back-end, SQL enjeksiyonları ve diğer enjeksiyon türleri gibi sorunları önlemek için her türlü girdi filtresine sahip olmalıdır.

Ancak front end, veritabanındaki stok miktarına dayanarak "sepete ekle" veya "stokta yok/yakında gelecek" düğmelerini göstermeye güveniyordu. Bu, stokta olmayan ürünlerin sipariş edilmesine karşı tek doğrulamaydı. Backend ise istenen ürünün stok durumunu yeniden doğrulamıyor ve frontend gönderilen tüm taleplerin stokta olduğuna güveniyordu.

Elbette bu, backend'e manuel olarak gönderilen talepleri (örneğin, kötü niyetli aktörler tarafından) hesaba katmıyor. Dolayısıyla, backend stok durumunun yeniden doğrulanmaması, bu mantık hatasına neden oldu. Ayrıca, front end, satın alma talebi gönderilirken sepet öğelerinin stok durumunu yeniden kontrol etmek için bir doğrulama yapmıyordu ki bu, mutlaka uygulanması gereken bir testtir.


### Doğrulama Mantığı Eşitsizlik Hatalarının Türleri

Gördüğümüz gibi, bu sorun client-side mantığının server-side mantığı ile eşit olmaması ve her birinin farklı varsayımlarla kodlanması nedeniyle ortaya çıkmış ve bu boşluğa yol açmıştır.

Dolayısıyla, Logic Disparity hataları web ve mobil uygulamalarda, front-end'in back-end ile aynı filtreleri uygulamadığı ve doğrulama mantığında bu tür hatalara neden olan bir eşitsizliğe yol açtığı zaman ortaya çıkar. Her iki taraf da aynı mantığı kullanarak filtreleri ve doğrulamaları uygulamalıdır ve back-end her zaman front-end'in uyguladığı aynı doğrulamaları ve filtreleri yeniden uygulamalıdır.

Front-end'de back-end'in uyguladığı bazı filtreler eksikse, bu durum uygulamanın kullanıcı deneyiminde hatalara yol açabilir; örneğin bir ürünün aslında stokta olmadığı halde stokta olmadığını söylemek gibi. Öte yandan, back end bazı filtreleri atlıyor ya da front end'de kullanılanları yeniden uygulamıyorsa, bu durum yararlanabileceğimiz bir mantık hatasına yol açabilir ki bizim aradığımız da budur.

![Pasted image 20241219010317.png](/img/user/resimler/Pasted%20image%2020241219010317.png)


## Identifying Logic Disparity Bugs

Her iki tarafın kaynak koduna erişimimiz olsaydı, doğrulama fonksiyonlarını arayabilir ve bunları client-side kod ile server-side kod arasında karşılaştırabilirdik. Herhangi bir tutarsızlık fark edersek, bunları test için listemize ekleyebiliriz. Ancak, yalnızca back-end koduna erişimimiz olduğunu varsayalım; whitebox pentesting ve güvenli kodlama alıştırmalarında genellikle durum böyledir, çünkü uygulamanın hassas fonksiyonelliğini ve kontrolünü içerdiği için genellikle back-end'e daha fazla vurgu yapılır. Çalışan bir web/mobil uygulamamız olduğu sürece front-end koduna erişmemiz gerekmeyecektir.

Mantıksal Eşitsizlik hatalarını aramak için aşağıdaki özelliklere sahip fonksiyonları test etmemiz gerekir:

1. Kullanıcı girdisini kabul et
2. Bu girdiye client-side doğrulaması uygulayın
3. Doğrulama testinin nasıl çalıştığını ayarlamak için back-end'den gelen verilere güvenir

Bu, statik testlerden ziyade dinamik doğrulama testleriyle ilgilendiğimiz anlamına gelir. Statik bir doğrulama testi, tüm girdilere aynı filtreyi uygulamak gibi her zaman aynı şekilde çalışır (örneğin, girdinin e-posta formatıyla eşleştiğinden emin olmaya çalışır). Öte yandan dinamik testler farklı şekilde çalışır, genellikle back-end'den alınan verilere dayanır, ancak bazen tarih veya günün saati gibi başka bilgilere de dayanabilirler. Bu dinamik doğrulama testlerini belirledikten sonra, girdimizi aldıktan sonra back-end'in de aynı filtreleri uyguladığından emin olmak için bunları back-end karşılıklarıyla karşılaştırabilir ve potansiyel olarak bu fonksiyonların bazılarındaki bazı eşitsizlikleri belirleyebiliriz.

Özetle, Mantık Eşitsizliğine karşı savunmasız bir fonksiyon front-end doğrulamasına (back-end tarafından sağlanan verilere dayanarak) dayanacak ve front-end'den gelen girdiyi yeniden doğrulamayacaktır. Başka bir deyişle, doğrulama testlerinin tamamı her iki tarafta da gerçekleştirilmez, çünkü back-end bunlardan bazılarını gerçekleştirirken front-end diğerlerini gerçekleştirir ve böylece iki taraf arasında bir eşitsizlik yaratır.

Tüm bunlar kulağa biraz bunaltıcı veya karmaşık geliyorsa, bir sonraki bölümde alıştırmalarımızı yapmaya başladığımızda çok daha anlamlı hale gelecektir.


Soru : Front-end veri doğrulamasını kullanan fonksiyonları belirlemek için front-end web uygulamasında farklı fonksiyonlarla oynamaya çalışın. Ardından, bu doğrulama filtrelerini dinamik olarak uygulamak için hangilerinin back-end'den gelen verilere dayandığını görmeye çalışın. Back-end'e giden istekleri izlemek için ''Browser Dev Tools'' içindeki ''Network'' sekmesini kullanabilirsiniz. Böyle bir fonksiyonu bulabileceğimiz URL yolu nedir?

Cevap :



# Code Review - Validation Logic Disparity

Önceki bölümde belirtildiği gibi, mantık uyumsuzluğu hatalarını belirlemenin en kolay yolu, uygulamanın her iki tarafındaki doğrulama testlerini karşılaştırmak ve back-end kodunda bir uyumsuzluk bulmaya çalışmaktır. Aksi takdirde, front-end'deki fonksiyonları manuel olarak test edebilir ve hangilerinin dinamik doğrulama testlerine dayandığını görebiliriz. Ardından, eşitsizlikleri belirlemek için back-end kodunu incelemeye başlayabiliriz.

Bunu büyük kod tabanları ve uygulamalar için yapmak, özellikle de çok sayıda form ve alana sahip olanlar için zahmetli gelebilir. Ancak, doğrulama mantığı eşitsizliği hatalarının nasıl göründüğüne dair doğru bir anlayışa sahip olduğunuzda, back-end'deki herhangi bir fonksiyonu incelerken bunları tespit etmeniz muhtemeldir.

Bu özel kullanım durumu için kod analizi ve dinamik uygulama testinin bir karışımı ile başlıyoruz, ancak modül boyunca ilerledikçe, kod tabanının daha büyük bölümlerini incelemek ve bunları belirli kriterler için filtrelemek için daha gelişmiş teknikler kullanacağız.

Not: Bir önceki bölümün sonundaki alıştırmayı tamamladınız mı? Eğer öyleyse, not ettiğiniz / kısa listeye aldığınız fonksiyonlardan birinin bölümde tartışacağımız şey olup olmadığına bakın. Eğer bulduysanız, harika bir başlangıç yaptınız demektir. Harika bir iş çıkardınız!


### Dinamik Doğrulama Testleri

Front-end web uygulamasını incelemeye başlarsak, açıkça client-side veri doğrulaması uygulayan birkaç form ve alanı kolayca tespit edebiliriz. Bu, anlık geri bildirimle ve doğrulama uygulanırken hiçbir istek gönderilmemesi gerçeğiyle kolayca doğrulanabilir, bu da bunun aslında client tarafında gerçekleştiğini gösterir. Örneğin, karşılaştığımız ilk form oturum açma formudur ve tarayıcı developer araçlarından Network sekmesini açabilir ve gerçekten de bu doğrulamayı işlemek için hiçbir istek gönderilmediğini görebiliriz:

![client_side_validation_test.gif](/img/user/resimler/client_side_validation_test.gif)

Önceki bölümde de belirtildiği gibi, özellikle back-end'den alınan verilere dayalı dinamik front-end doğrulama filtreleri arıyoruz. Oturum açma formu tarafından uygulanan filtreler back-end'den gelen herhangi bir veriye dayanmıyor gibi görünmektedir, bu nedenle her zaman belirli bir kalıbı (örneğin e-posta formatı) eşleştirmeye çalışan statik filtreler olarak düşünülebilirler. Ayrıca, sayfayı ziyaret ederken tarayıcımız tarafından gönderilen isteklerin hiçbiri, onun tarafından kullanılabilecek verilere sahip görünmemektedir.

Web uygulamasında bulabileceğimiz diğer formlarla devam edebilir, bir yandan da gönderilen istekler için network sekmesine göz atabiliriz:

![forms_network_monitoring.gif](/img/user/resimler/forms_network_monitoring.gif)

Not: Tüm formların back-end'den benzer şekilde veri çekmediğini unutmayın. Bazıları form tıklandığında verileri çekerken, diğerleri sayfa ziyaret edildiğinde verileri çekebilir vb.



### Exam Booking

Web uygulaması içindeki diğer formlar ve alanlarla devam edersek, exam booking fonksiyonunun önceki bölümde belirttiğimiz kriterlerin 3'ünü de karşıladığını fark edeceğiz. Öyleyse, nasıl çalıştığını ve bu açığa karşı savunmasız olup olmadığını daha iyi anlamak için front-end'e bir göz atalım.

Eğer /exams sayfasına gidersek, satın almak için listelenmiş mevcut sınavları görürüz. “Verilen kimlik bilgilerine sahip kullanıcı için olduğu gibi” bunlardan birini zaten satın almış olsaydık, bir sonraki adım sınav yerimizi ayırtmak olurdu. Bu, birçok sertifika kuruluşu için yaygın bir uygulamadır ve aynı zamanda birçok çevrimiçi randevu ve rezervasyon için de kullanılır.

![Pasted image 20241219021646.png](/img/user/resimler/Pasted%20image%2020241219021646.png)

Rezervasyon Yap seçeneğine tıkladığımızda, rezervasyon yapabileceğimiz mevcut oturumlar için bir takvim görünümü sunulur. Uygun bir slot seçip Onayla'ya tıkladığımızda, sınav rezerve edilir ve sınav tarihimizi içeren bir onay mesajı alırız.

![Pasted image 20241219023452.png](/img/user/resimler/Pasted%20image%2020241219023452.png)

Bunu görebiliyoruz:

1. Kullanıcı girdisini kabul eder: takvimde seçtiğimiz tarih şeklinde
2. Client taraflı doğrulamalar uygular: belirli kullanılamayan tarihleri devre dışı bırakarak
3. Doğrulamayı ayarlamak için back-end verilerine dayanır: bunu istekleri ve filtrenin nasıl değiştiğini izleyerek doğrulayabiliriz

Şahsen, ne zaman benzer bir vaka görsem hemen kendime soruyorum:

1. Uygunluk filtreleri nasıl uygulanıyor?
2. Back-end rezervasyon sırasında müsaitlik durumunu yeniden doğruluyor mu?

Bunu nasıl onaylayacağımızı daha iyi anlamak için bir kez daha tarayıcı developer aracımızı açabilir ve Network sekmesine gidebiliriz. Bunu yaptıktan sonra, network öğelerini temizlemek için sağ üst köşedeki çöp simgesine tıklayabiliriz. Şimdi, book butonuna tekrar tıklarsak, uygulamanın hangi slotların kullanılamadığına dair detayları almak için bir istek gönderdiğini görürüz:

![[unavailable_slots_req.gif\|unavailable_slots_req.gif]]

Bunu biraz daha inceleyelim. Sağ üstteki açılır menüden “ Response yerine, yukarıda gösterildiği gibi” Request'i seçersek, aşağıdaki verileri içeren bir istek gönderdiğini görürüz:

```json
{
  "id": 1,
  "startDate": "2023-09-01T15:47:14.843Z",
  "endDate": "2023-10-01T15:47:14.843Z"
}
```

Tam API endpoint URL'sini bulmak için headers sekmesine tıklayabilir ve Request altında /api/exams/availability endpoint'ine bir POST isteği gönderdiğini görebiliriz:

![Pasted image 20241219031532.png](/img/user/resimler/Pasted%20image%2020241219031532.png)

Son olarak, hangi isteğin gönderildiğini görmek için uygun herhangi bir slotu seçelim ve confirm (onayla) butonuna tıklayalım. Gördüğümüz gibi, bu kez /api/exams/book adresine, sınav kimliği ve seçilen tarih ile aşağıdaki gibi başka bir POST isteği gönderildi:

```json
{
  "id": 1,
  "date": "2023-09-14T23:00:00.000Z"
}
```

![book_exam_request.gif](/img/user/resimler/book_exam_request.gif)

Endpoint ile kısa etkileşimimizden, /availability'ye yapılan ilk isteğin filtrenin nasıl uygulandığını değiştirmek için kullanıldığını, /book'a yapılan ikinci isteğin ise sınav rezervasyonu için kullanılan normal istek olduğunu görebiliriz. Doğrulama mantığı eşitsizliğini test etmek için, bu endpointlerden sorumlu fonksiyonları bulmamız ve kodlarını incelememiz ve filtrelerini front-end'de gözlemlediğimizle karşılaştırmamız gerekir.

Not: Seçtiğiniz tarih ile talepteki tarih arasında küçük farklar görebilirsiniz. Bu tamamen normaldir, çünkü istek her iki taraftan da aynı olmasını sağlamak için mutlak bir zaman dilimi kullanır.

## Locating Endpoints

Bu endpoint fonksiyonlarını bulmak için app.js dosyasını açabilir ve examRoutes altında olduğunu görebiliriz:

```js
// set up API routes
<SNIP>
app.use("/api/exams", examRoutes);
```

CMD/CTRL+tıklayabiliriz ve daha önce gördüğümüz gibi VSCode'da yeni bir sekmede açılacaktır:

```js
router.get("/", getAllExams);
router.get("/:id", getExamById);
router.post("/availability", getExamAvailability);

// secure private routes for content (use req.user in private controllers)
router.use(verifyToken);
router.get("/user/exams", getUserExams);
router.post("/book", bookExam);
router.get("/content/:id", getExamContent);
```

/availability endpoint'inin verifyToken'dan önce, /book endpoint'inin ise sonra geldiğini görüyoruz. Bunun endpointleri ve genel olarak uygulamayı nasıl etkilediğini anlamak önemlidir. Kodunu incelersek, kimlik doğrulama token'ından kullanıcı ayrıntılarını çözmek ve doğrulamaktan sorumlu olduğunu göreceğiz. Dolayısıyla, kendisinden sonra gelen tüm endpoint'ler kimliği doğrulanmış bir token gerektirecektir.

Alıştırma yapın: Kimlik doğrulama token'ının kodunu nasıl çözdüğünü ve kullanıcı ayrıntılarını talebe nasıl eklediğini görmek için verifyToken fonksiyonunu okumaya çalışın ve talebe hangi kullanıcı ayrıntılarının eklendiğini not edin. Kullanıcı kimliğimizi manipüle etmemizin mümkün olabileceğini düşünüyor musunuz?

Dolayısıyla, /availability endpoint herkese açıkken, /book endpoint kimlik doğrulaması gerektirir ve geçerli bir token gerektirir. Bu /book endpoint için beklenen bir durumdur, çünkü yukarıdaki istek bizim için sınav rezervasyonu yapacak kullanıcımız hakkında herhangi bir detay vermemiştir, bu yüzden bu detayları bizim tokenımızdan alıyor olmalıdır.

Bir sonraki bölümde, bu fonksiyonların üzerinden geçeceğiz ve nasıl çalıştıklarını anladığımızı doğrulamak için testler yapacağız.

Soru : Yukarıdaki fonksiyonların her ikisini de bulmaya çalışın ve ardından ana işlevlerini anlamaya çalışın ve front-end'de gerçekleştirilen herhangi bir doğrulamanın eksik olup olmadığını görün “böylece bir mantık eşitsizliğine yol açar”. Hangisinin savunmasız olma olasılığı daha yüksektir? Cevabınız olarak fonksiyon adını kullanın

Cevap :


### Local Testing - Validation Logic Disparity (Doğrulama Mantığı Eşitsizliği)

Potansiyel olarak ilginç bir fonksiyon belirlediğimize göre, bu bölümde etkileşimde bulunduğu back-end API'lerini inceleyeceğiz ve front-end doğrulama mantığı ile back-end olanlar arasında herhangi bir uyumsuzluk olup olmadığını görmeye çalışacağız.

Not: Devam etmeden önce, orijinal durumuna sıfırlamak için Docker konteynerinizi yeniden başlatabilirsiniz.


## getExamAvailability()

getExamAvailability() fonksiyonu ile başlayalım. İlk olarak, request body'den {id, startDate, endDate} ayarladığını ve tarih formatını doğrulamak için birkaç kontrol gerçekleştirdiğini görüyoruz. Daha sonra gönderilen id'yi kullanarak Exam.findOne ile veritabanındaki exam'ı bir id ve exam doğrulama formu olarak bulur:

```js
// validate date format
if (
  !startDate ||
  !endDate ||
  isNaN(Date.parse(startDate)) ||
  isNaN(Date.parse(endDate))
) {
  return next({
    message: "Please provide a valid date range.",
    statusCode: 400,
  });
}

let exam;
try {
  // ensure exam exists
  exam = await Exam.findOne({
    id,
  });
  <SNIP>
}
```

Bundan sonra fonksiyon, verilen tarih aralığındaki mevcut sınav yuvalarını bulmak için aşağıdaki kodu kullanır:

```js
const bookedExams = UserExam.find({
  examId: exam.id,
  date: {
    $gte: new Date(startDate).setUTCHours(0, 0, 0, 0),
    $lte: new Date(endDate).setUTCHours(23, 59, 59, 999),
  },
  used: false,
});
```

Not: Kod mongodb veritabanı ile etkileşime girdiğinde, bu durumda Exam ve UserExam gibi önceden tanımlanmış modülleri kullanır. Bunun nasıl çalıştığını anlamak için kodlarını okumaya çalışın. Bu, kod incelememizi etkilememelidir, ancak geliştiricilerin veritabanıyla etkileşime girmesini ve bizim kodu anlamamızı kolaylaştırır.

Son olarak, kod basitçe rezerve edilen tarihlerin bir JSON listesini döndürür ve herhangi bir sonuç bulamazsa veya herhangi bir sorunla karşılaşırsa boş bir array (dizi) döndürür:

```js
res.json({
  unavailableSlots: (await bookedExams).map((exam) => exam.date),
});
```

RapidAPI üzerinden temel bir request göndererek bunu doğrulayabiliriz. RapidAPI extension sekmesine gidersek, + tuşuna basın ve ardından yöntemi POST ve URL'yi http://localhost:5000/api/exams/availability olarak ayarlayın. Son olarak, veri türünü JSON olarak ayarlayabilir ve aşağıdaki request body'yi “from the front-end request” kullanabiliriz:

```json
{
  "id": 1,
  "startDate": "2023-09-01T15:47:14.843Z",
  "endDate": "2023-10-01T15:47:14.843Z"
}
```

Şimdi, isteği gönderirsek, bu tarih aralığında kullanılamayan yuvaların bir listesini alırız:

![[rapidapi_availability_req.gif\|rapidapi_availability_req.gif]]

Fonksiyon basitçe mevcut olmayan tarihlerin bir listesini döndürdüğü için tüm bunlar oldukça normal görünüyor. Bir endpoint'in mevcut tarihler yerine mevcut olmayan tarihlerin bir listesini gönderdiği bu yaklaşım oldukça yaygındır. Her iki durumda da, bu “henüz” herhangi bir mantık hatasını etkilemez veya buna neden olmaz.


## bookExam()

bookExam() fonksiyonunu kontrol ettiğimizde, request body'den {id, date} ayarlarını yaptığını ve ardından req.user?.id'den kullanıcı kimliğini ayarladığını görüyoruz. Ayrıca getExamAvailability() fonksiyonunda olduğu gibi tarih formatını doğruladığını ve ardından sınavın varlığını onaylamak için sınav ayrıntılarını aldığını görüyoruz. Son olarak, kullanıcının satın aldığı sınav biletini rezerve edilen sınav tarihi ile günceller:

```js
const updateReq = await UserExam.findOneAndUpdate(
  {
    examId: exam.id,
    userId,
    used: false,
    date: {
      // date must be null 'unbooked' -> can't change date once booked
      $eq: null,
    },
  },
  {
    date: new Date(date),
  }
);
```

Sınavı, var olduğu zaten doğrulanmış olan id'sine göre aldığını ve kullanıcının zaten bir sınav bileti satın aldığından ve kullanmadığından emin olmak için userId'yi kullandığını görüyoruz (used: false). Ayrıca, boş bir tarihe sahip bir bilet arayarak (date: { $eq: null }) kullanıcının zaten sınav rezervasyonu yapmadığından emin olur. Son olarak, bu bileti istenen sınav tarihi ile günceller (date: new Date(date)).

Fonksiyonu doğru anladığımızı teyit edelim. userId değerini değiştirmek istiyoruz, ancak private bir anahtarla imzalanan JWT token'ından alındığı için, “gerçek hedefteki anahtar lokal olandan farklıdır” şeklinde basitçe değiştiremeyiz. Bunun yerine, userId'nin ayarlandığı satırdan hemen sonra bir breakpoint ayarlayacağız ve ardından endpoint'e bir istek göndereceğiz. Breakpoint'e ulaşıldığında, userId'yi biraz değiştirerek başka bir şey yapabiliriz ve bize bu sınavı satın almadığımızı söylemesi gerekir.

İlk olarak, VSCode'da satır numarasına tıklayarak (veya SHIFT+F9 kısayolunu kullanarak) break point ekleyeceğiz. Ayrıca userId değişkenine sağ tıklayabilir ve değerine göz atmak için Add to Watch'u seçebiliriz:


![book_exam_breakpoint.gif](/img/user/resimler/book_exam_breakpoint.gif)

Son olarak, önceki bölümde gördüğümüz id/date body verilerinin aynısıyla /api/exams/book adresine bir POST isteği gönderebiliriz. Bu endpoint kimlik doğrulaması gerektirdiğinden, token'ımızı da isteğe eklememiz gerekecek, bunu da Local Storage altındaki Browser Dev Tools'daki storage sekmesinden kopyalayabiliriz, ardından token'a tıklayıp Copy Row'u seçebiliriz. Ardından, RapidAPI isteğinde, Auth sekmesine Bearer seçeneği ile ekliyoruz “değeri yapıştırdığınızda token kelimesini sildiğinizden emin olun”. İstek düzgün bir şekilde ayarlandıktan sonra Gönder'e tıklayabiliriz ve ayarladığımız breakpointde otomatik olarak ulaşmamız gerekir:

![book_exam_breakpoint_hit.gif](/img/user/resimler/book_exam_breakpoint_hit.gif)
Watch'a eklediğimiz userId değeri de dahil olmak üzere sol bölmelerdeki istek değerlerini inceleyebiliriz:

![book_exam_breakpoint_details.webp](/img/user/resimler/book_exam_breakpoint_details.webp)

Şimdi, WATCH grubu altındaki userId'ye sağ tıklayabilir, Set Value'yu seçebilir ve bunu başka bir şeyle değiştirebiliriz, yani rezerve edilmiş bir sınavı olmayan başka bir ID olabilir. Ayarladıktan sonra, isteğin yürütülmesine devam etmek için F5'e tıklayabiliriz ve az önce gönderdiğimiz isteğin yanıtında “ User has not purchased this exam” (Kullanıcı bu sınavı satın almadı) hatasını alacağız:

![book_exam_req_error (1).gif](/img/user/resimler/book_exam_req_error%20(1).gif)


Bu işlemle, fonksiyonun kimliği doğrulanmamış kullanıcıları doğru bir şekilde engellediğini, tarih formatını doğru bir şekilde doğruladığını, sınav kimliğini doğru bir şekilde doğruladığını, kullanıcıların yalnızca sınavı satın aldıktan sonra rezervasyon yapabilmelerini sağladığını ve bir tarih belirlendikten sonra tekrar rezervasyon yapmalarını engellediğini doğrulayabildik. Güvenli görünüyor, değil mi? Pek sayılmaz.

Fonksiyon tarih formatını doğrularken, sınav tarihinin uygunluğu konusunda, halihazırda rezerve edilip edilmediğini veya gelecekte olup olmadığını kontrol etmek gibi hiçbir doğrulama gerçekleştirmez. Bir kullanıcı yalnızca “aşırı rezervasyona yol açabilecek” uygun olmayan bir tarihte sınav rezervasyonu yapmakla kalmaz, aynı zamanda “potansiyel olarak başka mantık sorunlarına yol açabilecek” geçmişte bir tarihte de rezervasyon yapabilir.

Front-end uygulaması, geçmişteki tüm tarihleri devre dışı bıraktığı ve /exam/availability'deki unavailableDates[] dizisinde bulunan tüm tarihleri devre dışı bıraktığı için bunların hepsini yapar. Ancak, iki uç arasındaki bu uyumsuzluk, bu bölümde tartıştığımız kusura yol açmaktadır.

Bu oldukça temel bir kusur olsa da (yani front-end doğrulamaya güvenmek), gerçekte bu, giriş bölümünde bahsettiğimiz gibi, en büyük çevrimiçi satıcıların bazılarında bile bulunan yaygın bir mantık hatasıdır.

Bu kusur, front-end ve back-end geliştiricileri arasındaki iletişimde bir eksiklik olması, kodun karmaşıklığı ve bunun başka bir yerde doğrulanmış olabileceğinin düşünülmesi gibi birçok nedenden kaynaklanabilir. Bu nedenle kod tabanlarını incelerken veya mobil/web uygulama sızma testleri gerçekleştirirken bunu aklımızda tutmalı ve her fonksiyonun her iki tarafında da sağlam bir doğrulama mantığına sahip olduğundan ve tam bir eşitlik içinde olduğundan her zaman emin olmalıyız.


Soru :  Şu ana kadar elde ettiğimiz bulguları kullanarak, tüm sınav slotları rezerve edilmiş olan hedefe saldırmaya çalışın. Gelecekteki bir CPTS sınavı için yer ayırtabilirseniz, bayrağı almak için içeriğini görüntüleyebileceksiniz.

CEvap :


# PoC and Patching - Validation Logic Disparity

Şimdi, devam edip teorimizi test edebilir ve uygun bir sınav yeri olmasa bile bir sınav yeri ayırtabileceğimizi doğrulayabiliriz.


## Proof of Concept

İlk olarak, sınav rezervasyonunun orijinal durumunu geri yüklemek ve koda eklemiş olabileceğimiz breadk pointleri kaldırmak için Docker konteynerimizi yeniden başlatacağız. Bu demo için, veritabanında kalan sınav yuvalarını gerçek hedefte sahip olacaklarımızı yansıtacak şekilde doldurduk (boş yuva yok).

Bundan sonra tek yapmamız gereken, front-end uygulamasını incelerken gördüğümüz gibi bir sınav rezervasyon isteği göndermek ve sadece tarih değerini aşağıdaki gibi mevcut olmayan herhangi bir tarih olarak değiştirmektir:

```json
{
  "id": 1,
  "date": "2023-09-14T23:00:00.000Z"
}
```

Bunu yaptığımızda, gerçekten de bir rezervasyon onayı alıyoruz:

![Pasted image 20241219053651.png](/img/user/resimler/Pasted%20image%2020241219053651.png)

Son olarak, /exams sayfasını yenileyebiliriz ve sınavımızın artık REZERVASYON YAPILDI yazdığını göreceğiz ve sınavı görüntüleyebileceğiz:

![book_exam_poc.gif](/img/user/resimler/book_exam_poc.gif)

Gördüğümüz gibi, bu mantık eşitsizliği kusuru, tüm sınav yuvaları tamamen dolu olmasına rağmen bir sınav rezervasyonu yapmamıza izin verdi. Aynı kusur, piyasaya sürülmemiş veya stokta olmayan bir ürünü satın almamıza izin vermek gibi diğer senaryolar için de geçerlidir.

Bu durumda, eksik doğrulama testi back-end'deydi ve bu tür kusurlar veritabanındaki verileri değiştirmemize izin verdiği için her zaman daha ciddidir. Ancak, Mantıksal Eşitsizlik sorunları daha önce de belirtildiği gibi front-end'deki eksik doğrulamalardan da kaynaklanabilir. Örneğin, bir ürün stokta ve satın alınabilir durumda olabilir ve back-end ürünleri doğru şekilde doğruluyor olabilir. Ancak, front-end doğrulama ile ilgili bir sorun, ürünü stokta yok olarak gösterebilir, müşterilerin ürünü satın alamamasına ve gelir kaybına yol açabilir, bu da başka bir yaygın mantık hatasıdır.

Tüm bunlar bize Doğrulama Mantığı Eşitsizliği sorunlarının nasıl ortaya çıkabileceği ve bunların nasıl tespit edilip kullanılacağı konusunda çok net bir fikir vermelidir. Daha sonra, bu tür kusurlardan nasıl kaçınılacağına ilişkin ipuçlarını göreceğiz.

Not: Bu bir Zor modül olduğundan, alıştırmalar bölümlerde gösterilen demo ile aynı olmayacaktır ve bu özel güvenlik açığı gerçek hedefte yamalanmıştır. Bunun yerine, içeriği anladığınızı benzer bir Mantık Hatası ile ancak farklı bir bağlamda test edeceğiz. Bölümde gösterilenleri test etmek için yine aynı kaynak kodunu kullanabilir ve alıştırmada tartışıldığı gibi başka bir mantık hatasını test edebilir ve tanımlayabilirsiniz.


## Patching

Güvenlik açığının var olduğunu ve istismar edilebileceğini kanıtladık, şimdi kodu yamalayarak bunu nasıl düzelteceğimizi görelim. Bu güvenlik açığına yol açan ana şey, uygulama front-end'de yapılan teste dayandığı için back-end'de eksik bir sınav uygunluk testidir.

Dolayısıyla, sınav rezervasyonuna devam etmeden önce bunu eklememiz gerekiyor. Bunu yapmak için aşağıdaki kodu /controllers/exam-controllers.js dosyasının 191. satırına ekleyebiliriz:

```js
// ensure exam slot is available
const bookedExams = UserExam.find({
  examId: exam.id,
  date: new Date(date),
  used: false,
});

if ((await bookedExams).length > 0) {
  return next({
    message: "Exam slot is not available.",
    statusCode: 400,
  });
}
```

Yalnızca fronte end doğrulaması uygulayan diğer alanları/formları belirlemek için web uygulamasını keşfedin ve 'Doğrulama Mantığı Eşitsizliği'nden muzdarip bir tane bulmaya çalışın. Ardından, SINIRSIZ küp elde etmek için kötüye kullandıktan sonra, “Akademiye Giriş” modülünün kilidini açın ve ilk bölümdeki bayrağı gönderin.



# Unexpected Input

Bir fonksiyonun mantığı genellikle belirli bir input tipi etrafında geliştirilir, bu nedenle input tipini doğrulamak ve işlemeden önce beklenen formatla eşleştiğini onaylamak her zaman önemlidir. Bir uygulama bunu tutarlı bir şekilde yapmazsa, beklenmedik bir kullanıcı girdisi alabilir ve potansiyel olarak istenmeyen mantık hatalarına yol açabilir.

Bu tür mantık hatalarında, sorunlar genellikle bir input değişkeninin güçlü bir şekilde typed olmadığı ve inputa bağlı olarak birden fazla değişken tipini kabul edebildiği değişkenlerin gevşek typing'i nedeniyle ortaya çıkar. Öyleyse, güçlü types ile gevşek types arasındaki farkları inceleyerek başlayalım.


## Strongly-typed vs Loosely-typed Languages

C#, Java ve TypeScript gibi güçlü tipli diller, değişkenlerin bildirim sırasında belirli bir veri tipine sahip olmasını gerektirir ve herhangi bir fonksiyonun parametre tipleriyle eşleşmesi gerektiğini ileri sürer. Birazdan tartışacağımız gibi, bu dillerden bazıları çalışma zamanı “dinamik typing” sırasında değişkenin veri tipinin değiştirilmesine izin verebilir, ancak yukarıdaki kural mevcut tip ne olursa olsun yine de geçerlidir (yani mevcut tip fonksiyonun input tipiyle eşleşmelidir).

Öte yandan, JavaScript ve PHP gibi esnek tipli/zayıf tipli diller, değişkenlerin belirli bir veri tipi olmadan bildirilmesine izin verir. Bu, değişkenlerin birden fazla olası türde değer almasına olanak tanır ve hatta herhangi bir değişken için herhangi bir veri türü belirtmeye gerek kalmadan tüm komut dosyalarını çalıştırabiliriz. Bu nedenle esnek tipli diller, hem değerin hem de tipin eşleşmesini sağlamak için katı eşitliği (yani `===`) destekler. Tip her zaman eşleştiğinden, güçlü tipli dillerde buna gerek yoktur.

Örneğin, JavaScript “node” sunucumuzda, kullanıcı girdisini tutacak parametre için var veya let kullanılırsa, değişken, alınan kullanıcı girdisine bağlı olarak bir string, bir tamsayı, bir double ve bir dizi başka biçime dönüşebilir. PHP gibi diğer bazı diller, stringler ve sayılar arasında aritmetik hesaplamalar bile yapabilir (örneğin “10” + 10 = 20), bu da serbest yazmayı açıkça gösterir.

Bunun ciddi güvenlik açıklarına yol açabileceğini Whitebox Attacks modülünde zaten görmüştük. Örneğin, karşılaştırmalar için katı eşitlik (`===`) yerine serbest eşitlik (yani `==`) kullanılırsa Type Juggling kimlik doğrulama atlamalarına yol açabilir.

![Pasted image 20241219064607.png](/img/user/resimler/Pasted%20image%2020241219064607.png)


Daha sonra statik ve dinamik typing'e sahibiz. Statik typing basitçe, bir değişkene bir tür atadığınızda, bu türün çalışma zamanı sırasında değiştirilemeyeceği ve yalnızca o türden değerlerin o değişkene atanabileceği anlamına gelir.

Dinamik typing'de ise değişkenler çalışma zamanı sırasında kullanımlarına bağlı olarak veri türlerini değiştirebilirler. Bu, uygulamanın değişkenleri herhangi bir formatta kabul etmesine olanak tanıyarak (örneğin “count” değişkenini “10” ya da 10 olarak kabul etmek) olası type check hatalarını azaltırken, önemli güvenlik açıklarına ve mantık hatalarına da yol açabilir.

Bu modülde, serbest ve dinamik typing'in nasıl ciddi mantık hatalarına yol açabileceğini göreceğiz. Modülün ilerleyen bölümlerinde, dinamik typing'i destekleyen dillerde (hem güçlü hem de esnek typed) bulunan null değişkenlerin neden olduğu hataları da inceleyeceğiz.


### Beklenmedik Input Hata Türleri

Çok sayıda beklenmedik input mantık hatası vardır, ancak en yaygın örneklerden biri, yalnızca pozitif değerleri kabul etmek üzere tasarlanmış fonksiyonlarda (örneğin alışveriş sepetleri) negatif değerlerin kullanılmasıdır. Bu, kullanıcının herhangi bir ödeme yapmasına gerek kalmayacağı anlamına gelebilir ve hatta bazı durumlarda sipariş verdikten sonra kullanıcının hesap bakiyesine para bile yükleyebilir!

Örneğin, bir alışveriş sepeti negatif miktarda ürün eklenmesine izin veriyorsa, toplam fiyatı artırmak yerine düşürecek ve potansiyel olarak sıfır veya negatif bir ücrete yol açacaktır. Daha da basit bir örnek, bir uygulamanın bahşiş için herhangi bir değeri kabul etmesidir, bu nedenle negatif bir bahşiş eklemek, aşağıdaki “bir Reddit kullanıcısı tarafından yayınlanan” gerçek bir örnekte gösterildiği gibi, toplam fiyatı potansiyel olarak sıfıra (veya daha azına!) Kadar düşürebilir.

![Pasted image 20241219064911.png](/img/user/resimler/Pasted%20image%2020241219064911.png)

Negatif değerler mantık hatalarının bir başka örneği de eski bankacılık uygulamalarında görülebilir; burada başka bir müşteriye negatif miktarda para aktarmak, onun hesabından para almanıza “temelde hırsızlık yapmanıza” neden olur. Örneğin, X kullanıcısı Y kullanıcısına -10$ aktardığında, Y'nin hesabından 10$ çekilir ve X'e yatırılır. Tüm bunlar, aktarım tutarının pozitif olduğunun doğrulanmamasından kaynaklanır.

Çok yaygın olmasına rağmen, negatif değerler kullanıcı girdi türlerini manipüle etmenin tek olası yolu değildir. Diğer örnekler arasında beklenenden daha uzun stringler göndermek, amaçlanan string formatlarını manipüle etmek, bir inputun dönüştürülme veya işlenme şeklini manipüle etmek vb. sayılabilir. Temel olarak, input tipi manipülasyonunun neden olduğu herhangi bir mantık hatası beklenmeyen input hatası olarak sınıflandırılabilir.


### Beklenmedik Input Hatalarını Belirleme

İkinci adım, testlerimizi serbest değişkenler (örn. var veya let) kullanan fonksiyonlarla ve/veya kullanıcı girdisi üzerinde herhangi bir tür kontrolü yapıyorlarsa (örn. `===` yerine `==`) serbest karşılaştırmalarla sınırlamak olacaktır. Bu tür fonksiyonlar, özellikle herhangi bir input doğrulaması yapmıyorlarsa, amaçlanandan farklı input tiplerini kabul edebilirler.

Not: Son alıştırmanın kaynaklarından biraz değiştirilmiş olabilecekleri için bu bölümün kaynak dosyalarını yeniden indirmeyi unutmayın. Ancak uygulamanın kendisi aynıdır.

Dolayısıyla, bir sonraki bölümde bunu yapacağız ve daha sonra belirlediğimiz ilginç fonksiyonları incelemeye başlayacağız.


Soru : VSCode kullanarak '/controllers' dizininde doğrudan kullanıcı girişi kabul eden fonksiyonları arayın. Toplam kaç fonksiyon buldunuz?
Cevap : 


### Lokal Test (Doğrulama) - Beklenmeyen Input

Listeye alınan iki fonksiyonla birlikte, payment-controllers.js dosyasındaki processPayment() ile başlayarak bunları tek tek test etmeye başlayabiliriz. Aradığımız ana şey, type safety'deki zayıflık ve doğrulama filtresini geçen beklenmedik bir type kullanabileceğimiz potansiyel durumlardır.

## processPayment()

İlk bakışta, bu fonksiyonun ortalamadan daha uzun olduğunu görebiliriz, bu da fonksiyon içinde daha büyük bir saldırı yüzeyine sahip olabileceğimiz anlamına gelir. Önceki bölümde belirtildiği gibi, fonksiyonun kontrol edebileceğimiz iki doğrudan kullanıcı girdisi vardır; cardId ve items.

PaymentCard.findOne ile kullanıcının ödeme kartını almak için cardId'nin kullanıldığını görüyoruz. Bununla birlikte, bu aynı zamanda auth token'dan gelen userId ile birleştirilmiştir, bu nedenle kartlarının kimliğini bilsek bile, bir şekilde başka bir kullanıcının ödeme kartını kullanmak için onu kandırmamız pek olası değildir. Bir kullanıcının kartı yoksa veya yanlış bir kart kimliği girerse, front-end sepetinde de görebileceğimiz gibi bir hata alırız.

```js
try {
  card = await PaymentCard.findOne({
    userId,
    _id: cardId,
  });

  if (!card) {
    throw new Error();
  }
} catch (err) {
  return next({
    message: "Could not find a card with this id for this user.",
    statusCode: 404,
  });
}
```

Alıştırma yapın: charge endpoint'e cardId olarak herhangi bir string ile bir istek göndererek yukarıdaki testin geçerliliğini doğrulamaya çalışın. Items değeri olarak empty array kullanabilirsiniz.

Böylece geriye item'lar kalıyor. Fonksiyonun, gönderdiğimiz items'in her bir öğesi üzerinde döndüğünü görüyoruz. Ancak, fonksiyonun items parametresinin aslında bir array olduğunu doğruladığını hiçbir yerde göremiyoruz. Peki, bir array yerine bir sayı gönderirsek ne olur?

```js
// validate items + get prices
try {
  for (const item of items) {
    const { name, category, price, amount } = item;
    <SNIP>
  }
}
```


### cardId elde etme

Daha önce gösterildiği gibi, /charge API endpoint geçerli bir cardId göndermemizi gerektirir; aksi takdirde, fonksiyon test ettiğimiz kısma ulaşmadan önce çalışmayı durduracaktır. Sağlanan kullanıcı kimlik bilgileriyle oturum açarsak, önceden yüklenmiş kullanıcının adına eklenmiş bir ödeme kartı vardır, bu nedenle kimliğini almaya çalışacağız. Bu başka bir production uygulaması olsaydı, muhtemelen sadece bir ödeme kartı ekler ve kimliğini alırdık, ancak burada, bir kart ekleme işlemi önemsizdir, bu yüzden DB'ye önceden ekledik.

CardId'yi almak için iki seçeneğimiz var: Front-end'deki istekleri izlemek ya da back-end'deki kodu incelemek. Biz “daha eğlenceli” yolu seçeceğiz ve back-end kodunu inceleyeceğiz. Bunu yapmak için, payment-routes.js'de gördüğümüz diğer API endpoint'i olan getUserCards()'ı kullanabiliriz:

```js
router.use(verifyToken);
router.get("/cards", getUserCards);
router.post("/charge", processPayment);
```

CMD/CTRL ile üzerine tıklarsak, fonksiyonu okuyabiliriz ve herhangi bir girdi almadığını ve temel olarak ödeme kartlarımızı almak için auth token'ımızdaki kullanıcı kimliğimizi kullandığını ve sonra bunları bize geri verdiğini görürüz:

```js
const userId = req.user?.id;
let userCards = null;

try {
  userCards = await PaymentCard.find({
    userId,
  });
  <SNIP>
}
```

Bu yüzden sadece /api/payment/cards adresine auth token'ımızla birlikte bir GET isteği göndermemiz ve cardId'yi almamız gerekiyor. İsteği gönderdikten sonra, her kartın kimliğini içeren kartlarımızın bir listesini alırız:

![Pasted image 20241219195214.png](/img/user/resimler/Pasted%20image%2020241219195214.png)

Bu muhtemelen hassas kart bilgilerini ağ üzerinden göndermekten kaçınmak için kullanılır (örneğin tam kart numarası) ve bunun yerine backend'den elde etmek için bir referans kullanın. cardId elimizdeyken, items parametresi için beklenmedik bir tür göndererek kurcalama girişimimize devam edebiliriz.

Not: Daha önce de belirtildiği gibi, “ alışveriş sepetinde” ödeme sayfasında front-end tarafından gönderilen istekleri izleyerek de aynı sonuca ulaşabilirdik. Ancak, önceki demodan farklı olarak, burada farklı bir kod inceleme yaklaşımını öğrenmek için yalnızca back-end analizine bağlı kalmaya çalışıyoruz. Kapsamlılık adına, diğer yaklaşımı da birazdan göstereceğiz.


### Beklenen Arrays ve Beklenmeyen Sayılar

Daha önce planlandığı gibi /api/payment/charge adresine bir POST isteği hazırlayabilir ve daha önce gösterildiği gibi Bearer'a auth token'ımızı ekleyebiliriz. JSON body için, az önce elde ettiğimiz cardId'yi, değeri için herhangi bir sayı içeren items anahtarıyla birlikte aşağıdaki gibi ekleyeceğiz:

```json
{
  "cardId": "64b85d58cabeffbc46ce76c9",
  "items": 0
}
```

Request'i gönderdikten sonra, oldukça uzun sürdüğünü ve ardından tüm ürünler için fiyat bulamadı şeklinde yanıt verdiğini görüyoruz:

![Pasted image 20241219195534.png](/img/user/resimler/Pasted%20image%2020241219195534.png)

Kodu kontrol ettiğimizde, bunun fonksiyonun catch bloğu içinde olduğunu görüyoruz, çünkü fonksiyon “bir array yerine” bir sayı üzerinde döngü yapmaya çalışırken başarısız olmuş olmalı. Bunu, items değişkenini izleyerek ve try bloğu içinde bir breakpoint ayarlayarak, ardından yukarıdaki isteği tekrarlayarak doğrulayabiliriz. Bundan sonra, tam olarak ne olduğunu ve nerede kırıldığını daha iyi anlamak için bloğun içine girebiliriz.

![[unexpected_number_as_array_breakpoint.gif\|unexpected_number_as_array_breakpoint.gif]]

Gördüğümüz gibi, aldığımız özel hata (TypeError: items not iterable) idi. Bu, bunun gerçekten de beklenmedik bir girdi hatası olduğunu, ancak söyleyebileceğimiz kadarıyla zararsız olduğunu doğrulamaktadır. Bu durumda try/catch bloğu, fonksiyonun hatalı bir items değeriyle devam etmesini engellemiştir, ancak fonksiyonun items değerinin gerçekten bir array olduğunu ve boş olmadığını doğrulaması gerekirdi; aksi takdirde for döngüsüne giremez ve validateCartItemDetails() doğrulamasına ulaşamazdı.

Bunu yanlış pozitif olarak değerlendirebilir ve fonksiyon kodunu incelemeye devam edebiliriz. Test ettiğimiz her şey yararlı veya savunmasız olmayacağından, herhangi bir kod inceleme uygulamasında bu normaldir. Test ettiğimiz çoğu şey, özellikle de güvenli bir şekilde kodlanmış uygulamalarda yanlış uyarılar olacaktır. Yine de, önceki bölümde yaptığımız fonksiyon filtrelemesi yanlış uyarıların sayısını azaltmalı ve umarım uygulamanın en umut verici fonksiyonlarını test etmemizi sağlamalıdır.


## validateCartItemDetails()

Şimdi, önceki bölümde gözümüze çarpan ilginç kısma, yani kullanıcı girdimizi doğrulayan fonksiyona geliyoruz. Fonksiyon, daha önce belirlediğimiz gibi, items array üzerinde döngü yaparak başlar ve ardından her bir item için aşağıdakileri yapar:

```js
const { name, category, price, amount } = item;

// validate CartItemType array
const errors = await validateCartItemDetails({
  name,
  category,
  price,
  amount,
});

if (errors) {
  return next(errors);
}
```

Her bir öğeden dört değişken elde ettiğini ve ardından bunları validateCartItemDetails() ile doğruladığını görüyoruz. Ne yaptığını incelemek için bir kez daha CMD/CTRL ile üzerine tıklayabiliriz ve hemen altında bulabileceğimiz CartItemSchema'ya dayalı bir doğrulama testi çalıştırdığını görürüz:

```js
export const CartItemSchema = yup
  .object({
    name: yup.string().required(),
    category: yup.mixed().oneOf(["subscription", "exam", "cubes"]).required(),
    price: yup.number().required(), // in usd
    amount: yup.number().required(), // item count
  })
  .required();
```

Önceki bölümde belirttiğimiz gibi, herhangi bir kod gözden geçiricinin herhangi bir formun herhangi bir doğrulama testinin sağlamlığını doğrulayabilmesi gerekir, bu nedenle bu şemayı inceleyelim ve parçalara ayırmaya çalışalım.


## CartItemSchema

İlk olarak, şemadaki her öğenin `required()` ile işaretlendiğini ve tüm nesnenin de `required` olduğunu fark ediyoruz. Bu nedenle, **item** nesnesi tamamen eksikse ya da 4 anahtardan herhangi biri eksikse hata verecektir.

Bunun dışında, `name` değerinin bir string olduğundan emin olunuyor ve bu beklenen format olduğu için kabul edilebilir görünüyor. `category` için, üç izin verilen değerden (**subscription**, **exam**, **cubes**) biri olması gerektiği belirtiliyor ki bu da oldukça kısıtlayıcı olduğundan kabul edilebilir görünüyor. Ancak `price` ve `amount` için, bunların sayı olması gerektiği belirtiliyor fakat bunun üzerine ek bir doğrulama yapılmıyor. Bu durum, özellikle bu iki alanın **processPayment** fonksiyonu için oldukça hassas olduğunu düşündüğümüzde önemli bir eksiklik.

Peki, `price` ve `amount` doğrulamasında neler eksik? İlk olarak, sayıların pozitif bir değer olduğundan emin olunmuyor. Bu nedenle negatif bir `amount` veya `price` sağlayabiliriz, bu da çeşitli sorunlara yol açabilir. Ayrıca, bu alanlar için bir minimum değer belirtilmediğinden, `amount` için 0 kullanmak mümkün. Bu, satın alma işlemleri açısından mantıklı değil, ancak fonksiyon bunu doğrulamıyor. Bu nedenle, doğrulama testi açıkça kusurlu.

Bir sonraki bölümde, bu mantık hatasından yararlanıp yararlanamayacağımıza bakacağız ve bunu doğrulayabilirsek bir kanıt konsepti (**proof of concept**) oluşturacağız.


Soru : Bir ücret talebi göndermeyi deneyin ve {“amount”: “test”} ifadesini request body'deki öğelerden biri için kullanın. Hangi hata mesajını aldınız.

Cevap : 



### Lokal Test (Manipülasyon) - Beklenmeyen Girdi

Artık CartItemSchema'da doğrulama testinin hatalı olduğunu gösteren sağlam kanıtlarımız olduğuna göre, bundan yararlanıp yararlanamayacağımızı görmek için testimize devam edelim. Amacımız, toplam fiyat hesaplamalarını olumsuz etkileyen ve amaçlanan mantığı değiştiren beklenmedik bir girdi göndererek ödeyeceğimiz toplam fiyatı etkileyebileceğimizi kanıtlamaktır.



## Manipulating Prices

Daha kolay olan seçenekle başlayalım; satın aldığımız herhangi bir öğe için 0 fiyat vermek, parametre için tek koşul bir sayı olması olduğundan şema buna izin verir. Bu, potansiyel olarak herhangi bir öğeyi tamamen ücretsiz olarak satın almamıza olanak sağlayabilir.

Dinamik bir testle başlayabilir ve fiyatı 0 olan bazı küpleri satın almak için bir ücret isteği gönderebiliriz. Bir kez daha, front-end tarafından gönderilen isteği basitçe kopyalayabiliriz, ancak biz back-end'e bağlı kalmaya çalışacağız ve kendi JSON objemizi oluşturacağız. Gönderdiğimiz önceki JSON nesnesini tekrar kullanabiliriz, ancak öğe değeri için 0 yerine, daha önce gösterilen 4 öğeli bir nesne kullanacağız ve “fiyatı” aşağıdaki gibi 0 olarak ayarlayacağız:

```json
{
  "cardId": "64b85d58cabeffbc46ce76c9",
  "items": [
    {
      "name": "1000",
      "category": "cubes",
      "price": 0,
      "amount": 1
    }
  ]
}
```

Not: Kodu inceleyerek, name değerinin abonelik veya sınav adlarıyla eşleşmesi gerektiğini anlıyoruz, ancak küpler ne olacak? Fonksiyonun kodunu okursak, bunu bir sayı olarak ayrıştırdığını ve (parseInt(name)) içinde küp sayısı olarak kullandığını görürüz, bu nedenle “umarım ücretsiz!” almak istediğimiz küp sayısını gireceğiz. Bir kez daha, bu bilgiyi elde etmek için kolayca front-end'i kullanabilirdik, ancak biz kod inceleme yolunu seçtik.

Ne yazık ki, talebi gönderdiğimizde, Yetersiz para olduğunu belirten bir hata mesajı alıyoruz:

![Pasted image 20241219201240.png](/img/user/resimler/Pasted%20image%2020241219201240.png)

Belirlediğimiz fiyat 0 iken nasıl yeterli fonumuz olmayabilir? For döngüsünün kalan kısmını okumaya devam edersek, fonksiyonun gönderdiğimiz fiyatları kullanmadığını ve bunun yerine bunları manuel olarak hesapladığını veya DB'den çektiğini göreceğiz:

```js
case "cubes":
    total += (parseInt(name) * amount) / 10;
    break;
```

Dolayısıyla, fiyat değeri kullanılmadığından, düzgün bir şekilde doğrulanmamasına rağmen bir mantık hatasına neden olmuyor gibi görünmektedir.

Zorluk: Fonksiyon name değerini bir tamsayı olarak ayrıştırdığından, ayrıştırılamayan bir değer gönderirsek ne olur? Kod bu bilgiyi de doğruluyor mu? Ne olduğunu deneyin ve görün ve neden olduğunu bulmaya çalışın.


## Manipulating Items

Price değeri kullanılmıyor olsa da, amount değeri kesinlikle kullanılıyor ve hem toplam fiyatı hem de sonraki item processing fonksiyonunu gerçekten etkiliyor:

```js
switch (item.category) {
  case "cubes":
    total += (parseInt(name) * amount) / 10;
    break;
  <SNIP>
}

// process items
try {
  for (const item of items) {
    // repeat by the amount
    for (let i = 0; i < item.amount; i++) {
      switch (item.category) {
        // if coupon.type is cubes, then buy cubes for user with item.name
        case "cubes":
          await buyCubes(userId, parseInt(item.name), next);
          break;
        <SNIP>
      }
    }
  }
}
```

amount düzgün bir şekilde doğrulanmadığından, bu kusurdan yararlanmak için beklenmedik bir değer göndererek onu manipüle edebilir miyiz? Nerede ve nasıl kullanıldığını görmek için kodun geri kalanını inceleyelim. Yukarıdaki process items for döngüsünde, her bir item için, belirtilen kategoriye bağlı olarak uygun hesaplama türünü yürütmek üzere bir switch deyimi kullandığını görüyoruz. Küpler için, basitçe adı bir tamsayıya ayrıştırır ve ardından toplam fiyatı hesaplamak için bunu miktarla çarpar:

```js
case "cubes":
    total += (parseInt(name) * amount) / 10;
    break;
```

Daha önce sorduğumuz gibi, “test” gibi bir tamsayıya ayrıştırılamayan bir string kullanırsak ne olur? Bunu yaparsak, isteğin tüm testleri geçtiğini ve hatta aşağıda gösterildiği gibi başarılı bir satın alma döndürdüğünü görürüz:

![Pasted image 20241219201510.png](/img/user/resimler/Pasted%20image%2020241219201510.png)

Total ve name değişkenlerine watcher'lar ayarlayabilir ve items döngüsünün başına bir break point koyabilir ve ardından aşağıda gösterildiği gibi fonksiyon yürütmesini takip edebiliriz:

![[unexpected_string_parsing_debugging.gif\|unexpected_string_parsing_debugging.gif]]


JavaScript'in “test” stringini bir tamsayıya ayrıştırmaya çalıştığında başarısız olduğunu ve bunun yerine NaN döndürdüğünü, ancak bir hata vermediğini veya yürütmeyi durdurmadığını göreceğiz! Bu JavaScript'te garip bir davranıştır ve ilerleyen bölümlerde daha ayrıntılı olarak ele alınacaktır. Önemli öğrenme noktası, JavaScript'in dinamik yazımının, değerler tamamen kapalı olsa bile (yani null veya NaN) yürütmeye devam edebileceğidir.

Dolayısıyla, bu durumda, ödeme kartı bakiyesi testini geçen toplamı NaN olarak bozdu. Küp satın almaya çalıştığında da aynı şeyi yaptı ve küp sayımızı NaN olarak ayarlamaya çalıştı, bu da potansiyel olarak veritabanındaki verilerimizi bozabilir. Son olarak, kartımızın bakiyesini toplamla (yani “NaN”) ayarlamaya çalıştı, bu da veritabanını bozabilir.

Bu, önceki bölümde gösterdiğimiz item array hatasına ek olarak bu fonksiyonda bulduğumuz ikinci beklenmedik girdi hatasıdır. Bu hataların her ikisi de alınan diğer önlemlerle (ya da tamamen şans eseri!) kurtarılmış olsa da, web uygulamasının fonksiyonelliği açısından ciddi risk oluşturdukları için bu hataların her ikisinin de düzeltilmesi gerekmektedir. Null güvenliği bölümlerinde, null veya NaN değerlerinin nasıl ciddi sonuçlara yol açabileceğini göstereceğiz. Her halükarda, bu hatadan yararlanmak için gerçekleştirebileceğimiz acil bir eylem yoktur, bu nedenle fonksiyonun geri kalanıyla devam edeceğiz.


## Manipulating Amounts

Şimdi, yukarıda gösterilen debug işlemini gerçekleştirirken yaşadığımız süreci biraz daha inceleyelim. Abonelik switch case'ini incelemeye devam edersek, fonksiyonun önce DB'den abonelik adını aldığını, ardından fiyatını hesaplamak için maliyet değerini kullandığını ve bunu gönderdiğimiz miktarla çarptığını görürüz. Aynı işlem sınav için de yapılır. Fonksiyon, gönderdiğimiz miktarlara göre tüm ürünlerin toplam fiyatını hesaplamak için for döngüsü boyunca toplamı toplamaya devam eder.

Bundan sonra fonksiyon, hesaplanan toplamın if ((total > card.balance) ile kartımızın bakiyesi dahilinde olduğundan emin olur. Ardından, fonksiyon her bir ürün üzerinde döngü oluşturarak ve satın alma işlemi için uygun fonksiyona (buyCubes, buySubscription ve buyExam) aktararak her bir ürünü işlemeye başlar. Ayrıca bunu miktar sayısına göre tekrarlar, böylece birden fazla ürün satın almak birden fazla kez işlenir.

Son olarak, fonksiyon kart bakiyemizi tüm ürünlerin toplam fiyatına göre ayarlar, yani toplam fiyatı ödeme kartımızdan düşer.

```js
card.balance = card.balance - total;
await PaymentCard.updateOne(
  {
    userId,
    _id: cardId,
  },
  card
);
```

Tüm bunlar boyunca, toplam fiyatı ve bir ürünün kaç kez işleneceğini hesaplamak için tutarı kullanırken, tutarın negatif bir tutar olabileceğini doğruladığını (hatta dikkate aldığını) asla görmüyoruz. Dolayısıyla, belirli bir ürün için potansiyel olarak negatif bir tutar gönderebiliriz ve bu negatif tutarı ürünün fiyatıyla çarptığında, bu, aşağıdakileri yaptığında toplam fiyatı artırmak yerine azaltmasına yol açmalıdır:

```js
total += (parseInt(name) * amount) / 10;
```

Bu ürünün daha sonra işlenip işlenmeyeceği umurumuzda değil, ancak bu tüm işlevin başarısız olmasına yol açmadığı sürece, bu kusuru potansiyel olarak daha düşük bir toplam fiyat elde etmek için kullanabiliriz veya potansiyel olarak hiç ödeme yapmayabiliriz. Bu bulguyu bir sonraki bölümde doğrulayacağız.


# PoC and Patching - Unexpected Input

Tüm testlerimizden sonra, nihayet bulgularımızı test edebilir ve tespit ettiğimiz type hatasından yararlanarak gerçekten ücretsiz küp satın alıp alamayacağımızı görebiliriz.


## Proof of Concept

Bazı ücretsiz küpler veya indirimli bir ücret almak istediğimizi varsayalım. Negatif tutarlı bir öğe ekleyebiliriz ve bu tutar toplam fiyatı düşürmelidir. Örneğin, fiyatı 10 $ olması gereken 100 küp belirleyebiliriz (daha önce gösterdiğimiz hesaplamalara göre veya front-end'e göre). Miktarı -1 olarak belirtirsek, toplam fiyat (10 * -1 = -10) kadar ayarlanmalıdır. Eşit ancak pozitif tutarlı başka bir ürün eklersek, toplam 0 $ ücret almalıyız ve kartımızın bakiyesi etkilenmemelidir.

Gönderdiğimiz önceki payload'u tekrar kullanalım ve yukarıdaki kriterlere uyacak şekilde aşağıdaki gibi ayarlayalım:

```json
{
  "cardId": "64b85d58cabeffbc46ce76c9",
  "items": [
    {
      "name": "100",
      "category": "cubes",
      "price": 0,
      "amount": 1
    },
    {
      "name": "100",
      "category": "cubes",
      "price": 0,
      "amount": -1
    }
  ]
}
```

Fonksiyon bu talebi işlediğinde, önce kart kimliğimizi doğrulayacak, ardından ilk olarak 10 olması gereken toplam fiyatı hesaplamak için itemler üzerinde yineleme yapacak ve ikinci yinelemede -10 azaltılarak toplam 0 netleştirilecektir. Ardından, fonksiyon 0'ın kartımızın bakiyesi dahilinde olduğunu doğrulayacaktır, ki bakiyemiz 0 olsa bile bu olmalıdır.

Bundan sonra, fonksiyon itemleri tutarlarına göre işleyecektir. Yani, 100 küpü bir kez işleyecek ve negatif tutarı hiç işlemeyecektir. Son olarak, kartımızın bakiyesini toplam 0 fiyatına göre ayarlayacaktır, bu nedenle etkilenmemelidir.

Yukarıdaki isteği göndererek ve ne elde ettiğimizi görerek bunu test edelim:

![Pasted image 20241219202410.png](/img/user/resimler/Pasted%20image%2020241219202410.png)

Gördüğümüz gibi, yanıt, toplam 0 $ ile ödemeyi başarıyla işlediğini onaylıyor. Şimdi sağlanan kimlik bilgileriyle front-end'e giriş yapabiliriz ve küp sayımızın herhangi bir ödeme yapmak zorunda kalmadan gerçekten arttığını göreceğiz:

![Pasted image 20241219202432.png](/img/user/resimler/Pasted%20image%2020241219202432.png)

Sepet itemlerinin doğrulanma şeklindeki küçük bir hatanın ödeme sisteminin tamamen tehlikeye girmesine yol açtığını ve ödeme kartımızda sıfır bakiye olsa bile herhangi bir ürünü tamamen ücretsiz olarak satın almamıza izin verdiğini görebiliriz.

Alıştırma: Aynı saldırıyı tarayıcı ve front-end web uygulamasından başka bir şey kullanmadan da gerçekleştirmek mümkündür. Bunu yapmaya çalışın. İpucu: Tarayıcı sepetimizdeki ürünleri nasıl tutuyor?

Bu örnek, kullanıcı tarafından gönderilen her girdinin, bu girdiye/nesneye dahil olabilecek tüm alt öğeler de dahil olmak üzere, kapsamlı ve yeterli bir şekilde incelenmesinin ve doğrulanmasının önemini göstermektedir. Sağlam bir doğrulama mekanizması olmadan, böyle bir sorun ve diğerleri ortaya çıkabilir ve çeşitli mantık hatalarına yol açabilir.

Zorluk: Burada gösterdiklerimizi lokal ortamınızda kopyalamaya çalışın. Bundan sonra, processPayment fonksiyonu ve önceki bölümde kısaca listelediğimiz diğer fonksiyonlarla ilgili diğer sorunları bulmaya çalışın.


## Patching

Unexpected Input mantık hataları için, yalnızca beklediğimiz belirli girdi türünü kabul ettiğimizden ve diğer her şeyi reddettiğimizden emin olmalıyız. CartItemSchema yalnızca tutarın bir sayı olup olmadığını kontrol ettiği, ancak minimum 1 olan pozitif bir sayı olup olmadığını doğrulamadığı için bu işlevin ana sorunu yetersiz girdi doğrulamasıydı. Bu nedenle, tek yapmamız gereken aşağıda gösterildiği gibi bu kontrolleri şemaya eklemektir:

```js
// to process cart items in payment requests
export const CartItemSchema = yup
  .object({
    name: yup.string().required(),
    category: yup.mixed().oneOf(["subscription", "exam", "cubes"]).required(),
    price: yup.number().positive().min(1).required(),
    // in usd
    amount: yup.number().positive().min(1).required(), // item count
  })
  .required();
```

Tespit ettiğimiz diğer iki 'küçük' hataya gelince, bunları da düzeltme notlarımızda ele almalıyız. Items array hatası için, items değişkeni bir dizi değilse aşağıdaki gibi bir hata atabiliriz:

```js
try {
  if (!Array.isArray(items)) {
    throw new Error();
  }

  for (const item of items) {
    const { name, category, price, amount } = item;
    <SNIP>
  }
} catch (err) {
  <SNIP>
}
```

Son olarak, name tamsayı ayrıştırma hatasını düzeltmeliyiz. Bu hata için, name değerinin bir tamsayı olarak ayrıştırılabileceğini doğrulamamız gerekir, ancak yalnızca küp durumunda, diğer durumlarda string beklenir. Daha önce modülde gördüğümüz date formatını onaylamak için kullanılan benzer bir yöntemi, isNaN(parseInt(name)) kullanarak değerin güvenli bir şekilde ayrıştırılabileceğini onaylamak için aşağıdaki gibi kullanabiliriz:

```js
// add cost to total
switch (item.category) {
  case "cubes":
    if (isNaN(parseInt(name))) {
      throw new Error();
    }

    total += (parseInt(name) * amount) / 10;
    break;
  <SNIP>
}
```

Genel olarak, bu tür güvenlik açıklarını yamamak için, doğrulama testlerinin (örneğin şema) beklenen girdi türüyle doğru bir şekilde eşleştiğinden ve her bir girdi için aynı şeyi yaptığından emin olmamız gerekir. Doğrulama testleri manipülasyon için ekstra alan sağlıyorsa (yani çok çeşitli girdi türlerini kabul ediyorsa), muhtemelen bu tür saldırılara karşı savunmasız olacaklardır.

Alıştırma yapın: Kodunuzu yamalamayı deneyin ve daha sonra yukarıdaki PoC'yi ve diğer iki hata için önceki bölümlerde denediklerimizi tekrar uygulayın.


Soru : Az önce incelediğimiz 'processPayment' fonksiyonunda başka bir 'beklenmedik girdi' mantık hatası var. Bu sorunu tespit etmek için tekrar gözden geçirmeyi deneyin, ardından “Akademiye Giriş” modülünün kilidini açmak ve ilk bölümündeki bayrağı elde etmek için bundan yararlanın. Not 1: Önceki hata artık düzeltildi. Not 2: Token/küp bakiyenizi yenilemek için yeniden giriş yapmanız veya kullanıcı bilgilerinizi güncellemeniz gerekmektedir.

Cevap : 


# Null Safety

Null değişken kavramı bilgisayar programcılığında 1965 yılına kadar uzanmaktadır. NULL referansının mucidi, yıllar boyunca bilgisayar programlarına getirdiği sayısız sorun nedeniyle bu kavramdan “[Milyar Dolarlık Hata](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)” olarak bahsetmiştir. Örneğin C'deki null pointer'lar çeşitli yazılım açıklarına ve hatalarına yol açmıştır.

Bu bize kodda null değişkenlere izin vermenin neden genellikle kötü bir fikir olarak kabul edildiğine dair temel bir fikir vermelidir, çünkü kullanıcı deneyimini bozabilecek çalışma zamanı hatalarına neden olabilirler. Null değişkenler ayrıca, ilerleyen bölümlerde göreceğimiz gibi, kullanıcıların belirli kısıtlamaları atlamasına ve erişim kontrolü sorunları yoluyla değil, mantık hataları yoluyla erişmemeleri gereken verilere erişmesine olanak tanıyan kusurlar da ortaya çıkarabilir.

Bu tür güvenlik açıkları o kadar yaygındır ki, bu bölümü yazarken Facebook uygulamasında bizzat bir tanesiyle karşılaştım. Bir bildirime tıklayarak bir yoruma eriştiğimde (bu, uygulamanın bildirim tarafından belirlenen URI'ye gitmesini tetikler), ne zaman bir yorum eklesem başarısız olduğunu ve yeniden denememi istediğini fark ettim. Sonra, (null) olarak yanıtla dediğini fark ettim, bu yüzden muhtemelen hala kullanıcı bilgilerimi yüklüyordu, bu da muhtemelen eksik tanımlayıcılar (ör. userId) nedeniyle yorumu ekleyememesine neden oldu.

![Pasted image 20241220091844.png](/img/user/resimler/Pasted%20image%2020241220091844.png)

Bu çok küçük bir kullanıcı rahatsızlığı mantık hatası olsa da, bu tür hataların çok sıkı kodlama ve güvenlik standartlarına sahip kuruluşlarda bile meydana geldiğini göstermektedir, bu yüzden bunları öğrenmeli ve önlemek için önlemler almalıyız.


## Null Variables

Null değişken, kendisine hiçbir değer atanmamış bir değişkendir. Genellikle bir değişken başlangıç değeri olmadan tanımlandığında ortaya çıkar (örneğin var count=0; yerine var count;). Bu, belirli bir değişkenin değerinin uzak bir kaynaktan çekilmesini beklemek gibi belirli koşullar altında yararlı olabilir.

Bu, geliştiricilerin değişkeni bir başlangıç değeri olmadan bildirmesine ve daha sonra alındıktan sonra ona bir değer atamasına yol açar. Değişkene yeni bir değer atanmadan önce asla erişilmez veya kullanılmazsa, kod null-safe olarak kabul edilir. Ancak, değişkene erişilirse veya bir fonksiyona/metoda aktarılırsa (örn. count.toString()), null referans hatası olarak bilinen bir çalışma zamanı hatasına yol açar ve uygulamanın bir kısmını/tamamını çökertir.

Değişkene bir değer atanmadan önce erişilebilecek çok sayıda durum vardır. Örneğin, bir front-end web uygulaması uzak bir kaynaktan (örneğin internete bağlı olmayan kullanıcı cihazı) bir değişkenin değerini alamayabilir, bu nedenle sayfayı bu değişkene bir değer atanmadan oluşturmaya devam edebilir, bu da bir run-time hatasına neden olur ve sayfayı çökertir.

Bu nedenle, bazıları potansiyel olarak yararlanabileceğimiz mantık hatalarına yol açabilecek null ile ilgili çalışma zamanı hatalarını önlemek için null-safe olan kodu nasıl yazacağımızı bilmemiz önemlidir.



## Null Safety

Null güvenliğini destekleyen modern diller, düzenleme zamanı sırasında veya kod derlenmeden önce belirli kontrolleri/kuralları uygulayarak null değişkenlere bir değer olmadan asla erişilmemesini sağlar. Null güvenliği çözümlerini uygulayan dillerden bazıları şunlardır:

- TypeScript
- Rust
- C#
- Swift
- Kotlin
- Dart

Ancak JavaScript gibi diğer birçok dil henüz null güvenliğini tam olarak desteklemediğinden, birçok geliştirici null bir değişkene bir değer atanmadan önce erişilmediğinden emin olmak için belirli kontroller kullanma eğilimindedir. Örneğin, bir geliştirici değişkenin null olup olmadığını test edebilir (örn. if (count === null) veya if !(count)) veya mevcut değerin beklenen türle eşleştiğinden ve null olmadığından emin olmak için tür doğrulama testleri gerçekleştirebilir.

Bu tür kontrollerle bile, değişkenlere bir değer atanmadan önce erişilmesine neden olan öngörülemeyen durumlar olabileceğinden null referans hatalarını tamamen önleyemeyiz.

Her dil kendi ortamına uyan biraz farklı bir yaklaşıma sahip olsa da, çoğu dil null-safe koda izin vermek için benzer temel kavramları kullanır. Bunlardan bazıları şunlardır:

![Pasted image 20241220093014.png](/img/user/resimler/Pasted%20image%2020241220093014.png)


Null-safe diller hem nullable hem de non-nullable değişkenleri desteklerken, diğer diller genellikle sadece nullable değişkenleri destekler. Bu nedenle, JavaScript gibi bazı null-safe olmayan diller, olası null hatalarını azaltmak için ?. veya ?? gibi yukarıdaki null operatörlerinden bazılarını desteklemeye başlamıştır.

Bu aynı zamanda, bir uygulama null güvenli bir dilde kodlanmış olsa bile, null güvenlik kontrollerinden bazılarını geçersiz kılabileceğinden (örneğin ! kullanarak) null güvenli olmayan kod üretebileceğini ve bunun da null güvenlik mantık hatalarına yol açabileceğini göstermektedir. Bu nedenle, bu kontrolleri geçersiz kılmaktan mümkün olduğunca kaçınmaya çalışmalı ve null güvenlik geçersiz kılmalarını yalnızca değişkenin null olmayacağından %100 emin olduğumuzda kullanmalıyız (örneğin if (count !== null) ile).

Not: Her dilin null güvenliğini derecelendiren ve null güvenliği açısından en iyi/kötü dillerin bir listesini sunan bu [makaleye](https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/) başvurabilirsiniz.


## Identifying Null Bugs

Çoğu mantık hatasının aksine, null güvenlik sorunları, yukarıda bahsedilen çoğu dilin düzenleme zamanı sırasında yaptığı gibi, araçlar aracılığıyla güvenilir bir şekilde tanımlanabilir. Ancak, bu yalnızca bir değişkene null iken erişilebileceği olası durumları tanımlar ve erişilmesi durumunda nelerin etkileneceğine dair herhangi bir mantık analizi yapmaz. Ayrıca, daha önce de belirtildiği gibi, güvenlik kontrollerini geçersiz kılan null-safe diller bile (örneğin, ! veya null güvenliğini tamamen kapatarak), hala null güvenlik mantık hatalarına sahip olabilir. Bu nedenle, null-güvenli diller için null güvenliği geçersiz kılmalarına odaklanacağız.

Dolayısıyla, izleyebileceğimiz süreç, kullanıcı tarafından kontrol edilebilen potansiyel null değişkenleri belirlemek ve ardından bunun neden olabileceği potansiyel mantık hatasını araştırmaktır. İlk adım için, null güvenlik türüne bağlı olarak aşağıdakileri yapabiliriz:

1. Null güvenliği olmayan diller için: Başlatılmamış değişkenleri veya daha sonra null olarak atanan değişkenleri arayın.

2. Null-güvenli diller için: Null olmayan onay operatörü (!) kullanımlarını gözden geçirin ve bir null-reference hatasına yol açıp açmayacağına bakın.


Bunları belirledikten sonra, type validation veya if (count !== null) koşul testleri gibi bu değişkenler için yapılan null güvenlik kontrollerini gözden geçirmemiz gerekir. Bu kontrolleri atlayabilecek bir durum belirleyebilirsek, potansiyel bir mantık hatasına yol açıp açmayacağını belirlemek için bu değişkeni daha fazla lokal test ve kod incelemesi için kısa listeye alabiliriz.

Bunu akılda tutarak, bir sonraki bölümde tüm potansiyel null değişkenlerin bir listesini oluşturarak başlayabilir ve ardından sonraki adımlarla devam edebiliriz.

Alıştırma: Şimdiye kadar, bir kod tabanında nasıl gezineceğiniz ve nasıl çalıştığını anlayacağınız konusunda oldukça iyi bir fikre sahip olmalısınız. Bu nedenle, modülün geri kalanına devam etmeden önce becerilerinizi test etmenin zamanı geldi. Kod tabanındaki olası null safety mantık hatalarını belirlemek için yukarıdaki süreci kullanmaya çalışın. Daha sonra bulgularınızı ve izlediğiniz süreci gelecek bölümlerde ele alınacak olanlarla karşılaştırabilirsiniz; bu, neyi daha iyi yapmış olabileceğinizi bilmek için önemli bir adımdır.


Soru : Null safety mantık hatalarına karşı savunmasız bir fonksiyonu tanımlamak için yukarıdaki işlemi deneyin. Böyle bir fonksiyonun adı nedir?

Cevap : 


# Code Review (Optional Parameters) - Null Safety

Önceki bölümde, null hatalarının oluşabileceği 2 yolu belirttik: null değişkenler ve isteğe bağlı parametreler. Tüm nullable değişken vakalarını inceledik ve bunların çoğunlukla güvenli bir şekilde ele alındığını gördük.

Null hatalarına yol açan ikinci yaygın yol, null değerlerin/değişkenlerin nullable/isteğe bağlı parametrelere atanmasıdır; bu durum fonksiyonlarda ve nesnelerde meydana gelir. Hem fonksiyonlar hem de objeler opsiyonel parametrelere/anahtarlara izin verebilir ve eğer bu parametrelerin varsayılan bir değeri yoksa, fonksiyonun bu parametreler aktarılmadığında (yani null olduklarında) bunları nasıl ele alacağını görmemiz gerekir.

Bu bölümde, temel olarak kullanıcı girdisini kullanan API endpoint'lerini belirlemeye çalışacağız ve ardından endpoint parametrelerinden herhangi birinin isteğe bağlı olup olmadığına bakacağız (yani null olabilir). İsteğe bağlı parametrelere izin veriyorlarsa ve null değerlerin kullanılmadığından emin olmak için uygun testler yapmıyorlarsa, mantık hataları oluşabilir ve biz de bunu tespit etmeye çalışacağız.


## Identifying Null Parameters

JavaScript named parametreleri (örn. ({param1, param2})) ve positional parametreleri (örn. (param1, param2)) destekler. Named parametreleri kullanmanın ana faydası, bunları doğru bir şekilde sıralamamız gerekmemesi ve her bir argümanı parametrenin adıyla çağırabilmemizdir. Bu, yukarıda belirtildiği gibi, değer olarak null kabul eden isteğe bağlı parametrelere de izin verir. Ancak, fonksiyonun isteğe bağlı bir parametre kabul ettiğini ve uygun null kontrolleri yapmadığını ve sonunda parametreyi null iken kullandığını varsayalım. Bu durumda, çalışma zamanı hatalarına ve mantık hatalarına yol açabilir.

Aynı şey, daha sonra doğrudan atama (örn. const param1 = obj.param1;) veya object destructuring (örn. const {param1, param2} = obj;) yoluyla bir fonksiyona atayabileceğimiz named parametreler içeren nesneler için de geçerlidir. Bu, özellikle POST isteklerindeki JSON nesnelerinde (örn. req.body;) çok yaygın olarak kullanılır ve her JSON parametresini bir değişkene atamaktan çok daha basit ve kısadır.

Asıl soru, bir endpoint bizden belirli bir parametre göndermemizi beklerse ve biz bunu yapmazsak ne olur? Bu oldukça normaldir ve genellikle JSON nesnesini şemalar (daha önce gördüğümüz gibi) veya başka herhangi bir yolla doğrulayarak ele alınır. Dolayısıyla, örneğin boş bir body gönderirsek, tam olarak neyin eksik olduğunu belirten bir hata atarak zarif bir şekilde ele alınmalıdır. End-point'lerde opsiyonel parametrelerle herhangi bir null safety hatasının olması, özellikle son kullanıcı tarafından doğrudan kontrol edilebilecekleri için ciddi mantık hatalarına yol açabilir.

Eksik API/JSON parametrelerini kontrol etmek, önceki bölümde bahsettiğimiz null kontrollerine oldukça benzerdir ve daha önce tartıştığımız aynı tuzaklardan muzdarip olabilir. Dolayısıyla, null güvenliği mantık hataları söz konusu olduğunda, sorun yaratma olasılığı en yüksek olan alan budur.


### Gerekli ve İsteğe Bağlı Parametreler

Esas olarak kullanıcı girdisiyle ilgili sorunları aradığımız için, daha önce Unexpected Input - Code Review bölümünde listelediğimiz kullanıcı girdisini kullanan endpoint'lere geri dönebiliriz. Ancak bu kez, girdinin null olmadığını doğrulamak için yeterli test olup olmadığını kontrol edeceğiz.

Ayrıca daha önce tüm endpoint'lerin kullanıcı girdisini bir ID olmadığı sürece bir şema aracılığıyla doğruladığını öğrendik, bu durumda veritabanında aranarak doğrulanır ve eşleşme bulunamazsa bir hata atılır. Kullanıcı tarafından kontrol edilebilen tüm girdileri gözden geçirmek ve herhangi bir kontrolün eksik olup olmadığını kontrol etmek her zaman yararlıdır, ancak beklenmedik girdi bölümlerinde bunu zaten doğruladığımız için, tüm girdilerin veritabanı veya bir şema aracılığıyla doğrulanacağını güvenle varsayabiliriz.

Peki bu, kodun null güvenliği sorunlarına karşı güvende olduğu anlamına mı geliyor? Tabii ki hayır, çünkü şemalar düzgün yapılandırılmadıkları takdirde null parametrelere izin verebilir.

Bir validasyon aracından diğerine farklılık gösterse de, hemen hemen hepsi, daha önce tartıştığımız gibi, tıpkı named fonksiyonlar gibi gerekli ve isteğe bağlı parametrelere izin verir. Bu durumda, yup paketi .required() seçeneğini kullanarak zorunlu alanları belirtmemize izin verir. Eğer endpoint belirli opsiyonel parametrelere izin veriyorsa, .required() seçeneği kullanılmayacaktır ve endpoint parametrenin kullanılıp kullanılmamasına bağlı olarak buna göre hareket etmelidir. Bu, farklı şemalarda kullanılan tüm isteğe bağlı parametre örneklerini tanımlamamız ve ardından bunları null güvenlik sorunları açısından incelememiz gerektiği anlamına gelir, çünkü endpoint sağlam bir mantıkla kodlanmamış olabilir ve bu da bir mantık hatasına yol açabilir.

Neyse ki, önceki bir bölümde kullanıcı girdisi ile şemaları kullanan endpointleri zaten tanımlamıştık. Burada şemalarının adlarıyla birlikte tekrar yer almaktadırlar:

- `validateCouponCode` -> `CouponCodeSchema`
- `validateCartItemDetails` -> `CartItemSchema`
- `resetPassword` -> `passwordResetSchema`
- `validateUserDetails` -> `UserSchema`

Alıştırma: İsteğe bağlı parametreler için yukarıdaki 4 şemayı kontrol edin (.required seçeneği eksik) ve ardından şemalarını kullanan endpointlerde bu isteğe bağlı parametreleri arayın (Beklenmeyen Girdi - Kod İnceleme bölümünde de bulunur) ve bu isteğe bağlı parametrelerin kullanıldığı null değerleri düzgün bir şekilde kontrol edip etmediklerini görün.


## Identifying Optional Parameters

Artık null değer tutabilecek opsiyonel parametreleri tanımlamaya başlayabilir ve ardından opsiyonel parametreleri nasıl ele aldıklarını görmek için fonksiyonlarını inceleyebiliriz. Yukarıdaki şemalarla başlayalım ve herhangi bir isteğe bağlı parametreyi destekleyip desteklemediklerini görmek için bunları tek tek inceleyelim.

İlki olan CouponCodeSchema, yalnızca .required() ile gösterilen tek bir coupon parametresini desteklediği için oldukça basittir, yani optional bağlı değildir ve bunu sağlamazsak şema doğrulama testi hata verecektir:

```js
export const CouponCodeSchema = yup.object({
  // coupon must be an md5 hash of the coupon code
  coupon: yup
    .string()
    .matches(/^[a-f0-9]{32}$/i, "Invalid coupon.")
    .required(),
});
```

Daha sonra, dört parametresi olan CartItemSchema (beklenmedik giriş hatalarından yamaladığımız) var, ancak hepsinde .required() var, yani hiçbiri isteğe bağlı değil. Bunun da ötesinde, tüm nesnenin kendisi .required()'dir, yani boş bir sepet gönderirsek, bu da hata verecektir:

```js
export const CartItemSchema = yup
  .object({
    name: yup.string().required(),
    category: yup.mixed().oneOf(["subscription", "exam", "cubes"]).required(),
    price: yup.number().positive().min(1).required(),
    // in usd
    amount: yup.number().positive().min(1).required(), // item count
  })
  .required();
```

PasswordResetSchema bundan sonra aşağıdaki gibi gelir:

```js
const passwordResetSchema = object({
  // validate mongodb object id
  id: mixed((value) => ObjectId.isValid(value)).typeError("Invalid id"),
  // validate bcrypt hash
  token: string().matches(/[0-9a-f]{32}/i, "Invalid token"),
  // validate password
  password: string().min(5),
}).required();
```


Objenin tamamı .required() iken, parametrelerden hiçbirinin bu seçeneğe sahip olmadığını görüyoruz ki bu biraz garip bir durum. Dolayısıyla, en az birini sağlamamız gerekiyor, ancak hepsi isteğe bağlı olarak kabul edildiğinden hangisini gönderdiğimiz önemli değil. Bu kesinlikle ilginç ve daha sonra buna bir göz atmalıyız.

Son olarak, tüm uygulamada en çok kullanılan şemalardan biri olan UserSchema'ya sahibiz. Her biri bir kez kullanılan önceki üç şemanın aksine, bu şema createUser, login, updateUserDetails ve requestPasswordResetLink gibi çoğu kullanıcı endpoint'i için kullanılır. Tüm bu fonksiyonlar hassas ve ilginçtir, bu da bu şemayı öncelikler listesinde üst sıralara çıkarır. Şimdi parametrelerine bakalım:

```js
export const UserSchema = yup
  .object({
    id: yup.string(),
    name: yup.string(),
    username: yup.string(),
    email: yup.string().email().required(),
    password: yup.string().min(5).required(),
    registrationDate: yup.date(),
  })
  .required();
```

Gördüğümüz gibi, altı parametreden dördü isteğe bağlıdır, yani: id, name, username ve registrationDate. Bu oldukça garip bir seçimdir, çünkü id veya kullanıcı adı gibi parametrelerin gerekli olmasını bekleriz, ancak belki de bunun nedeni birden fazla endpoint ile kullanılmasıdır ve tüm endpointler bu alanların tümünü gerektirmez. Her durumda, lokal testlerimiz için kısa listeye almaya değer.

soru  : “ password” parametresini eklemeden bir oturum açma isteği göndermeyi deneyin. Hangi hata mesajını aldınız.


# Local Testing (Schemas) - Null Safety

Opsiyonel parametrelere sahip endpointlerin bir listesiyle, bu opsiyonel parametrelerin kullanımını incelemeye başlayabilir ve null güvenlik sorunları olabileceğinden endpoint tarafından nasıl ele alındıklarını görebiliriz. Herhangi bir null güvenlik sorunu tespit edersek, daha zor olan kısma geçebiliriz, yani bu tür kusurlardan nasıl yararlanabileceğimizi görmeye çalışabiliriz.


## UserSchema

Önceki bölümde, iki farklı şemada opsiyonel parametreler tanımladık: passwordResetSchema ve UserSchema. Her iki şemanın tüm kullanımları /controllers/ altındaki users-controllers.js dosyasında bulunur. İki şemadan daha ilginç/hassas olan UserSchema ile başlayacağız.

Önceki bölümde belirtildiği gibi, bu şemanın dört isteğe bağlı parametresi vardır: id, name, username, registrationDate ve 4 farklı endpointde kullanıcı girdisini doğrulamak için kullanılır: createUser, login, updateUserDetails ve requestPasswordResetLink. Şimdi bunların her birini inceleyelim ve potansiyel null değişkenleri nasıl ele aldığını görelim.

createUser ile başlayacağız. İlk fark ettiğimiz şey, name ve username değişkenleri için null kontrolleri gerçekleştirdiğidir:

```js
// name/username are not set as required in the schema, so we need to check for them here
if (!name || !username) {
  if (!name) {
    <SNIP>
  } else {
    <SNIP>
  }
}
```

Bu da şu soruyu akla getiriyor: Bu parametreler neden burada null-check yapmak yerine şemada .required() olarak ayarlanmadı? En olası cevap, bu alanların girdi doğrulaması için UserSchema kullanan tüm endpoint'lerde gerekli olmayabileceğidir; dolayısıyla isteğe bağlı olarak ayarlanmışlardır.

Ancak, null güvenlik sorunlarına yol açabileceğinden bu kötü bir uygulamadır ve daha iyi uygulama şema için koşullu gereksinimleri kullanmak olacaktır. Bu, her bir parametrenin opsiyonel veya zorunlu olarak kabul edileceği belirli bir koşul belirlediğimiz anlamına gelir; örneğin, useUsername toggle'a sahip olmak gibi, bazı parametreleri opsiyonel olarak ayarlayabilir. Başka bir seçenek de her bir kullanım durumu için farklı bir şema kullanmak olabilir, ancak bu her zaman ideal veya verimli değildir, çünkü tekrarlama miktarına neden olacaktır.

Yukarıdakilere ek olarak, JavaScript'te not operatörünün (!) kullanımının bazı dezavantajları olduğunu zaten tespit etmiştik. Örneğin, adı 0 olarak ayarlarsak, null olarak ayarlamamış olsak bile yukarıdaki koşul tetiklenir ve aşağıda gösterildiği gibi 1 veya “0” ya da başka bir string olarak ayarlamak işe yarar:

![not_operator_null_bug.gif](/img/user/resimler/not_operator_null_bug.gif)

Bir ismin asla “0” olmaması gerektiği için bu durum bu durumda açık olsa da, sayısal değerler bekleyen diğer bazı parametreler, beklenmedik girdi bölümlerinde gördüğümüz örnekteki amount gibi aynı sorunla karşılaşabilir. Bu nedenle, bu tür edge case'lerden kaçınmak için mümkün olan her yerde her parametreyi doğrularken belirli bir kalıp kullanılması da tavsiye edilir. Ayrıca, lokal null kontrolleri yapmamız gerektiğinde, not operatörünü (!) kullanmaktan kaçınmalı ve katı eşitliğe bağlı kalmalıyız (örneğin, if (name === null || name === undefined)).

name ve username dışında, id ve registrationDate otomatik olarak oluşturulur ve kullanıcı girdisi olarak aktarılmaz, bu nedenle bu durumda kullanımları güvenlidir. Login endpoint'ine geçersek, yalnızca iki kullanıcı girdisi kabul ettiğini görürüz: e-posta ve şifre, her ikisi de şema tarafından gereklidir, bu nedenle bunlar da güvenlidir.

Daha sonra, 3 kullanıcı giriş parametresi kabul eden updateUserDetails'e sahibiz: name, username, email, bunlardan ikisi şema tarafından isteğe bağlı olarak ayarlanmıştır (name ve username). Endpoint, kullanıcı girişini test etmek için şema doğrulamasını kullanır:

```js
const errors = await validateUserDetails({
  email,
  password: process.env.VALIDATION_TEST_PASSWORD,
  name,
  username,
});
if (errors) {
  return next(errors);
}
```


Kodun, gerekli bir alan olmasına rağmen bu endpoint'te kullanılmadığı için gerekli parola alanı için önceden ayarlanmış rastgele bir parola kullandığını görüyoruz. Bu, kötü bir şema tasarımının başka bir örneğidir, çünkü gerekmediği halde gerekli parametreleri geçmek için geçici bir çözüm kullanmaktadır. Bir kez daha bu, usePassword geçişi false olarak ayarlandığında parola parametresini isteğe bağlı olarak ayarlaması gereken koşullu gereksinimin kullanılması gereken başka bir durumdur.

Bunun dışında, şema tarafından isteğe bağlı parametreler olarak ayarlanmalarına rağmen hem name hem de username'in daha sonra veritabanındaki kullanıcı ayrıntılarını güncellemek için kullanıldığını görüyoruz ve yukarıda createUser endpoint'in yaptığı gibi endpoint'in bunların null olup olmadığını kontrol ettiğini bile görmüyoruz:

```js
const updateReq = await User.findByIdAndUpdate(
  // use id from token to ensure users can only update their own account
  req.user?.id,
  {
    email,
    name,
    username,
  },
  {
    returnOriginal: false,
  }
);
```

Bu kesinlikle bir sorundur, çünkü veritabanında null değerleri saklayabiliriz ve kodun herhangi bir yerinde null değerler beklenmezken bu değerler alınırsa, çalışma zamanı hatasına veya işlemin çökmesine neden olabilir. Bunu daha sonra test edeceğiz.

Son olarak, bu şema yalnızca bir parametre (e-posta) kabul eden requestPasswordResetLink'te kullanılır ve bu parametre şemada .required() olarak işaretlenmiştir ve güvenli olduğu düşünülebilir.



## PasswordResetSchema

İkinci şemaya geçiyoruz. Önceki şemadan farklı olarak, bu şema tanımlandığı endpoint içinde yalnızca bir kez kullanılır. Daha önce, şemanın tamamı gerekli olarak ayarlanmış olmasına rağmen, tüm parametrelerinin isteğe bağlı olarak ayarlandığını fark etmiştik. Bu, şema doğrulama testini geçmek için parametrelerden en az birini sağlamamız gerektiği anlamına gelir, ancak hangi parametreyi kullanmayı seçtiğimiz önemli değildir.

Her bir parametrenin endpoint'te nerede kullanıldığını görmeye çalışalım. id parametresinin kullanıcıyı tanımlamak ve ardından gizli parola sıfırlama token'ını hesaplamak için kullanıldığını görüyoruz:

```js
// retrieve user based on id
try {
  user = await User.findById(id);
  <SNIP>
}
<SNIP>

// generate password reset token based on password hash and user id
const hashedToken = md5(`${id}:${user?.password}`);
```

Token'a gelince, esas olarak yukarıda hesaplandığı gibi gizli token'a karşı doğrulama yapmak için kullanılır:


```js
// verify password reset token based on password hash and user id
// if not valid, return error
if (token && token !== hashedToken) {
  return next({
    message: "Invalid password reset token.",
    statusCode: 403,
  });
}
```

Şifre, her şey doğrulandıktan sonra şifreyi değiştirmek için kullanılır. Yani, uygulama temel olarak kullanıcı kimliğini ve gizli token'ı kabul eder, ardından gönderilen token'ı veritabanlarında saklanan gizli kullanıcı ayrıntılarına (esas olarak eski şifre karması) dayanarak hesapladığı token ile dinamik olarak karşılaştırır.

Çoğu modern uygulama, parola sıfırlama talebi üzerine rastgele ve uzun bir gizli token üretir ve ardından token'ın tahmin edilememesini ve zamanında sona ermesini sağlamak için bir son kullanma tarihiyle birlikte veritabanında saklar. Yine de bazı küçük uygulamalar tokenları back-end'de saklamaktan kaçınmak için bu dinamik yaklaşımı kullanır ve kullanıcıların tahmin edemeyeceği gizli bilgileri kullanarak çalışma zamanında hesaplar. İlk yaklaşım önerilse de, bu yaklaşım mutlaka güvensiz değildir, bu nedenle bunu bir güvenlik riski olarak değerlendirmeyeceğiz.

Ancak, kodla ilgili tek sorun bu mu? Bizi buraya getiren asıl sorun, tüm bu parametrelerin opsiyonel olarak kabul edilmesidir. Peki, bunlardan herhangi biri null olarak ayarlanırsa ne olur? Bir sonraki bölümde bunu test edeceğiz.

Soru : Docker konteynerini yeniden başlattıktan sonra, varsayılan kullanıcının auth token'ını kullanın ve /api/users/update adresine bir istek göndermeyi deneyin, ancak istek body'sine "name" parametresini eklemeyin. İstek işlendikten sonra, kullanıcının “Full Name” değeri nedir?

Cevap : 




# Local Testing (functions) - Null Safety

Artık birkaç potansiyel null güvenlik sorunu tespit ettiğimize göre, daha önce de belirtildiği gibi söylemesi yapmaktan daha kolay olabilecek bu kusurlardan yararlanmaya çalışmanın zamanı geldi. Enjeksiyon ve tip güvenliği açıklarında, potansiyel güvenlik önlemlerini atlamak için çeşitli payload'lar kullanabilir ve saldırı vektörümüzü değiştirmek için bunları değiştirebiliriz.

Ancak null güvenlik saldırılarında elimizdeki tek kontrol null bir değişken göndermek ve sunucunun bunu nasıl ele aldığını görmektir. Yani, temelde null olan tek bir değer kullanabiliriz ve bunun dışında fazla bir kontrolümüz yoktur.



### Null Güvenlik Sorunlarının Yaygın Etkileri

Null güvenlik sorunlarının büyük çoğunluğunun çalışma zamanı hatalarına yol açtığını veya back-end sunucu sürecini çökerttiğini, bunun da genellikle yavaş veya geçici bir hizmet reddine neden olduğunu ve bazı durumlarda tüm sunucuyu çökerttiğini belirtmek önemlidir. Elbette bu tek başına büyük bir sorundur ve çok ciddiye alınmalıdır, çünkü hizmet reddi saldırıları kötü niyetli aktörler tarafından en çok kullanılan saldırılar arasındadır, özellikle de geniş bir bot ağına (yani DDoS) güvenmeden neden olabiliyorlarsa.

Buna ek olarak, null değişkenin, özellikle back-end veritabanının bir kısmını/tamamını bozmak veya hatta belirli güvenlik önlemlerini atlamak gibi başka bir tür mantık hatası veya güvenlik açığı ile eşleştirildiğinde başka sorunlara neden olabileceği bazı durumlar da vardır. Ancak bu büyük ölçüde hedef uygulamaya ve uygulamanın nasıl tasarlandığına bağlıdır.



### Kullanıcı Bilgilerini Güncelle (Update)

Önceki bölümde gördüğümüz gibi, name ve username parametreleri isteğe bağlıdır, bu nedenle bunlara null değer atarsak, veritabanında bu şekilde saklanabilirler ve bu da birden fazla potansiyel etkiye sahip olabilir. Örneğin, uygulama boyunca bu parametrelerin kullanımlarını arayabilir ve kullanıcı ayrıntılarının users veritabanı koleksiyonundan ne zaman alındığını görebiliriz. Veritabanından alınan değerlerin genellikle depolanmadan önce filtrelendiğine ve doğrulandığına güvenildiğinden, bu değerler kullanılmadan önce null kontrollerinin yapılmaması muhtemeldir. Eğer durum buysa, sunucuyu çökertebilir ya da güvenlik açığı mantığına bağlı olarak başka bir şey yapabiliriz.

Ancak bunu yapmadan önce, veritabanında null değerleri gerçekten saklayabildiğimizden emin olmamız gerekir. Bunu yapmak için, JSON objesine “name” ve “username” parametrelerini dahil etmeyeceğiz, çünkü empty (boş) bir değer kullanmak basitçe boş bir string olarak değerlendirilecektir, bu da null değildir ve tartıştığımız aynı sorunlara neden olmaz. Bu nedenle, aşağıdaki POST body ile başlayalım ve gerekli bir alan olduğu için yalnızca e-posta parametresini dahil edelim:

```json
{
  "email": "[email protected]"
}
```

API endpoint'inin rotasını bulmak için updateUserDetails fonksiyonunun adına CMD/CTRL ile tıklayabiliriz ve user-routes.js dosyasında bu fonksiyona referans verildiğini görebiliriz:

![Pasted image 20241220103856.png](/img/user/resimler/Pasted%20image%2020241220103856.png)

Bu bize kullanıcı rotaları altında (app.js'de /api/users/ olarak tanımlanmıştır) /update adresine bir POST isteği göndermemiz gerektiğini söyler, bu nedenle son istek /api/users/update adresine olacaktır. Ayrıca bunun verifyToken'dan sonra geldiğini görüyoruz, yani isteğimizin bir token ile doğrulanması gerekiyor. Bu, kullanıcı ayrıntılarını elde etmek için auth token'ının kodunu çözerek ayarlanan req.user?.id'nin fonksiyon içinde kullanılmasıyla da anlaşılır.

Dolayısıyla, token'ı tarayıcı oturumumuzdan kopyalayabilir (maceracı hissediyorsanız, bir oturum açma isteği göndererek de elde edebilirsiniz), body payload'umuzu ekleyebilir ve isteği gönderebiliriz. Ancak bunu yapmadan önce, fonksiyonun başına bir breakpoint koyacağız ve null olarak alındıklarından emin olmak için yukarıdaki değişkenlerin her ikisini de watch'a ekleyeceğiz:

![[update_user_details_request.gif\|update_user_details_request.gif]]

Uygulama çökmedi ve sadece “Kullanıcı bilgileri başarıyla güncellendi!” dedi. Peki, veritabanındaki bu parametreleri bozduk mu, yoksa herhangi bir zarara neden olmadık mı? Tarayıcımız üzerinden tekrar giriş yapalım ve güncellenmiş kullanıcı bilgilerimizin neye benzediğini görmek için /settings'e gidelim:

![Pasted image 20241220104119.png](/img/user/resimler/Pasted%20image%2020241220104119.png)

Şaşırtıcı bir şekilde, name ve username parametreleri ne null ne de boştur ve isteğimizden hiç etkilenmemiş gibi görünmektedirler. Bunu Docker konteyneri içindeki veritabanında kullanıcı kaydımızı kontrol ederek daha da doğrulayabiliriz ve aynı değişmemiş değerleri elde ederiz:

![confirm_user_db_record.gif](/img/user/resimler/confirm_user_db_record.gif)

Kod bir veritabanı güncelleme çağrısı (findByIdAndUpdate) kullandığından, null bir değer gönderdiğimizde, “değişiklik yok” olarak kabul edileceğinden parametreyi güncellemeyecek gibi görünüyor. Bu büyük bir şans! Kod, örneğin (set) gibi farklı bir veritabanı çağrısı kullansaydı, değerleri null olarak ayarlayabilirdik ve veritabanında null değerler saklanırsa daha önce bahsettiğimiz sorunlara neden olabilirdik.

Saldırımız başarısız olsa da, kodda kesinlikle bir hata var ve yamanması gerekiyor, sadece biz bundan yararlanamadık. Bir sonraki sayıda daha şanslı olmayı umalım.


## Reset Password

Şimdi resetPassword endpoint'inde yer alan, tespit ettiğimiz ikinci soruna geçelim. Tüm parametrelerin isteğe bağlı olduğunu gördük, ancak hiçbiri kullanılmadan önce null güvenliği için düzgün bir şekilde doğrulanmıyor gibi görünüyor. Teker teker inceleyelim ve bu parametrelerin kullanımının çalışma zamanı hatalarına veya mantık hatalarına neden olup olmadığını kontrol edelim.

id ile başlayarak, daha önce belirlediğimiz gibi, veritabanı null bir id'ye dayalı olarak herhangi bir sonuç döndürmediğinde uygulama hata verecektir:

```js
if (!user) {
  throw new Error();
}
```

Bazı veritabanı türleri aynı işlem yapıldığında çökebilir veya tüm sonuçları döndürebilir, ancak MongoDB kullanımı göz önüne alındığında bu doğru bir şekilde ele alınır ve güvenli olarak kabul edebiliriz (yine de ! kullanımına karşı tavsiye ederken).

Token parametresine gelince, önceki bölümde tartıştığımız gibi, token gizli değerlere göre hesaplandığından, esas olarak kullanıcının şifresini sıfırlamasına izin vermek için bir doğrulama kontrolü olarak kullanılmaktadır. Ancak, hemen göze çarpan konu, token null kontrolünün burada nasıl kullanıldığıdır:

```js
if (token && token !== hashedToken) {
  return next({
    message: "Invalid password reset token.",
    statusCode: 403,
  });
}
```

Geliştiricilerin herhangi bir değişkeni kullanmadan önce null değer olup olmadığını kontrol etmeleri gerektiğini zaten belirtmiştik. Ancak, buradaki kod bunu düzgün bir şekilde yapmıyor. İlk olarak, değişkeni null VE undefined ile karşılaştırmak için katı eşitlik (yani `===`) kullanmıyor, sadece if (token) yapıyor ki bu daha önce gördüğümüz gibi sorunlu olabilir.

Yine de, buradaki ana sorun bu değildir. Ana mantık sorunu, kodun yalnızca token mevcutsa token'ı doğrulayacağı gerçeğinde yatmaktadır! Yani, herhangi bir token sağlamazsak, tüm bu token doğrulaması atlanacak ve kod şifreyi değiştirmeye devam edecektir!

Örneğin, token null ise, if (token) false olarak değerlendirilir ve böylece if ifadesindeki ikinci koşul asla test edilmez. Bu, birçok geliştiricinin yaptığı çok önemli bir hatadır; varsayılan olarak başarısız olmak yerine varsayılan olarak başarılı olmaktır. Kullanıcının erişimi olmadığı kanıtlanmadıkça yürütmeye devam etmek yerine, kullanıcı erişimi olduğunu kanıtlayana kadar herhangi bir hassas fonksiyona devam edilmemesi her zaman tavsiye edilir. Bu özel sorun daha çok erişim denetimi sorunlarıyla ilgilidir, ancak varsayılan başarı mantığı bir mantık hatasıdır ve burada belirtilmelidir.

Son parametre şifresi ile devam edilir:

```js
// geçerliyse, şifreyi güncelle
else {
  const salt = await bcrypt.genSalt();
  const newHashPassword = await bcrypt.hash(password, salt);

  try {
    // update user password
    const updateReq = await User.findOneAndUpdate(
      {
        _id: id,
      },
      {
        password: newHashPassword,
      }
    );
    <SNIP>
  }
}
```

İlk bakışta, bu en az sorunlu parametre gibi görünebilir, çünkü yalnızca tüm kontrolleri geçtikten sonra şifreyi değiştirmek için kullanılır, değil mi? Tam olarak değil. Bu parametrenin, veritabanında saklanacak yeni parola için bir hash oluşturmak üzere bcrypt fonksiyonuyla birlikte kullanıldığını görüyoruz. Ancak, bu bir try/catch bloğuna sarılmamıştır, bu da null değişkenlerle yapabileceğiniz en kötü şeydir, çünkü bu, bir null ile karşılaşırsa sadece bir hata döndürmek yerine tüm uygulamayı çökertebilir.

Bu kod satırına ulaşmanın tek yolu geçerli bir parola sıfırlama token'ına sahip olmak olsa bile, herhangi bir kullanıcı gerçek bir parola sıfırlama bağlantısı talep edebilir ve kullanıcısı için gerçek bir token elde edebilir. Ardından, passwordReset isteklerinden parola parametresini kaldırırlarsa, potansiyel olarak tüm kullanıcılar için tüm uygulamayı çökertebilirler.

Bir sonraki bölümde, bu null sorunlarından gerçekten yararlanıp yararlanamayacağımızı görmek için bu iddiaların her ikisini de test etmeye çalışacağız.


Soru :  'htb-student' kullanıcısının 1000 küpü var ve kullanıcı kimliği lokal test için kullandığımız uygulamada bulunanla aynı. Dolayısıyla, bir sonraki saldırımız için iyi bir hedef oluşturuyor. Yukarıda bahsettiğimiz şifre sıfırlama hatasından yararlanarak hesabını ele geçirmeye çalışın. Daha sonra “Akademiye Giriş” modülünün kilidini açabilir ve ilk bölümündeki bayrağı okuyabilirsiniz.

Cevap : 


# PoC and Patching - Null Safety

Elimizde üç farklı null sorunu olduğuna dair güçlü kanıtlar var ve bunlardan ikisi bizim tarafımızdan istismar edilebilir olmalı. Elbette, her zaman bu hatalardan yararlanmamızı engelleyen öngörülemeyen korumalar olabilir, bu nedenle bu bölümde, bir kavram kanıtı ile bunların kullanılabilirliğini doğrulamaya çalışacağız.


## Proof of Concept

Token parametresi ile tespit ettiğimiz ilk mantık hatası ile başlayalım. Bu hata, herhangi bir kullanıcının şifresini, gizli bir değer olarak kabul edilmesi gerekmeyen ve API çağrıları veya hatta profil URL'lerinde ortaya çıkabilecek olan kimliğini bilerek sıfırlamamızı sağlamalıdır.


## Account Takeover

649f2893cba8d0d6e8412182 id'sine sahip lokal kullanıcımızı hedef alalım. Bu saldırıyı gerçekleştirmek için tek yapmamız gereken /api/users/password/reset endpoint'ine bir POST isteği göndermek ve isteğimizin gövdesine token parametresini eklemeyi atlamak:

```json
{
  "id": "649f2893cba8d0d6e8412182",
  "password": "123456"
}
```

İstek gönderirsek, Şifre başarıyla güncellendi! Giriş yapmaya çalışırsak, başarılı bir şekilde girebiliriz, bu da ilk saldırımızın başarılı olduğu anlamına gelir:

![password_reset_poc.gif](/img/user/resimler/password_reset_poc.gif)


## Denial of Service

Mükemmel! İkinci saldırıya geçiyoruz ve bu kez yukarıdaki payload'tan şifre parametresini de kaldıracağız ve yukarıda yaptığımız gibi kontrolü atlamak için token parametresini eklememize gerek yok (veya maceracı hissediyorsanız gerçek token'ı hesaplayıp ekleyebilirsiniz). Şimdi, 
uygulamanın bunu nasıl ele aldığını görmek için isteği göndereceğiz:

![Pasted image 20241220105142.png](/img/user/resimler/Pasted%20image%2020241220105142.png)

Sunucudan hiçbir yanıt alamıyoruz. Bunun herhangi bir hataya neden olup olmadığını kontrol etmek için VSCode'daki Docker sekmesine gidebilir, çalışan konteynere sağ tıklayabilir ve View Logs'u seçebiliriz; uygulamanın tamamen çökmüş gibi göründüğünü göreceğiz. Gerçekten de, tarayıcıya geri dönüp yenilediğimizde, web uygulamasının artık çalışmadığını görürüz:


![password_reset_dos_poc.gif](/img/user/resimler/password_reset_dos_poc.gif)

Basit bir istekle sunucuyu tamamen devre dışı bıraktık ve artık manuel olarak yeniden başlatılana kadar hiçbir kullanıcı sunucuya erişemeyecek. Bu iki örnek de null güvenlik sorunlarının ne kadar ciddi olabileceğini ve bunları neden ciddiye almamız gerektiğini göstermektedir.

Not: Hizmet reddi saldırıları söz konusu olduğunda kavram kanıtımızı test ederken çok dikkatli olmalıyız, çünkü üretim hizmetlerini kesintiye uğratmaktan veya üretim verilerini kalıcı olarak değiştirmekten her zaman kaçınmalıyız.


## Patching

Bu kodda, birden fazla sorun tespit ettik ve hepsinden yararlanamasak da, yine de hepsi için yamalar uygulamamız gerekiyor.


#### updateUserDetails

İlk sorun updateUserDetails endpoint'indeydi ve temel neden UserSchema'daydı. Bazı endpointler şema doğrulamasına ihtiyaç duyduğundan ve tüm parametrelere ihtiyaç duymadığından (örneğin, login yalnızca e-posta/parola gerektirir), tüm parametreleri basitçe zorunlu tutamayız. Aynı zamanda, bu parametreleri tüm durumlar için isteğe bağlı olarak bırakamayız.

Bu nedenle, en iyi çözüm koşullu doğrulamayı kullanmak ve bu parametrelerin gerekli olmasını istediğimiz durumları belirtmek olacaktır. Örneğin, UserSchema'daki username parametresinin yalnızca createUser ve updateUserDetails endpoint'lerinde gerekli olmasını istiyorsak ve geri kalanında isteğe bağlı olarak kalmasını istiyorsak (orada kullanılmadığı için), o zaman aşağıdaki gibi değiştirebiliriz:

```js
export const UserSchema = yup
  .object({
    useUsername: yup.boolean().default(false),
    id: yup.string(),
    name: yup.string(),
    username: yup
      .string()
      .when("useUsername", ([useUsername], schema) =>
        !useUsername ? yup.string().required() : yup.string()
      ),
    email: yup.string().email().required(),
    password: yup.string().min(5).required(),
    registrationDate: yup.date(),
  })
  .required();
```

Gördüğümüz gibi, varsayılan değeri false olan yeni bir boolean parametresi useUsername ekledik ve bu parametre true olarak ayarlanırsa, kullanıcı parametresini .required() yapmak için when seçeneğini tetikleyecektir. Doğrulama için şemayı kullandığımızda ve kullanıcı adı parametresini zorunlu tutmamız gerektiğinde, bunu aşağıdaki şekilde yapabiliriz:

```js
await UserSchema.validate({
  useUsername: true,
  username,
  email,
  password,
});
```

useUsername true olarak ayarlandığından, bu, username parametresinin gerekli olduğu ve null bir değer geçirilirse hata döndüreceği anlamına gelir. İsteğe bağlı parametre kontrollerini bu şekilde yapmak, bunları endpoint'lere dağıtmaktan çok daha güvenli ve çok daha sürdürülebilirdir, bu da endpoint'lerin herhangi birinde sorunlara yol açabilir.

TypeScript ile aynı şema çözümünü kullanıyor olsaydık, tüm bunlar otomatik olarak algılanırdı. Bu durumda, useUsername: true ayarını yanlış kullanırsak, ancak kullanıcı adının null olduğu bir durum varsa, düzenleme sırasında bizi bilgilendirir ve kodun derlenmesini önler.

## resetPassword

resetPassword endpoint'ine gelince, düzeltmemiz gereken birden fazla sorunumuz vardı. İlk olarak, tüm parametrelerin gerekli olduğundan emin olmamız gerekir, çünkü bunlar yalnızca bir kez kullanılır (bu endpointte) ve hepsine ihtiyaç vardır, bu nedenle herhangi birini isteğe bağlı olarak tutmanın bir anlamı yoktur. Önceki bölümde gösterdiğimiz gibi, nesnenin tamamının gerekli olmasının tüm parametrelerinin de gerekli olduğu anlamına gelmediğini unutmayın. Dolayısıyla, passwordResetSchema şemasını aşağıdaki gibi düzeltebiliriz:

```js
const passwordResetSchema = object({
  // validate mongodb object id
  id: mixed((value) => ObjectId.isValid(value))
    .typeError("Invalid id")
    .required(),
  // validate bcrypt hash
  token: string()
    .matches(/[0-9a-f]{32}/i, "Invalid token")
    .required(),
  // validate password
  password: string().min(5).required(),
}).required();
```

Bu yapıldığında, kodun yürütülmesi sırasında token'ın null olmayacağını biliriz, bu nedenle hashedToken ile karşılaştırırken bunu test etmek zorunda kalmayız. Böylece, basitçe şunu yapabiliriz:

```js
if (token !== hashedToken) {
  return next({
    message: "Invalid password reset token.",
    statusCode: 403,
  });
}
```

Ayrıca, fonksiyon zaten katı eşitsizlik (`!==`) kullandığından, bu aynı zamanda bir string olan hashedToken türüne eşit olmayacağından null ve undefined olup olmadığını da kontrol edecektir. Fark ettiğimiz varsayılan başarı mantığı hatasını düzeltmemiz gerekiyor, token değişkeninin o noktada asla null olmayacağını bilsek bile, prensip olarak bunu düzeltmemiz gerekiyor. İdeal olarak, yalnızca tokenlar eşleşirse devam etmeli ve aksi takdirde başarısız olmalıyız. Bu şuna benzer bir şey olabilir:

```js
if (token === hashedToken) {
  try {
    const salt = await bcrypt.genSalt();
    const newHashPassword = await bcrypt.hash(password, salt);
    // update user password
    <SNIP>
  }
  <SNIP>
} else {
  return next({
    message: "Invalid password reset token.",
    statusCode: 403,
  });
}
```

Son olarak, önceki bölümde gördüğümüz gibi DoS'a neden olan yeni parola hash'ini hesaplayan satırlar gibi isteğe bağlı/nullable parametreler kullanan satırları her zaman bir try/catch bloğu ile sarmalıyız:

```js
else {
  try {
    const salt = await bcrypt.genSalt();
    const newHashPassword = await bcrypt.hash(password, salt);
    // update user password
    <SNIP>
  }
}
```

Elbette, güncellenmiş şema ile parola parametresinin asla null olmayacağını biliyoruz, ancak bu, bu durumda nasıl yapmamız gerektiğini göstermek için yapıldı. Bununla birlikte, web uygulamamızda bulunan tüm parametre mantığı hatalarını düzeltmiş olmalıyız. Yoksa düzelttik mi? Alıştırmaların test ettiklerine ek olarak başka hatalar bulup bulamayacağınızı görmeye çalışın.

Alıştırma: Yamaları üretime almadan önce lokal olarak test etmek çok önemlidir. Bu nedenle, yukarıdaki yamaları ilgili işlevlere/dosyalara uygulamayı deneyin, ardından doğru çalıştığından emin olmak için uygulamayı tekrar çalıştırın. Hem normal koşullar altında beklendiği gibi çalıştığından hem de artık yukarıdaki hatalara karşı savunmasız olmadığından emin olmak için yamaladığımız her fonksiyonu test etmelisiniz.


Soru : Yönetici hesabını ([email protected]) ele geçirmek için daha önce tartıştığımız null açığından yararlanmaya çalışın. Bunu yapmak için, önce özel kimliğini sızdıracak başka bir güvenlik açığını tespit edip kullanmanız ve ardından bunu şifresini sıfırlamak için kullanmanız gerekir. Yönetici kullanıcı sınırsız küpe sahiptir, bu nedenle “Akademiye Giriş” modülünün ilk bölümündeki bayrağı okumak için onun hesabını kullanın.

Cevap : 
