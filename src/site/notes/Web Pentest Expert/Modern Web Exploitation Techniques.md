---
{"dg-publish":true,"permalink":"/web-pentest-expert/modern-web-exploitation-techniques/"}
---


Bu modül üç gelişmiş web istismar tekniğini incelemektedir: DNS Rebinding, Second-Order vulnerabilities ve WebSocket saldırıları.


### DNS Rebinding

DNS Rebinding, Domain Name System'deki (DNS) değişikliklere dayanan gelişmiş bir saldırı tekniğidir; saldırganın yetersiz SSRF filtrelerinin yanı sıra SameOrigin ilkesini de atlamasına olanak tanır.


### Second-Order Attacks

Bazen second-order injection veya delayed vulnerability olarak da adlandırılan ikinci dereceden bir güvenlik açığı, bir kullanıcı tarafından sağlanan kötü niyetli girdinin, girdinin ilk noktasındaki bir zayıflıktan hemen yararlanmaması durumunda ortaya çıkar. Bunun yerine, bu girdi web uygulaması tarafından saklanır ve daha sonra uygulamanın kod tabanı içinde başka bir yerden alınana, işlenene veya kullanılana kadar gizli kalır. Bu sonraki etkileşim veya işleme sırasında güvenlik açığı ortaya çıkar ve potansiyel olarak güvenlik ihlallerine yol açar. Doğası gereği, ikinci dereceden güvenlik açıklarını tespit etmek çok daha zordur çünkü ilk “birinci dereceden” enjeksiyon noktası güvenlik açığına sahip olmayabilir ve bu da saldırganın web uygulamasının güvenlik açığına sahip olmadığı varsayımına yol açabilir.


### WebSocket Attacks

WebSockets, WebSocket client'ları ve sunucuları arasında çift yönlü iletişim sağlayarak geleneksel HTTP protokolüne kıyasla veri iletimi için alternatif bir yol sunar. Bir web sitesinin WebSocket'leri nasıl entegre ettiğine bağlı olarak Cross-Site Scripting ve SQL Injection gibi yaygın web güvenlik açıkları ortaya çıkabilir.

Bir sonraki bölümde ilk tekniği tartışarak başlayalım



### DNS Rebinding
DNS Rebinding, hatalı güvenlik önlemlerini atlatabilen gelişmiş bir saldırı tekniğidir. DNS Rebinding güvenlik açıklarından muzdarip web uygulamalarının nasıl tespit edileceğini ve ardından bunlardan nasıl yararlanılacağını öğrenmeden önce, DNS hakkındaki temel bilgileri hızlıca özetleyelim.


### Özet: Domain Name System (DNS)

Domain Name System (DNS), domain adlarını IP adreslerine çözümleyen hiyerarşik bir sistemdir (academy.hackthebox.com adresinin 104.18.21.126 (IPv4) veya 2606:4700::6812:157e (IPv6) olarak çözümlenmesi gibi); yapısı bir ağacı andırır. Bu ağacın aynı ad sunucusu tarafından yönetilen bölümlerine DNS zone'ları denir:

![Pasted image 20241207161904.png](/img/user/resimler/Pasted%20image%2020241207161904.png)

Domain adları sağdan sola doğru çözümlenir, yani top-level domain ile başlanır, second-level domain'e ve ardından mevcut tüm sub-domain'lere geçilir. DNS Rebinding saldırıları için, DNS zone sahiplerinin DNS zone'larını kendilerinin yönettiğini anlamak çok önemlidir. Yukarıdaki diyagramda, zone sahibi inlanefreight.com zone'unu ve tüm subdomain'lerini yönetmektedir. Bu nedenle, zone sahibi, yeni subdomainler için girişler eklemek, mevcut subdomainler için girişleri silmek ve bir domain adının çözümlendiği IP adresini yeniden yapılandırmak da dahil olmak üzere zone'larının DNS ayarlarını serbestçe yapılandırabilir. Örneğin, inlanefreight.com zone'unun sahibi www.inlanefreight.com domain'ini sabah 1.2.3.4'e çözümlenecek şekilde yapılandırabilir ve gece 5.6.7.8'e çözümlenecek şekilde yeniden yapılandırabilir; bunun bir kullanım alanı DNS aracılığıyla load balancing olabilir. Ayrıca, zone sahibi domainlerini, zone sahibi ile ilişkili olup olmadığına veya bu IP adresine karşılık gelen sistemin zone sahibinin DNS yapılandırmasını bilmemesine bakılmaksızın HERHANGİ bir IP adresine çözümlenecek şekilde yapılandırabilir.


[[Bağlantılar/Özet Chatgpt\|Özet Chatgpt]]

DNS'in bir diğer önemli parçası da caching'dir. Aynı hizmetle uzun bir süre boyunca etkileşimde bulunduğumuzu varsayalım; her servis isteğinden önce DNS istekleri gerçekleştirmek önemli ölçüde ek yüke neden olur. Örneğin, academy.hackthebox.com ile etkileşime girerken, öğrenciler buna birçok HTTP isteği gönderir; DNS caching olmadan, her HTTP isteğinden önce domain adının DNS ile aranması gerekir. Bu nedenle, yeni bir DNS araması gerekmeden önce DNS yanıtları belirli bir süre için önbelleğe alınır. Bu süreye time-tolive ( TTL ) adı verilir ve domain adının bir DNS isteği ile tekrar çözümlenmesi gerekmeden önce çözümlenen IP adresinin kaç saniye geçerli olacağını belirler.

Burada, komut satırı aracı dig kullanılarak academy.hackthebox.com domainine ait örnek bir arama bulunmaktadır:

![Pasted image 20241207162638.png](/img/user/resimler/Pasted%20image%2020241207162638.png)

TTL, çözümlenen domain adından sonra ANSWER SECTION'da belirtilir. Bu durumda, TTL 300 saniyedir (5 dakikaya eşdeğerdir).

İlerleyen bölümlerde öğreneceğimiz gibi, saldırganlar çeşitli saldırılar gerçekleştirirken, hatalı filtreleri veya diğer güvenlik önlemlerini atlatmak amacıyla bir DNS sunucusunu farklı bir IP adresine işaret edecek şekilde yeniden yapılandırmak için saldırgan DNS Rebinding tekniğini (düşük bir TTL ile birlikte) kötüye kullanırlar. Bir DNS Rebinding saldırısında, saldırgan kendi domain'inde düşük bir TTL yapılandırır ve sonraki istekler arasında domain'in çözümlendiği IP adresini değiştirir. Bu konuyu ilerleyen bölümlerde daha ayrıntılı olarak inceleyeceğiz.


### SSRF Basic Filter Bypasses

Server-Side Request Forgery (SSRF) güvenlik açıkları, bir saldırganın sunucuyu HTTP isteklerini kullanarak remote kaynakları getirmeye zorlayabildiği durumlarda ortaya çıkar; bu, bir saldırganın web sunucusunun local ağında çalışan ve dışarıdan bir saldırganın erişimi engelleyen bir güvenlik duvarı nedeniyle genellikle erişemeyeceği services'i tanımlamasına ve listelemesine olanak sağlayabilir. SSRF hakkında daha fazla ayrıntı için Server-side Attacks modülüne göz atın.


### SSRF'nin Onaylanması
Bir geliştiricinin SSRF güvenlik açıklarını nasıl ele alabileceğini göstermek için aşağıdaki savunmasız web uygulamasını ele alalım. Bu sadece SSRF güvenlik açıklarının hızlı bir özeti olduğundan, Whitebox sızma testinin adımlarını ayrıntılı olarak gözden geçirmeyeceğiz.


### Kod İncelemesi - Güvenlik Açığının Belirlenmesi

Örnek web uygulamamız, URL'lerini verdiğimiz web sitelerinin ekran görüntülerini almamızı sağlar:

![Pasted image 20241207163036.png](/img/user/resimler/Pasted%20image%2020241207163036.png)

Bunun nasıl uygulandığını belirlemek için kaynak koduna bakalım. Web uygulaması iki endpoint içerir. Birincisi ekran görüntüsü almayı yönetirken, ikinci endpoint bir hata ayıklama sayfası ile yanıt verir ve yalnızca localhost'tan erişilebilir:

![Pasted image 20241207163118.png](/img/user/resimler/Pasted%20image%2020241207163118.png)

Hedefimiz debug sayfasına yetkisiz erişim elde etmek olduğundan, /debug endpoint'teki kontrolü atlamamız gerekir. Ancak, request.remote_addr değişkenini manipüle edemeyiz çünkü bu, isteğin kaynaklandığı IP adresidir (yani, dış IP adresimiz). Bu nedenle hata ayıklama endpoint'ine doğrudan erişemiyoruz.

Web uygulamasının screenshot_url fonksiyonunda ekran görüntüsü almayı nasıl uyguladığına bir göz atalım:

![Pasted image 20241207163239.png](/img/user/resimler/Pasted%20image%2020241207163239.png)
![Pasted image 20241207163244.png](/img/user/resimler/Pasted%20image%2020241207163244.png)

Web uygulaması, local dosyaları okumak için dosya şemasını sağlayamayacağımız şekilde URL'nin şeması da dahil olmak üzere birkaç temel kontrol gerçekleştirir. Daha sonra, sağlanan URL[ headless Chrome'da](https://developer.chrome.com/blog/headless-chrome/) açılır ve web sitesinin bir ekran görüntüsü alınır ve bize gösterilir.


### Exploitation

Web uygulaması bizi yalnızca http ve https şemalarıyla kısıtladığı, ancak sağlayabileceğimiz domain veya IP adresini kısıtlamadığı için, web uygulamasının kendisinde /debug endpoint'ine işaret eden bir URL sağlayabiliriz. Web uygulaması daha sonra kendi debug endpoint'ini ziyaret edecek ve böylece istek 127.0.0.1 adresinden kaynaklanacaktır. Bu nedenle, erişim izni verilir ve alınan ekran görüntüsü debug sayfasını içerir:

![Pasted image 20241207163748.png](/img/user/resimler/Pasted%20image%2020241207163748.png)


### SSRF Basic Filter Bypasses

DNS rebinding ile bunu yapmadan önce basit yöntemler kullanarak atlayabileceğimiz birkaç kusurlu SSRF filtresini tartışacağız


### Localhost'un gizlenmesi

İlk ve en basit SSRF filtresi, localhost veya 127.0.0.1 gibi belirli domainleri açıkça engelleyen bir filtredir. Şimdi böyle bir filtrenin uygulamasına bir göz atalım. screenshot_url fonksiyonunun check_domain fonksiyonu ile aşağıdaki gibi “geliştirildiğini” varsayalım:

![Pasted image 20241207163910.png](/img/user/resimler/Pasted%20image%2020241207163910.png)
![Pasted image 20241207163916.png](/img/user/resimler/Pasted%20image%2020241207163916.png)

check_domain localhost ve 127.0.0.1 kelimelerini içeren tüm domainleri engeller. Ancak, lokal makineye işaret eden bir IP adresini temsil etmenin başka birçok yolu vardır. İşte birkaç örnek:


![Pasted image 20241207164006.png](/img/user/resimler/Pasted%20image%2020241207164006.png)


Bunlardan herhangi biri filtreyi başarıyla atlatmamızı sağlar:

![Pasted image 20241207164029.png](/img/user/resimler/Pasted%20image%2020241207164029.png)


### DNS Resolution ile Bypass

İkinci bir örnek olarak, aşağıdaki geliştirilmiş check_domain fonksiyonuna bir göz atalım:

![Pasted image 20241207164321.png](/img/user/resimler/Pasted%20image%2020241207164321.png)

Bu kez, filtre sağladığımız herhangi bir IP adresini ayrıştırır ve herhangi bir özel adres aralığındaysa engeller. Ancak, ilettiğimiz herhangi bir domain adı kara listeye alınmış localhost kelimesini içermiyorsa sorun olmaz, bu da iç IP adresine çözümlenen herhangi bir domaini iletmemizi sağlar.

Bir domain kaydedebilir ve herhangi bir iç IP adresine yönlendirebiliriz; ancak, 127.0.0.1 adresine çözümlenen localtest.me gibi zaten var olan bazı domainleri kötüye kullanabiliriz:

![Pasted image 20241207164450.png](/img/user/resimler/Pasted%20image%2020241207164450.png)
![Pasted image 20241207164457.png](/img/user/resimler/Pasted%20image%2020241207164457.png)

Bu domain'i geçmek filtreyi atlamamızı sağlar:

![Pasted image 20241207164529.png](/img/user/resimler/Pasted%20image%2020241207164529.png)


### HTTP Redirect ile Bypass

Web uygulaması, kullanıcı tarafından sağlanan domain adlarını çözümleyebilir ve DNS çözümlemesi yoluyla bypass'ı düzeltmek için özel IP'ler olup olmadıklarını kontrol edebilir. Aşağıdaki geliştirilmiş check_domain fonksiyonuna bakalım:

![Pasted image 20241207164632.png](/img/user/resimler/Pasted%20image%2020241207164632.png)

Domain adını çözümlemenin yanı sıra, geliştirilmiş filtre varsayılan olarak False döndürür ve yalnızca herhangi bir istisna oluşmadığında True döndürür. Ancak filtre, headless Chrome tarayıcısının takip edeceği HTTP yönlendirmelerini hesaba katmaz. Bu nedenle, kontrolümüz altındaki bir web sunucusuna işaret eden bir URL sağlayarak ve web uygulamasını local debug endpoint'e yönlendirerek filtreyi atlatabiliriz. Bunu yapmak için aşağıdaki PHP kodunu web sunucumuzda barındırabiliriz:

![Pasted image 20241207164734.png](/img/user/resimler/Pasted%20image%2020241207164734.png)

Dosyayı built-in PHP web sunucusunu kullanarak barındırabiliriz:

![Pasted image 20241207164759.png](/img/user/resimler/Pasted%20image%2020241207164759.png)

Daha sonra web sunucumuzda barındırılan PHP koduna işaret eden bir URL sağlayarak filtreyi atlayabiliriz:

![Pasted image 20241207164829.png](/img/user/resimler/Pasted%20image%2020241207164829.png)

Bunu önlemek basit bir iş değildir. Debug endpoint'te, yönlendirilmiş bir isteği doğrudan bir istekten ayırt etmek imkansızdır. İyi huylu web uygulamaları da yönlendirmeleri kullandığından, yönlendirmeleri tamamen engellemek kullanıcı deneyimini etkileyebilir. Ayrıca, JavaScript ve meta etiketleri kullanmak gibi bir yönlendirmeyi zorlamanın başka yolları da olduğundan, tüm HTTP yönlendirmelerini engellemek yetersizdir. Bu durumların ayrı ayrı ele alınması gerekir; örneğin, headless Chrome tarayıcısında JavaScript'i devre dışı bırakarak, önce HTML yanıtını indirerek ve indirilen HTML dosyasını headless Chrome tarayıcısında oluşturmadan önce yönlendirmelere neden olan meta etiketleri kaldırarak

Bu durum, güvenlik kontrollerini neden asla kendi başımıza uygulamamamız gerektiğini iyi bir şekilde göstermektedir. Artan karmaşıklık ve birçok uç durum nedeniyle, SSRF güvenlik açıklarını tamamen ortadan kaldırmak zordur. Her türlü yönlendirmeyi engellemeyi başarsak bile, bir sonraki bölümde tartışacağımız gibi, DNS Rebinding kullanılarak filtre yine de atlatılabilir.

SSRF güvenlik açığını önlemenin en basit ve en güvenli yolu güvenlik duvarı kurallarıdır. Webshot'ı (örnek web uygulaması) çalıştıran sistem, debug endpoint'i barındıran iç web uygulamasından ayrılmalıdır. Ardından, SSRF güvenlik açıklarını önlemek için Webshot sisteminden dahili web uygulamasına gelen bağlantıları önlemek için güvenlik duvarı kuralları uygulayabiliriz.


### DNS Rebinding: SSRF Filter Bypass

Localhost gizleme, DNS çözümleme ve HTTP yönlendirmeleri gibi tekniklerle bunları nasıl atlayacağımızı keşfettikten sonra, DNS rebinding kullanarak kusurlu SSRF filtrelerini atlayalım.


### Kod İncelemesi - Güvenlik Açığının Belirlenmesi
Bu bölümde, URL proxy olarak görev yapan bir web uygulaması olan D-Proxy'yi analiz edeceğiz; herhangi bir URL belirtmemize izin verir ve ardından bizim için onu getirir ve işler

![Pasted image 20241207170353.png](/img/user/resimler/Pasted%20image%2020241207170353.png)

D-Proxy'nin kaynak kodunu açık bir yedekleme dosyası aracılığıyla elde ettiğimizi varsayalım; analiz ederken ve güvenlik açıklarını ararken, son bölümde tartışılan her şeyi aklımızda tutacağız. D-Proxy'nin iki endpoint'i vardır, bunlardan birine sadece local olarak erişilebilir, /flag :

![Pasted image 20241207170434.png](/img/user/resimler/Pasted%20image%2020241207170434.png)
![Pasted image 20241207170441.png](/img/user/resimler/Pasted%20image%2020241207170441.png)

POST isteği altında index isimli fonksiyon ile web uygulaması verdiğimiz domain'i çözümlüyor ve tüm iç IP adreslerini engelliyor.

Ancak, web uygulaması **index()** fonksiyonunda domain adını iki kez çözümler:

- Bir kez[ **socket.gethostbyname**](https://docs.python.org/3/library/socket.html#socket.gethostbyname) fonksiyonu ile,
- Diğer kez ise **[requests](https://requests.readthedocs.io/en/latest/user/quickstart/)** kütüphanesindeki **requests.get** fonksiyonu ile (eğer **global_check** True ise).

Bu durum, filtreyi **DNS Rebinding** saldırısına karşı savunmasız hale getiriyor ve şu yöntemle bunu aşmamızı mümkün kılıyor:

Web uygulamasına, DNS yapılandırmasını değiştirebileceğimiz kontrolümüzde olan bir domain sağlamamız gerekiyor. Bu bölüm için, **attacker.htb** domainine sahip olduğumuzu ve DNS yapılandırmasını değiştirebildiğimizi varsayalım. DNS sunucusunu, **attacker.htb**'yi kara listede olmayan herhangi bir IP adresine (örneğin, **1.1.1.1**) çözümleyecek şekilde yapılandıracağız ve bu domain için çok düşük bir **TTL (Time-To-Live)** değeri atayacağız.

Web uygulamasına **[http://attacker.htb/flag](http://attacker.htb/flag)** URL'sini sağladığımızda, domain adı **1.1.1.1**'e çözümlenir ve bunun dahili bir IP adresi olmadığını doğrular.  
Çünkü **global_check**'e atanan fonksiyon **True** değerine ulaşır ve **global_check** **True** olur.  
**if** ifadesindeki her iki koşul da **True** olarak değerlendirilir, bu nedenle **render_template** fonksiyonuna erişim sağlanır.

Ardından, **attacker.htb** domaini için DNS yapılandırmasını yeniden bağlayarak (rebind), **1.1.1.1** yerine **127.0.0.1**'e çözülmesini sağlarız.  
**flag** fonksiyonunda bayrağı almaya çalışırken ve **attacker.htb** için atanmış düşük TTL nedeniyle, web uygulaması **attacker.htb**'yi tekrar çözümler.

Son olarak, **DNS Rebinding** nedeniyle ikinci DNS çözümlemesi, **attacker.htb** domain adını **127.0.0.1**'e çözer. Bu durumda web uygulaması, **[http://127.0.0.1/flag](http://127.0.0.1/flag)** URL'sine erişir ve bayrağı bizim için alır.


Böyle bir saldırının zamanlamasının son derece hassas olması gerekir çünkü DNS yeniden bağlamanın web uygulaması tarafından yapılan iki DNS çözümlemesi arasında gerçekleşmesi gerekir. Bunun nasıl başarılacağını Exploitation bölümünde tartışacağız.


### Uygulamada Lokal Olarak Debugging  

Debug etmek için D-Proxy'yi local olarak çalıştırdıktan sonra, tespit ettiğimiz DNS rebinding açığından faydalanmak için bir kavram kanıtı geliştireceğiz

İlk olarak, ourdomain.htb domainini /etc/hosts dosyasına ekleyeceğiz ve 1.1.1.1 olarak çözümlenmesini sağlayacağız:

![Pasted image 20241207171322.png](/img/user/resimler/Pasted%20image%2020241207171322.png)

Domainin socket.getbyhostname tarafından ilk çözümlenmesinden sonra, requests.get ikinci bir çözümleme gerçekleştirmeden önce bir kesme noktası belirleyeceğiz.

Şu anda hata ayıklamakta olduğumuz D-Proxy'ye http://ourdomain.htb:8000/flag URL'sini sağlarsak kesme noktası tetiklenecektir. Daha da önemlisi, bu durum SSRF filtresi domain'i çözümledikten sonra (yani ipaddress.ip_address(info).is_global) uygulamanın durumunda meydana gelir. DNS yeniden bağlama saldırısını simüle etmek için ourdomain.htb DNS girişini 1.1.1.1 yerine /etc/hosts dosyasında 127.0.0.1 olarak yeniden bağlayacağız:

![Pasted image 20241207171412.png](/img/user/resimler/Pasted%20image%2020241207171412.png)

D-Proxy'yi çalıştırmaya devam edersek requests.get, ourdomain.htb domain adını tekrar çözümleyecektir. Ancak bu kez, DNS yeniden bağlama nedeniyle 1.1.1.1 yerine 127.0.0.1'e çözümlenecek ve korumalı /flag endpoint'e erişmemize izin verecektir:

![Pasted image 20241207171443.png](/img/user/resimler/Pasted%20image%2020241207171443.png)


----



### Introduction to Second-Order Attacks

İkinci dereceden güvenlik açıklarının nasıl tespit edileceğini ve kullanılacağını tartışmadan önce, birinci dereceden güvenlik açıkları ile aralarındaki kritik farkları, ikinci dereceden güvenlik açıklarını tespit etmek için nelere dikkat etmemiz gerektiğini anlayalım ve ardından ilerleyen bölümlerde odaklanacağımız temel web güvenlik açıklarını hızlıca özetleyelim.


### What is a Second-Order Vulnerability?

Kullanıcı tarafından sağlanan kötü niyetli girdi ilk enjeksiyon noktasında değil de daha sonra web uygulaması tarafından depolandığında veya işlendiğinde bir güvenlik açığını tetikliyorsa, bu ikinci dereceden bir güvenlik açığı olarak bilinir.

Bazı web güvenlik açıkları doğası gereği ikinci derecedendir. Örneğin, bir kullanıcının başka bir kullanıcıya XSS payload'u içeren bir mesaj gönderebildiği bir sosyal medya ağında stored bir XSS düşünün. Diğer kullanıcı mesajı açtığında, XSS payload'u tetiklenir. Bu nedenle, enjeksiyon noktası (yani mesajın gönderilmesi) tetikleyiciden (yani mesajın açılması) farklıdır. Başka bir deyişle, kullanıcı tarafından sağlanan payload güvenli olmayan bir şekilde farklı bir endpoint'te depolanır ve görüntülenir, bu da bir XSS zafiyetine neden olur. Bu nedenle, depolanan XSS ikinci dereceden bir güvenlik açığı olarak düşünülebilir.

Daha spesifik olarak, bu dolayımı gerektiren herhangi bir web güvenlik açığı ikinci dereceden bir güvenlik açığı olarak kabul edilebilir. Bu güvenlik açıklarını tespit etmek çok daha zordur, çünkü doğrudan enjeksiyon noktası güvenli görünebilir ve güvenlik açığını tetiklemek için farklı bir endpoint'e ulaşılması gerekir. Bu nedenle, ikinci dereceden güvenlik açıklarını tespit etmek ve kullanmak için belirli bir web uygulamasının altında yatan iç işleyişi iyi anlamak çok önemlidir.


### Özet: Insecure Direct Object References (IDOR)

Insecure Direct Object References ( IDOR ) güvenlik açıkları, kullanıcıların ek yetkilendirme kontrolleri olmadan kontrol edebilecekleri bir nesneye doğrudan referans verilmesinden kaynaklanan yaygın web güvenlik açıklarıdır. Bu, referans verilen nesneye yetkisiz erişime yol açabilir. Bu nedenle, IDOR'lar erişim kontrolü güvenlik açıklarıdır. 

Genel olarak, IDOR'ların tanımlanması ve onaylanması süreci, doğrudan nesne referansının tanımlanması, nesne referansının değiştirilmesi ve web sunucusunun değiştirilen nesne referansına verdiği yanıtın incelenerek yetkisiz erişimin gerçekleştiğinin onaylanmasından oluşur.



### Özet: Local File Inclusion (LFI)

Local File Inclusion ( LFI ) güvenlik açıkları, bir web uygulaması kullanıcı girdisine dayalı olarak dinamik bir şekilde dosya eklediğinde ortaya çıkar. Kullanıcı girdisi düzgün bir şekilde sterilize edilmezse, bir saldırgan amaçlanan dizinin dışına çıkabilir ve web sunucusunun local dosya sistemindeki rastgele dosyaları okuyabilir.


### Özet: Command Injection

Komut Enjeksiyonu, kullanıcı tarafından sağlanan verileri uygun sanitizasyon olmadan sistem komutlarına dahil eden web uygulamalarında ortaya çıkabilir. Birçok web geliştiricisi komut enjeksiyonunun tehlikelerini bildiğinden, istismar genellikle uygulanan filtrelerin atlanmasını gerektirir.


### Second-Order IDOR (Whitebox)

İkinci dereceden güvenlik açıkları hakkında bazı arka plan bilgilerini ele aldığımıza göre, beyaz kutu yaklaşımını kullanarak bunları bir web uygulaması içinde tanımlama, kullanma ve hafifletme yöntemlerini keşfedeceğiz.


### Kod İncelemesi - Güvenlik Açığının Belirlenmesi

Web uygulamasının kaynak kodunu analiz etmeden önce, bizi hangi fonksiyonların beklediğini görmek için uygulamayı kurcalayalım. Uygulama bir dosya depolama uygulaması gibi görünüyor. Test kullanıcımız htb-stdnt ile giriş yaptıktan sonra, bu kullanıcı için depolanan dosyaları görebiliriz:

![Pasted image 20241213232823.png](/img/user/resimler/Pasted%20image%2020241213232823.png)

İlk saklanan dosyaya tıklandığında /get_data.php?id=2 adresine bir istek gönderilir ve bu da bizi dosyayı görüntüleyen bir sayfaya yönlendirir:

![Pasted image 20241213232847.png](/img/user/resimler/Pasted%20image%2020241213232847.png)

id parametresi bariz bir IDOR enjeksiyon noktası olduğundan, diğer kullanıcıların dosyalarına erişip erişemeyeceğimizi görmek için parametreyi değiştirmeyi deneyelim. Tarayıcımızda /get_data.php? id=1 bağlantısına erişirsek, oturumumuz kapatılır ve bir hata mesajı görüntülenir:

![Pasted image 20241213232918.png](/img/user/resimler/Pasted%20image%2020241213232918.png)

Dolayısıyla, web uygulaması klasik birinci dereceden IDOR güvenlik açığına karşı savunmasız değildir. İkinci dereceden bir IDOR açığı tespit edip edemeyeceğimizi görmek için kaynak kodunu analiz etmeye devam edelim.

Bir dosya talep ederken, backend erişimimizi kontrol eder ve get_data.php'de görebileceğimiz gibi, talep edilen dosyaya erişimimiz olup olmadığına bağlı olarak bizi display_data.php veya error.php'ye yönlendirir:

![Pasted image 20241213233319.png](/img/user/resimler/Pasted%20image%2020241213233319.png)

[[Bağlantılar/php1\|php1]]


Kontrol başarılı olursa, dosya alınır ve display_data.php içinde görüntülenir:

![Pasted image 20241213233939.png](/img/user/resimler/Pasted%20image%2020241213233939.png)

[[Bağlantılar/php2\|php2]]

Aksi takdirde, oturumumuz kapatılır ve index.php adresine yönlendiriliriz:


![Pasted image 20241213234149.png](/img/user/resimler/Pasted%20image%2020241213234149.png)

[[Bağlantılar/php3\|php3]]

Gördüğümüz gibi, session değişken id'si get_data.php'ye GET isteğinde sağladığımız dosya ID'sine ayarlanır. Erişim kontrolü başarılı olursa, dosya oturum değişkeni kimliğine göre alınır. Ancak, erişim kontrolü başarısız olursa, oturum değişkeni yalnızca session_unset fonksiyonuna yapılan çağrı aracılığıyla error.php'ye yönlendirildikten sonra temizlenir. Böylece, session değişkeni kimliği, error.php endpoint'ine erişene kadar get_data.php endpoint'ine sağladığımız dosya kimliğine ayarlı kalır. Bu, error.php'ye yönlendirmeyi takip etmeyerek ve bunun yerine get_data.php endpoint'i aracılığıyla herhangi bir dosya kimliğini ayarladıktan sonra doğrudan display_data.php'ye erişerek istediğimiz dosya kimliğine erişmemizi sağlar



### Uygulamayı Lokal Olarak Çalıştırma
![Pasted image 20241214005443.png](/img/user/resimler/Pasted%20image%2020241214005443.png)
![Pasted image 20241214005450.png](/img/user/resimler/Pasted%20image%2020241214005450.png)

Daha sonra verilen db.sql dosyasından veritabanını başlatan bir MySQL docker konteynerini başlatabiliriz:

![Pasted image 20241214005618.png](/img/user/resimler/Pasted%20image%2020241214005618.png)

Daha sonra, uygulamayı çalıştırmak için PHP'nin built-inweb sunucusunu kullanabiliriz:

![Pasted image 20241214005744.png](/img/user/resimler/Pasted%20image%2020241214005744.png)


### Exploitation

İkinci dereceden IDOR güvenlik açığından yararlanmak için, web uygulamasını session değişken id'sini farklı bir kullanıcının dosyasına ayarlamaya zorlamamız gerekir, böylece onu görüntüleyebiliriz. Bunu get_data.php endpoint'ine rastgele bir ID sağlayarak yapabiliriz:

![Pasted image 20241214005946.png](/img/user/resimler/Pasted%20image%2020241214005946.png)
error.php'ye yönlendirmeyi takip etmediğimiz sürece, oturum değişkeni kimliği ayarlı kalır. Böylece, admin kullanıcının gizli elmalı turta tarifi olan dosyayı görüntülemek için artık web tarayıcımızda /display_data.php adresine gidebiliriz:


![Pasted image 20241214010018.png](/img/user/resimler/Pasted%20image%2020241214010018.png)

Bu kavram kanıtı, web uygulamasındaki mevcut tüm dosyalara sızan küçük bir komut dosyası yazmamızı sağlar.


### Patching

Güvenlik açığını yamamak için, dosyaya erişilmeden önce erişimin kontrol edildiğinden emin olmamız gerekir. Bu web uygulamasında, oturum değişkeni id'si ayarlanır ayarlanmaz dosyaya erişilebilir. Bu nedenle, bu oturum değişkeninin yalnızca erişim kontrol edildikten sonra ayarlandığından emin olmalıyız. Böylece, get_data.php'deki kodu değiştirerek güvenlik açığını düzeltebiliriz:

![Pasted image 20241214010134.png](/img/user/resimler/Pasted%20image%2020241214010134.png)
