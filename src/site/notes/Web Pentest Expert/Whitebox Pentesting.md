---
{"dg-publish":true,"permalink":"/web-pentest-expert/whitebox-pentesting/"}
---


Whitebox pentesting sürecimiz aşağıdaki gibi 4 ana adımdan oluşmaktadır:

![Pasted image 20241130040813.png](/img/user/resimler/Pasted%20image%2020241130040813.png)

![Pasted image 20241130040830.png](/img/user/resimler/Pasted%20image%2020241130040830.png)

### Kod İncelemesi
Kod İnceleme adımı temel olarak potansiyel güvenlik açıklarını belirlemek için kodun okunarak statik analizinden oluşur. Bununla birlikte, bunu belirli güvenlik açıkları için uygulama kullanımı yoluyla dinamik analizle birleştirmek de mümkündür.

Kod incelemesi bu süreçte en uzun süreyi alabilir, bu nedenle ilginç işlevleri hızlı bir şekilde tanımlamayı, kısa listeye almayı ve önceliklendirmeyi öğrenmek çok önemlidir. Bu adım aynı zamanda programlama dilleri ve uygulama tasarımı hakkında bilgi sahibi olmayı da gerektirir; bunlar olmadan uygulamanın nasıl çalıştığını anlayamayız.


### Local Testing
Kusurlu olabilecek öncelikli işlevlerin bir listesini yaptıktan sonra, öncelikli/kısa listeye alınmış işlevleri test ederek ve sahip olduğumuz araçları ve erişimi kullanarak bunları lokal olarak test ederek dinamik analizimize başlamamız gerekir. Bu adımda, bir işlevin savunmasız ve istismar edilebilir olup olmadığını belirleyebileceğiz.

Uygulamanın üretim ortamıyla yakından eşleşen bir test ortamı kurulumuna ihtiyacımız olacaktır. Bir test ortamı, taleplerimizin nasıl ele alındığına ve uygulamanın bunları nasıl işlediğine dair daha fazla görünürlük sağlar, bu da bulunması zor bazı güvenlik açıklarını tespit etmemizi sağlayabilir.


### Proof of Concept (PoC)
Bir güvenlik açığı (veya katları) local testlerle doğrulandıktan sonra, güvenlik açığını otomatik olarak kullanan ve varlığını kanıtlayan bir exploit yazarak bir Kavram Kanıtı (PoC) oluşturmamız gerekir. Bunu yapmak, bir test ortamında test ettikten sonra istismarı üretim hedefinde kolayca çoğaltmamızı sağlar.

PoC'yi Python, Bash ve JavaScript gibi komut dosyası dillerinde yazmamız gerekebileceğinden, bu adım aynı zamanda komut dosyası bilgisi de gerektirir. Belirli anahtarları veya diğer kodlanması zor işlevleri oluşturmak için uygulamanın kodunu yeniden kullanabiliriz. Gerçek üretim hedefi üzerinde yapılan tüm testler, herhangi bir kesinti veya veri kaybına neden olmayacak şekilde güvenli bir şekilde yapılmalıdır.

### Yama ve İyileştirme
Herhangi bir whitebox pentesting çalışmasının amacı güvenlik açıklarını tespit etmek ve yamamak olduğundan, tespit edilen güvenlik açıkları için çözümler önermeden tamamlanmış sayılmaz. Bu adımda, geliştiricilerin bunları kolayca uygulayabilmesi ve test edebilmesi için kaynak kodda belirli değişikliklerle birlikte kesin yamaların ayrıntılı açıklamalarını sunacağız.


### Code Review - Authentication

Bu bölümün sonunda bulunan arşivi indirerek, içeriğini çıkararak ve ardından Dosya>VSCode'da Klasör Aç veya aşağıdaki komutu kullanarak VSCode'da açarak başlayabiliriz:

```shell-session
[!bash!]$ code ./intro_to_whitebox_pentesting
```

Gördüğümüz gibi, kod tabanı hiyerarşisi oldukça basit, bir giriş dosyası (app.js) ve birkaç başka dizinden oluşuyor. Şimdi, nasıl çalıştığını daha iyi anlamak için koda bakalım.

![Pasted image 20241209204421.png](/img/user/resimler/Pasted%20image%2020241209204421.png)

Bu görsel, bir Node.js projesinin klasör yapısını ve dosya [[Bağlantılar/organizasyonunu\|organizasyonunu]] göstermektedir.
## app.js
app.js dosyası bir express sunucusu kurarak, bir JSON body parseri ayarlayarak ve ardından ana API rotalarını ayarlayarak başlar:

```js
// ekspres kurun
const app = express();
const port = parseInt("5000");

// body parser ve cors'u kurun
app.use(bodyParser.json());

// API rotalarını ayarlama
app.use("/api/auth", authRoutes);
app.use("/api/service", serviceRoutes);
```

[[Bağlantılar/Kodun Detayı\|Kodun Detayı]]

Bu, bir node.js API backend için temel bir express sunucu kurulumudur. Dosyanın geri kalanı 404 rota işleme ve istisna işleme ayarlarını yapar ve express sunucusunu başlatarak sona erer:


![Pasted image 20241209213343.png](/img/user/resimler/Pasted%20image%2020241209213343.png)

[[Kodun Detayı 2 \|Kodun Detayı 2 ]]

Bu dosyadaki tek ilginç kısım API rotalarıdır, çünkü geri kalanı temel ekspres ayarlarıdır. Şimdi bu rotalara bir göz atalım.


### Authentication

VSCode'da CMD/CTRL tuşlarını basılı tutarak authRoutes seçeneğine tıklayabiliriz, bu bizi bu rotaları içeren dosyaya götürecektir. routes/auth-routes.js dosyası basitçe getUserToken ile tek bir API endpoint'inden oluşur:

`const router = express.Router();` 
`router.post("/authenticate", getUserToken);` 
`module.exports = router;`

Bu kod parçası, Express.js kullanılarak bir **rota (route)** oluşturmak için kullanılan temel bir yapıdır. Bu yapı, bir HTTP POST isteğini belirli bir URL'ye yönlendirir ve belirli bir işlemi tetikler.

`const router = express.Router();` 

- **Ne işe yarar?**  
    `express.Router`, Express.js içinde bir **router (yönlendirici)** nesnesi oluşturur. Bu nesne, bir grup ilgili rota tanımlamanıza olanak tanır.
    - Örneğin: Tüm "kullanıcı kimlik doğrulama (authentication)" ile ilgili yollar (routes) bu router içinde gruplanabilir.
- **Neden kullanılır?**  
    Büyük projelerde kodun modülerliğini ve düzenini artırmak için rotaları gruplamak önemlidir.
- **Sonuç:**  
    `router` değişkeni, bir yönlendirici nesnesi olarak işlev görür.


`router.post("/authenticate", getUserToken);` 

- **Ne işe yarar?** Bu komut, bir **POST** isteğini dinlemek ve bu isteği karşılayacak bir işlem (callback işlevi) tanımlamak için kullanılır.
- **Açıklama:**
    - **`router.post`**: Bu, POST türündeki HTTP isteklerini karşılamak için bir rota oluşturur.
        - POST, genellikle sunucuya veri göndermek için kullanılır. Örneğin: Kullanıcı adı ve şifre gönderimi.
    - **`"/authenticate"`**: Bu, POST isteğinin hedef URL'sidir. Kullanıcı tarayıcıda veya bir istemci uygulamada `http://localhost:3000/authenticate` gibi bir adrese POST isteği gönderdiğinde bu kod çalışır.
    - **`getUserToken`**: Bu, isteği işlemek için çağrılacak bir fonksiyondur. Örneğin, kullanıcı kimlik doğrulama işlemleri için:
        - Kullanıcının gönderdiği bilgileri kontrol eder.
        - Giriş başarılıysa, bir token (belirteç) veya başarı mesajı döndürür.
        - Hatalıysa, hata mesajı döndürür


`module.exports = router;`

- **Ne işe yarar?** Bu, JavaScript'in Node.js modül sistemiyle ilgilidir. `router` nesnesini dışa aktarır, böylece başka dosyalarda kullanılabilir hale gelir.
- **Neden kullanılır?** Büyük bir projede kodun modüler olması önemlidir. Farklı rotalar ayrı dosyalara bölünür ve daha sonra ana dosyada (örneğin `app.js`) birleştirilir.
- **Bu komut ne yapar?** Bu komut, `router` nesnesini başka bir dosyaya dahil etmek (import etmek) için kullanılabilir hale getirir.


1. validateEmail 
2. getUserToken 
3. verifyToken

`function validateEmail(email) {` 
	`return String(email)` 
		`.toLowerCase()`
		`.match(/^...SNIP...$/);`
`}`

Bu JavaScript fonksiyonu, bir **e-posta adresini doğrulamak** (validate etmek) için yazılmıştır. Aşağıda, satır satır ne işe yaradığını açıklıyorum:

`function validateEmail(email) {` 

- Bu bir **fonksiyon tanımıdır**.
- **`validateEmail`** fonksiyonunun amacı, bir **e-posta adresinin geçerli olup olmadığını kontrol etmektir**.
- **Parametre:** `email` adında bir değişken alır. Bu, doğrulanmak istenen e-posta adresini temsil eder.

`return String(email)` 

- Gelen `email` parametresini önce bir **String** (metin) veri tipine dönüştürür. Bu, özellikle `email` bir sayı ya da başka bir türde ise, metin olarak işlem yapabilmek için önemlidir.
- Eğer parametre zaten bir metinse, herhangi bir değişiklik yapılmaz.


`.toLowerCase()`

- Dönüştürülen metin (e-posta adresi), tamamen **küçük harfe** çevrilir.
- **Neden küçük harfe çevriliyor?** E-posta adresleri büyük/küçük harf duyarsızdır, yani `EXAMPLE@DOMAIN.COM` ile `example@domain.com` aynı şeydir. Bu yüzden doğrulama sırasında büyük/küçük harf farkını önlemek için küçük harfe çevrilir.


`.match(/^...SNIP...$/);`


- **`match` Metodu:** Küçük harfe çevrilmiş metni, bir **düzenli ifadeyle (regex)** kontrol eder.
    
- Düzenli ifade (regex), belirli bir deseni tanımlamak için kullanılan bir kuraldır. Burada `...SNIP...` yazdığı için düzenli ifadenin tamamı verilmemiş, ancak e-posta doğrulamak için bir desen olduğu anlaşılıyor.
    
- **Neden düzenli ifade kullanılıyor?**
    
    - Bir e-posta adresinin doğru formatta olup olmadığını kontrol etmek için:
        - KullanıcıAdı@AlanAdı.uzantı
        - Örnek: `user@example.com`
        
**Düzenli İfade Deseni:** Yaygın bir regex şu şekildedir:

`/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/`


validateEmail fonksiyonu, dosyanın sonunda dışa aktarılmadığı için bu dosyaya lokal gibi görünmektedir. Bir göz attığımızda, bir e-posta biçimiyle eşleştiğinden emin olmak için bir dizeyi düzenli bir ifade desenine karşı doğrulayan temel bir işlev gibi görünüyor



### getUserToken

**getUserToken** fonksiyonuna geri dönersek, bu fonksiyonun, POST request body'sinden, yani **req.body**'den **email** parametresini alarak başladığını görüyoruz. Daha önce gördüğümüz **bodyparser** nedeniyle tüm endpoint'lerin bir **JSON body** beklediğini biliyoruz, bu yüzden bunu aklımızda tutmalıyız.

Bundan sonra, fonksiyon, yukarıda açıklanan **validateEmail** fonksiyonunu kullanarak e-posta formatını doğruluyor. Kodda yer alan bir yorum satırına göre bu işlem gerçekleşiyor. Bu tür yorumlar, kodun anlaşılmasını kolaylaştırdığı için oldukça faydalıdır. Ancak, ya kodda hiç yorum satırı olmasaydı? Böyle bir durumda, kodun işlevselliğini anlamak için **kodlama bilgimize** güvenmek zorunda kalırız.

Eğer bir 'secure coding' (güvenli kodlama) egzersizi yapıyor olsaydık, incelemekte olduğumuz dil hakkında derin bir bilgiye sahip olmamız beklenirdi. Ancak, aynı durum **whitebox pentesting** için geçerli değildir. Bunun sebebi, büyük olasılıkla birden fazla dilde yazılmış farklı kod tabanlarını test ediyor olmamızdır ve her dilde uzman olmamız beklenemez. Bu, güvenli kodlama yaparken genellikle uzun süre aynı kod tabanı üzerinde çalışmamızdan farklıdır.

Bu nedenle, **whitebox pentesting** için gerekli olan birincil beceri, kodun genel amacını anlamaktır. Bu, kodun savunmasız olup olmadığını belirlememizi sağlar.

Fonksiyona devam edersek, yorumların bir sonraki kısmı belirtmediğini göreceğiz. Hızlı bir bakış, iki key içeren bir jwt token'ı imzalıyor gibi göründüğünü gösterir:

- **email** "bizim input'umuzdan alınır"
- **role** "email tarafından belirlenir"

Bundan sonra, endpoint imzalı jwt token'ı döndürür. Anladığımızdan emin değilsek, VSCode Copilot “veya ChatGPT gibi kodlama bilincine sahip başka bir AI sohbet botu” kullanarak AI'dan bize fonksiyonun ne yaptığını söylemesini isteyebiliriz:


`let accessToken;`

`try {`
  `accessToken = jwt.sign(`
    `{`
      `email, // Kullanıcının e-posta adresi`
      `role: email.includes("@hackthebox.com") ? "admin" : "user", // E-posta "@hackthebox.com" içeriyorsa kullanıcı admin olur, aksi takdirde user`
    `},`
    `JWT_ACCESS_SECRET, // Token'ı imzalamak için kullanılan gizli anahtar`
    `{`
      `expiresIn: "1d", // Token'ın 1 gün sonra geçerliliğini yitireceği belirtiliyor`
    `}`
  `);`
`} catch (err) {`
  `return next({`
    `message: "Could not authenticate user, please try again.",`
    `statusCode: 500,`
  `});`
`}`

`if (accessToken) {`
  `res.json({`
    `token: accessToken, // Erişim token'ı başarıyla oluşturulursa bu token döndürülür`
  `});`
`}`


1. **`let accessToken;`**  
    Bu satırda, bir **accessToken** değişkeni tanımlanır. Bu değişken, daha sonra JWT'yi saklamak için kullanılacaktır.
    
2. **`try { ... } catch (err) { ... }`**  
    Bu blok, kodun güvenli bir şekilde çalışmasını sağlamak için hata yönetimi (error handling) içerir. Eğer JWT oluşturulurken bir hata meydana gelirse, catch bloğundaki kod çalışacaktır.
    
3. **`accessToken = jwt.sign({...}, JWT_ACCESS_SECRET, {...})`**  
    Burada, **jwt.sign()** fonksiyonu ile bir token oluşturuluyor. Fonksiyonun içinde, şu parametreler yer alır:
    
    - **`email`**: Kullanıcının e-posta adresi (dışarıdan alınır, örneğin form ile).
    - **`role`**: Kullanıcının rolü. E-posta adresi "@hackthebox.com" içeriyorsa kullanıcı **admin** olarak kabul edilir, değilse **user** olarak kabul edilir. Bu, kullanıcının rolünü belirler.
    - **`JWT_ACCESS_SECRET`**: Token'ı imzalamak için kullanılan gizli bir anahtardır. Bu, güvenliğin sağlanmasında önemli bir parametredir.
    - **`expiresIn: "1d"`**: Token'ın geçerlilik süresi 1 gün olarak ayarlanmıştır. Bu, token'ın 24 saat sonra geçersiz olacağı anlamına gelir.
4. **`catch (err) { return next({ ... }) }`**  
    Eğer **jwt.sign()** fonksiyonu sırasında bir hata oluşursa, bu blok çalışacaktır. Burada kullanıcıya hata mesajı gönderilir ve işlem başarısız olduğunda HTTP 500 hatası (sunucu hatası) döndürülür.
    
5. **`if (accessToken) { res.json({ token: accessToken }) }`**  
    Eğer token başarılı bir şekilde oluşturulmuşsa, token bir **JSON** olarak kullanıcıya gönderilir. Bu, genellikle kullanıcının kimliğini doğrulamak için başka bir API'ye gönderilmesi gereken bir **access token**'dır.
    

### Özet:

- **E-posta** adresine bakarak, kullanıcının rolünü (admin veya user) belirler.
- **JWT** oluşturur ve bunu kullanıcıya döndürür.
- Eğer token oluşturulamazsa, hata mesajı ile işlem durdurulur.

Copilot daha fazla ayrıntıya giriyor, ancak bizim anlayışımızı doğruluyor. Bu tür araçlar, bizim için birçok görevi basitleştirebildiklerinden, beyaz kutu pentesting uygulamasında faydalı olabilir. Bununla birlikte, bir uyarı: Tüm görevler için yapay zekaya aşırı güvenmeyin, çünkü hata yapması veya bir insanın fark edebileceği şeyleri kaçırması çok yaygındır. Esas olarak “az önce yaptığımız gibi” anlayışınızı doğrulamak veya anlamadığınız bir şeyi açıklığa kavuşturmak için kullanın “ve sonra onaylamak için iki kez kontrol edin”.

Not: Bu, kullanıcıya bir kimlik doğrulama tokenı döndüren basitleştirilmiş bir kimlik doğrulama işlevidir. Bu, daha fazla kurulum ve kaynak gerektiren bir veritabanına güvenmekten kaçınmak için yapılır, ancak genel fikir aynı kalır. Diğer birçok modül tam bir kimlik doğrulama mekanizmasına sahip olacaktır, ancak bu bizim amaçlarımız için yeterli olacaktır.


### verifyToken

Son olarak, verifyToken fonksiyonuna sahibiz. Adından da anlaşılacağı gibi, authorization HTTP başlığı olan req.headers.authorization'dan token'ı alarak başlar. Eğer herhangi bir token sağlanmamışsa, 403 Unauthorized hatası verir. Aksi takdirde, token'ın imzalı olduğunu ve manipüle edilmediğini doğrulamak için jwt.verify işlevini kullanır. Token imzalanmışsa, daha sonra göreceğimiz gibi, sunucudaki diğer endpoint'ler tarafından kullanılmak üzere isteğin kullanıcı nesnesine ekler.

Bu fonksiyon, sunucudaki diğer endpoint'ler tarafından kullanılmak üzere kullanıcının token'ında saklanan güvenli ayrıntıları alır. Dolayısıyla, bir endpoint çağrılmadan önce verifyToken kullanıyorsa, bu endpoint'in büyük olasılıkla kimliği doğrulanmış bir token (yani geçerli kullanıcı kimlik doğrulaması) gerektirdiğini biliyoruz.

Şimdiye kadar her şey normal görünüyor, o halde bir sonraki rotaya geçelim ve neler içerdiğine bakalım.


### Kod İnceleme - Services

Artık /api/auth API endpoint ve fonksiyonlarını ele aldığımıza göre, routes/service-routes.js içinde bulunan /api/service endpointlerini kontrol edebiliriz:

`const router = express.Router();` // Express Router'ını oluşturur
`router.use(verifyToken);` // verifyToken fonksiyonunu, tüm gelen isteklerde kullanılmak üzere ara katman olarak ekler 
`router.post("/generate", generateQR);` // "/generate" yoluna gelen POST isteğini, generateQR fonksiyonu ile işler
`module.exports = router;` // router'ı dışa aktarır, böylece başka dosyalarda kullanılabilir


### Adım Adım Açıklama:

1. **`const router = express.Router();`**
    
    - Burada, **Express Router** kullanılarak bir **router** nesnesi oluşturuluyor.
    - **Router**, belirli yollar ve HTTP metodları (GET, POST, vb.) için işlevler tanımlamanıza olanak sağlar.
    - Bu, ana uygulama içinde farklı API yollarını modüler bir şekilde yönetmenizi sağlar.
2. **`router.use(verifyToken);`**
    
    - Bu satır, **middleware** (ara katman yazılımı) olarak bilinen **verifyToken** fonksiyonunu, tüm gelen isteklerde çalıştırılacak şekilde ayarlıyor.
    - **verifyToken** fonksiyonu, genellikle bir **JWT token**'ını doğrulamak için kullanılır. Bu sayede, her gelen istekten önce token'ın geçerli olup olmadığı kontrol edilir.
    - Eğer token geçersizse, istek durdurulur ve genellikle hata mesajı döndürülür.
3. **`router.post("/generate", generateQR);`**
    
    - Bu satırda, **POST** isteği alacak bir yol tanımlanıyor. Bu yol, **"/generate"** olarak belirlenmiş.
    - Bu yola bir **POST** isteği yapıldığında, **generateQR** fonksiyonu çalıştırılır.
    - **generateQR**, muhtemelen bir **QR kodu** oluşturmak için kullanılan bir fonksiyondur. Bu fonksiyon, isteğe bağlı olarak gelen verilerle bir QR kodu üretebilir.
4. **`module.exports = router;`**
    
    - Bu satır, **router** nesnesini dışa aktarır.
    - Bu, başka bir dosyada **require()** fonksiyonu ile bu router'ı kullanabilmenizi sağlar.
    - Örneğin, başka bir dosyada şu şekilde kullanılabilir:

`const apiRouter = require('./router');` 
`app.use('/api', apiRouter);`


### Özet:

- **Router**: Bir grup API yolunu organize eder ve yönetir.
- **`verifyToken` Middleware**: Tüm gelen isteklerde, geçerli bir token olup olmadığını kontrol eder.
- **`/generate` Yolu**: **POST** isteği alır ve **generateQR** fonksiyonunu çalıştırarak QR kodu oluşturur.
- **`module.exports`**: Bu router'ı başka bir dosyada kullanmak için dışa aktarır.


Tek bir POST endpoint'i olduğunu görüyoruz, o da /generate . Ayrıca, önceki bölümde tartışıldığı gibi, verifyToken fonksiyonu ondan önce kullanıldığı için bu endpoint'in kimlik doğrulaması gerektirdiğini görüyoruz. Şimdi generateQR'ye yakından bakalım.


### generateQR

controllers/service-controllers.js dosyası yalnızca iki fonksiyon içerir

1. validateString 
2. generateQR

Kullanımını önizlemek için validateString'e CMD/CTRL ile tıklayabiliriz ve generateQR fonksiyonu içinde yalnızca bir kez kullanıldığını görürüz, bu yüzden kodunu inceleyelim.

POST request body'den text parametresini alarak başladığını ve ardından req.user'dan role parametresini aldığını görüyoruz:

`const { text } = req.body;` 
`const role = req.user?.role;`

---

### 1. **`const { text } = req.body;`**

- **`req.body`**: Bu, **Express.js** framework'ünde, HTTP istekleriyle gönderilen **veri**yi temsil eder. **`req.body`**, genellikle **POST** veya **PUT** isteklerinde kullanılır ve bu veriler genellikle JSON formatında olur.
    
    - Örneğin, bir istemci (client) bir formu gönderdiğinde, form verileri **`req.body`** içinde bulunur.
- **`const { text } = req.body;`**:
    
    - Bu satır, **destructuring assignment** (yapı bozma ataması) kullanarak **`req.body`** içinde gönderilen verilerden **`text`** adlı bir özelliği alır ve bir değişkene atar.
        
    - Eğer **`req.body`** şu şekilde bir veri içeriyorsa:


![Pasted image 20241210000941.png](/img/user/resimler/Pasted%20image%2020241210000941.png)

- Bu durumda, **`text`** değişkeni **"Hello, world!"** değerini alır.
    
- **Destructuring** özelliği, nesneden tek tek elemanları çıkarmak ve bu elemanları bağımsız değişkenlere atamak için kullanılır.



### 2. **`const role = req.user?.role;`**

- **`req.user`**: Bu, genellikle bir **middleware** (ara katman yazılımı) aracılığıyla belirli bir kullanıcı bilgisini içeren bir nesneyi temsil eder. Örneğin, kullanıcı doğrulaması yapıldıktan sonra, kullanıcının bilgileri **`req.user`** içinde bulunabilir.
    
    - Bu, genellikle oturum açmış (authenticated) kullanıcıya ait bilgileri tutar. **`req.user`**, örneğin JWT token'dan alınan kullanıcı bilgileri olabilir.
- **`?.` (Optional Chaining)**: Bu, **JavaScript**'te **"Optional Chaining"** (Opsiyonel Zincirleme) adı verilen bir özelliktir.
    
    - **`?.`** operatörü, bir nesnenin içindeki bir özelliğe erişmeden önce, nesnenin **`null`** veya **`undefined`** olup olmadığını kontrol eder. Eğer nesne **`null`** veya **`undefined`** ise, hata fırlatmak yerine **`undefined`** döner.
    - Örneğin:

![Pasted image 20241210001005.png](/img/user/resimler/Pasted%20image%2020241210001005.png)

- Eğer **`req.user`** nesnesi mevcutsa, **`role`** özelliği alınır.
        - Eğer **`req.user`** **`null`** veya **`undefined`** ise, **`role`** değişkeni **`undefined`** olur ve hata fırlatmaz.
- **`const role = req.user?.role;`**:
    
    - Bu satırda, **`req.user`** nesnesinin **`role`** özelliği alınmak isteniyor.
    - Eğer **`req.user`** nesnesi varsa ve içinde **`role`** özelliği bulunuyorsa, o özellik **`role`** değişkenine atanır. Eğer **`req.user`** nesnesi yoksa, **`role`** değişkeni **`undefined`** olur.

### Özet:

1. **`const { text } = req.body;`**: **req.body** içindeki **`text`** özelliğini alır ve **`text`** adlı bir değişkene atar.
2. **`const role = req.user?.role;`**: **req.user** nesnesinin **`role`** özelliğini güvenli bir şekilde alır. Eğer **`req.user`** yoksa, **`role`** değişkeni **`undefined`** olur.

---

Daha önce tartıştığımız gibi, **req.user** kimlik doğrulama token'ından kullanıcının e-posta adresine dayalı olarak atanır. Bundan sonra, endpoint, hem **text** hem de **roles** parametrelerini geçirerek **validateString** fonksiyonunu çalıştırır.

Son olarak, dosyanın başında içe aktarılan **qrcode** paketinden **QRCode.toDataURL** fonksiyonu çalıştırılır. Bu fonksiyonun üzerine fareyi getirdiğimizde, "dış paket olduğu için" dökümantasyonunu görebiliriz ve bu fonksiyonun, QR Kod görüntüsünün bir temsilini içeren bir Data URI döndürdüğünü görürüz.

![Pasted image 20241210001206.png](/img/user/resimler/Pasted%20image%2020241210001206.png)

Tipik olarak, dış paketleri manuel olarak test etmek, daha sonra göreceğimiz gibi npm audit komutu ile yapabileceğimiz genel güvenlik açıklarını kontrol etmenin yanı sıra, bir whitebox pentest uygulamasının kapsamı dışındadır.

Dolayısıyla, bu endpoint kullanıcı girdisindeki metni bir QR koduna dönüştürüyor gibi görünmektedir. Geriye validateString fonksiyonu kalıyor, şimdi ona daha yakından bakalım.


### validateString
Fonksiyon nispeten kısa ve özdür:

![Pasted image 20241210001313.png](/img/user/resimler/Pasted%20image%2020241210001313.png)

----


Bu **validateString** fonksiyonu, bir **input** (girdi) ve bir **onError** (hata durumunda yapılacak işlem) parametresi alır. Fonksiyonun amacı, verilen girdi string'inin (yazı) belirli kurallara uygun olup olmadığını kontrol etmektir. Adım adım açıklayalım:

1. **typeof input !== "string"**:
    
    - Bu kontrol, verilen **input**'un bir string (yazı) olup olmadığını kontrol eder. Eğer **input** bir string değilse, fonksiyon **false** döner ve hata işlemi yapılır.
2. **input.length == 0**:
    
    - Bu, **input**'un boş olup olmadığını kontrol eder. Eğer input boşsa, yine **false** döner ve hata işlemi yapılır.
3. **input.match(/['"`;]/g)**:
    
    - Bu ifade, **input** string'inin içinde tek tırnak (`'`), çift tırnak (`"`), geri tırnak (`` ` ``) veya noktalı virgül (`;`) olup olmadığını kontrol eder. Bu karakterlerin varlığı, genellikle kötü niyetli kod enjeksiyonlarını (örneğin SQL enjeksiyonu veya XSS) önlemek amacıyla kontrol edilir. Eğer bu karakterlerden herhangi biri varsa, yine **false** döner ve hata işlemi yapılır.
4. **eval(onError)**:
    
    - Eğer yukarıdaki kontrollerden herhangi biri başarısız olursa, **eval(onError)** fonksiyonu çağrılır. **eval()**, JavaScript'te bir string içindeki JavaScript kodunu çalıştıran bir fonksiyondur. Burada **onError** bir string olmalı ve içinde çalıştırılacak bir işlem barındırmalıdır (örneğin hata mesajı göstermek gibi).
5. **return false**:
    
    - Eğer herhangi bir kontrol başarısız olursa, fonksiyon **false** döner.
6. **return true**:
    
    - Eğer tüm kontroller başarıyla geçerse, fonksiyon **true** döner, yani input geçerli bir string olarak kabul edilir.

### Özet:

Bu fonksiyon, verilen **input** string'inin belirli kurallara uygun olup olmadığını kontrol eder. Eğer input geçerli değilse, belirli bir hata işlemine (onError) yönlendirilir ve **false** döner. Eğer input geçerli bir stringse, **true** döner.


---

İki parametre alır: input ve onError . Ardından, stringin geçerli olup olmadığını belirtmek için bir if deyimi çalıştırır. if deyimi aşağıdakileri kontrol eder:

1. Input bir string değilse (örn. bir sayı veya nesne)
2. giriş uzunluğu 0 ise
3. Girdi belirtilen düzenli ifade kalıbıyla eşleşiyorsa


Yukarıdaki koşullardan hiçbiri karşılanmazsa, string geçerli kabul edilir ve fonksiyon tarafından true döndürülür. İlk iki koşul açıktır, ancak AI'dan bizim için düzenli ifadeyi açıklamasını isteyelim:

GitHub Copilot bize ' , “ ,  veya ; karakterlerinin örneklerini aradığını söylüyor. Bu, kötü karakterler içeriyorsa kullanıcı girdisini QR kod oluşturucusunda çalıştırmaktan kaçınmak için istismarlara karşı bir filtredir. Kod koşullardan herhangi birini ihlal ederse, fonksiyon tarafından false döndürülür ve onError string'i eval üzerinden çalıştırılır:

![Pasted image 20241210001824.png](/img/user/resimler/Pasted%20image%2020241210001824.png)

JavaScript fonksiyonlarının veya kodlarının başka bir fonksiyona parametre olarak geçtiğini görmek nadir değildir. Ancak, herhangi bir stringi eval ile çalıştırmak tehlikeli olabilir, bu nedenle daha fazla test için bu fonksiyonu kısa listeye alabiliriz.



### Önceliklendirme ve Hedef Seçimi

Dolayısıyla, farklı API endpoint'lerini inceledikten sonra, savunmasız olabilecek yalnızca bir ilginç fonksiyonu kısa listeye aldık. Buna ek olarak, dış paketleri genel güvenlik açıkları için kontrol etmemiz gerekiyor.

Nispeten küçük bir kod tabanıyla uğraştığımız için bu normaldir, bu nedenle çok fazla ilginç bulgu bulmayı beklemiyoruz. Ancak, daha büyük kod tabanlarıyla uğraşıyor olsaydık, Akademi'deki diğer modüllerde gösterildiği gibi, ilginç işlevleri tekrar tekrar kısa listeye almayı bekleyebilirdik

Bir sonraki bölümde, yukarıdaki iki bulguyu test etmek için local test adımına başlayacağız ve bunun bizi nereye götüreceğini göreceğiz.


### Planning

Artık kod tabanındaki kapsamımız hakkında genel bir anlayışa sahip olduğumuza göre, whitebox pentesting'in bir sonraki adımı olan Local Testing'e başlayabiliriz. Testimiz için web uygulamasını local olarak kurarak başlayacağız. Daha sonra, güvenlik açığı olup olmadığını ve istismar edilip edilemeyeceğini belirlemek için kısa listeye aldığımız işlevi test edeceğiz.


### Lokal Ortamın Kurulması

Backend replication prosesi veya web uygulamasının local olarak kurulması , web uygulamasına bağlı olarak bir whitebox pentest'ten diğerine değişir.

Daha önce tartışıldığı gibi, bu, diğer HackTheBox Academy modüllerinde gösterildiği gibi, bir VM veya bir docker konteyneri sağlamak gibi, bizi işe alan kuruluş tarafından hazırlanabilir. Bu modül için, bize yalnızca kaynak kodun, lokal olarak çalıştırmak için talimatların ve backend sunucusunun Debian tabanlı bir Linux Dağıtımı üzerinde çalıştığı gerçeğinin sağlandığı durumu varsayacağız. Bazen, backend'in çoğaltılmasıyla ilgili talimatlara sahip olmayabiliriz, bu nedenle tersine mühendislik yapmamız gerekebilir, ancak burada durum böyle değildir

Not: Windows kullanıyorsanız, uygulamayı bir Linux VM üzerinde çalıştırmak veya production sunucusuna yakından benzemek için PwnBox kullanmak en iyisi olabilir.

Web uygulamamızı çalışır hale getirmek için önceki bölümlerde indirdiğimiz arşivi npm install komutu ile aşağıdaki gibi çalıştırmamız gerekiyor:

![Pasted image 20241210005236.png](/img/user/resimler/Pasted%20image%2020241210005236.png)

Bu web uygulaması nispeten küçüktür, bu nedenle paketlerini yüklemek sadece birkaç saniye sürer. Bu işlem tamamlandıktan sonra, aşağıdaki gibi npm run dev ile çalıştırabiliriz:


![Pasted image 20241210005258.png](/img/user/resimler/Pasted%20image%2020241210005258.png)
![Pasted image 20241210005302.png](/img/user/resimler/Pasted%20image%2020241210005302.png)


package.json dosyası, web uygulamasını çalıştırmak için hangi paketlerin yüklenmesi ve hangi komutların çalıştırılması gerektiğine ilişkin gerekli tüm ayrıntıları içerir ve yukarıdaki komutlar çalışmak için bu dosyayı kullanır. Bir kimlik doğrulama token'ı almaya çalışarak uygulamanın doğru çalıştığını doğrulayabiliriz.

getUserToken fonksiyonunu önceki bölümlerde tartışmıştık, bu nedenle /api/auth/authenticate adresine e-posta verilerini içeren bir JSON body ile bir POST isteği göndermemiz gerektiğini biliyoruz, bunu curl kullanarak aşağıdaki gibi yapabiliriz:

![Pasted image 20241210013024.png](/img/user/resimler/Pasted%20image%2020241210013024.png)

Gördüğümüz gibi, bir kimlik doğrulama token'ını başarıyla elde ettik, bu nedenle uygulama beklendiği gibi çalışıyor.


### Checking for Public Vulnerabilities

Kısa listeye aldığımız fonksiyonu test etmeye geçmeden önce, şimdi web uygulamasının dayandığı paketlerden herhangi birinde bulunan genel güvenlik açıklarını aramak için iyi bir zamandır, çünkü bunlar aynı zamanda uygulamadan yararlanmanın başka bir yolu olabilir. Bu, aşağıdaki gibi npm audit komutu ile kolayca yapılabilir:

![Pasted image 20241210013132.png](/img/user/resimler/Pasted%20image%2020241210013132.png)

Hiçbir güvenlik açığı bulamadığını görüyoruz. Yüklü paketler eskidikçe bu durum değişebilir, bu nedenle paketleri izlemeli ve güncellemeliyiz. Şimdi testlerimize devam edelim.

Not: Güvenlik açığı bulunan bir paketin yamalanması büyük bir güncelleme gerektiriyorsa (örneğin X.0.0 sürümü değiştirilmişse), uygulamanın çalışmaya devam etmesi için kod değişiklikleri gerektiren kırılma değişiklikleri içerebilir. Bu gibi durumlarda, geliştiricilerin bu tür güncellemeleri uygulamalarını öneririz.


### Running validateString

validateString hedef fonksiyonumuzu test etmeye ve hata ayıklamaya başlayabiliriz. Öncelikle /api/service/generate API endpoint'inin temel fonksiyonelliğini test ederek başlayalım, bunu curl ile de yapabiliriz, ancak daha önce elde ettiğimiz token'ı aşağıdaki gibi sağlamamız gerekir:

![Pasted image 20241210020458.png](/img/user/resimler/Pasted%20image%2020241210020458.png)

Gördüğümüz gibi, isteğimiz bize base64 kodlu bir görüntü olarak döndürülen QR kodunu başarıyla elde etti.

Not: Oluşturulan QR kodunu önizlemek istiyorsanız, çıktıyı bir html dosyasına yönlendirin ( > output.html ) ve ardından herhangi bir tarayıcıda açın.



### Debugging validateString

QR kodu çıktısını başarıyla aldığımıza göre, generateQR'nin başarıyla çalıştığını ve validateString fonksiyonunun, ilettiğimiz metin stringinin geçerli ve güvenli olduğunu gösteren true değerini döndürdüğünü güvenle varsayabiliriz. validateString içinde bir breakpoint ayarlayarak bunu doğrulayabiliriz ve yukarıdaki isteği tekrar gönderdiğimizde uygulama kesilmelidir.

Bunu yapmak için öncelikle uygulamayı debug modunda çalıştırmamız gerekiyor. Arşiv, uygulamayı debug modunda çalıştırmak için gereken tüm ayrıntıları içeren bir .vscode dizini içerir. Bu nedenle, tek yapmamız gereken VSCode'daki Run and Debug sekmesine gitmek ve ardından aşağıdaki gibi Launch Program'ın yanındaki Run simgesine tıklamaktır:

![Pasted image 20241210021358.png](/img/user/resimler/Pasted%20image%2020241210021358.png)

Uygulama debug modunda çalıştığında, bunu belirtmek için alt çubuk kırmızıya dönmelidir. Şimdi controllers/service-controllers.js dosyasına geri dönebilir ve [SHIFT+F9] kısayolunu kullanarak satıra tıklayarak 4. satıra bir breakpoint ekleyebiliriz. Yanında etkin bir breakpoint'i gösteren kırmızı bir nokta belirecektir. Ardından, tek yapmamız gereken önceki isteği yeniden göndermektir ve uygulama o noktada kesilmelidir (isteğimiz bu satıra ulaşırsa):

![Pasted image 20241210021444.png](/img/user/resimler/Pasted%20image%2020241210021444.png)

Gördüğümüz gibi, uygulama breakpoint'e ulaştı. Ayrıca soldaki VARIABLES bölmesinin altında tüm değişkenleri görebiliriz. Bu, fonksiyona ilişkin önceki anlayışımızı doğrulamaktadır ve girdimizin yürütmenin o noktasında nasıl göründüğünü ve diğer değişkenlerin girdimizden nasıl etkilendiğini belirlemek için önemli bir yöntem olacaktır.

Fonksiyonun enjeksiyona karşı savunmasız olup olmadığını test etmeye geçmeden önce, kod enjeksiyonları, özellikle de eval enjeksiyonu hakkında hızlı bir tazeleme yapmamız gerekecek ve ardından testimize devam edeceğiz.



### Eval Injection

Bulgularımız temel olarak kod enjeksiyonundan muzdarip olabilecek bir eval fonksiyonuyla bağlantılı olduğundan, Kod Enjeksiyonları hakkında hızlı bir tazeleme yapacağız. Bu konuyla ilgili modülleri zaten tamamlamış olmalısınız, ancak yine de ihtiyacınız varsa, önce Command Injections modülünü tamamlayın. Ayrıca Cross-Site Scripting (XSS) ve SQL Injection Fundamentals gibi diğer enjeksiyon temelleri modüllerini de tamamlamanız önerilir.



### Code Injection

Tüm enjeksiyon güvenlik açıkları, bir saldırganın bir uygulamanın yürütülme şeklini değiştirmek için kullanıcı girdisini kullanmasını içerir. Bu genellikle kullanıcı girdisinin sınırlarını aşan ve onu kullanan fonksiyonu etkileyen bir string enjekte edilerek yapılır. Örneğin, bir SQL enjeksiyonu saldırısında, kullanıcı girdisi SQL sorgusunu etkileyebilir ve bir komut enjeksiyonunda, yürütülen komutu etkileyebilir

Peki ya kod enjeksiyonu? Kod enjeksiyonu güvenlik açığı, girdimizin uygulamanın koduna daha fazla kod enjekte ederek doğrudan etkilediği anlamına gelir. Açıkçası, kod enjeksiyonu güvenlik açıkları yalnızca ==JavaScript== veya ==Python== gibi kaynak kodlarını çalışma zamanı sırasında dinamik olarak yürüten yorumlanmış/kodlanmış dilleri etkiler.

Örneğin, sayfaya HTML/JavaScript kodu enjekte edeceğimiz ve bu kod daha sonra kurbanın makinesinde çalıştırılacağı için XSS güvenlik açıkları kod enjeksiyonu güvenlik açıkları olarak kabul edilir

NodeJS gibi backend üzerinde çalışan bir uygulamaya kod enjekte edebilirsek, basit bir XSS'den daha fazla zarara neden olabiliriz. NodeJS sunucusuna, güvenlik açığından yararlanıldığında çalışacak daha fazla JavaScript kodu ekleyebiliriz.

Bu saldırıya karşı savunmasız olan dile ve framework'e bağlı olarak, ek kütüphaneler import etmek veya herhangi bir fonksiyon çalıştırmak gibi keyfi kod ekleyemeyebiliriz. Sistem komutlarını çalıştıran veya sisteme dosya yazan kod çalıştırabilirsek, o sistemde uzaktan komut yürütmeye (RCE) ulaşabiliriz.


### Code/Command Injection Functions

Bir Whitebox Pentesting alıştırması sırasında bir komut/kod enjeksiyonu güvenlik açığını tespit etmek için, özellikle kullanıcı girdisi giriyorsa, sistem komutlarını yürüten veya dil kodunu değerlendiren işlevlere bakabiliriz. Aşağıda bunu yapabilecek fonksiyonlardan bazıları verilmiştir “vurgulananlar Kod Enjeksiyonu içindir, diğerleri ise Komut Enjeksiyonu içindir”:

![Pasted image 20241210022106.png](/img/user/resimler/Pasted%20image%2020241210022106.png)

Bu tür fonksiyonlara giren kullanıcı girdisi, güvenli bir şekilde doğrulandığından ve sterilize edildiğinden emin olmak için her zaman daha fazla teste yol açmalıdır. Kullanıcı girdisi de bunları dolaylı olarak etkileyebilir ve Modern Web Exploitation Techniques modülünde gösterildiği gibi Second-order saldırıların bir biçimi olarak test edilmelidir.


### Eval Injection

Tanımladığımız eval fonksiyonu kendisine aktarılan herhangi bir metni kod olarak değerlendirir, yani JavaScript kodu olarak çalıştırır. Bir stringi JavaScript kodu olarak değerlendiren tek JavaScript fonksiyonu değildir, çünkü diğer fonksiyonlar da aynı şeyi yapar ve kod enjeksiyonundan muzdarip olabilir. Aşağıda bu tür fonksiyonların kullanımına ilişkin bazı örnekler verilmiştir:

![Pasted image 20241210022235.png](/img/user/resimler/Pasted%20image%2020241210022235.png)

Kod enjeksiyonuna gelince, eğer diğer enjeksiyon türlerine aşinaysanız, eval enjeksiyonunu anlamak kolay olacaktır. Tek yapmamız gereken kullanıcı girdisinin sınırlarından kaçmak ve eval fonksiyonuna daha fazla kod eklemektir. Örneğin, aşağıdaki temel eval fonksiyonu örneğini ele alalım:

![Pasted image 20241210022259.png](/img/user/resimler/Pasted%20image%2020241210022259.png)

Bu kodun savunmasız olduğunu hemen anlayabiliriz, çünkü girdimiz doğrudan sanitizasyon veya doğrulama olmadan eval fonksiyonuna yerleştirilmiştir. Kod enjekte etmek için tek yapmamız gereken ilk tek tırnak işaretini ' kapatmak ve ardından kodumuzu eklemektir. Böylece, aşağıdaki girdiyi payload'umuz olarak kullanabiliriz:

![Pasted image 20241210022346.png](/img/user/resimler/Pasted%20image%2020241210022346.png)

Yani, son satır aşağıdaki gibi olacaktır:

![Pasted image 20241210022411.png](/img/user/resimler/Pasted%20image%2020241210022411.png)

Bu, aşağıdaki JavaScript kodunu çalıştıracaktır:

![Pasted image 20241210022521.png](/img/user/resimler/Pasted%20image%2020241210022521.png)


console.log(“injection”); kısmı, uygulamanın yürüteceği ve çalıştıracağı enjekte edilmiş kodumuzdur. Bu, eval enjeksiyonlarını anlamak için temel bir örnektir, ancak bir sonraki bölümde, eval enjeksiyonlarına daha derinlemesine dalacağız ve payload'ları nasıl hazırlayacağımızı öğreneceğiz ve kod enjeksiyonuna düzgün bir şekilde ulaştığımızı doğrulayacağız.


### validateString
Artık eval enjeksiyonlarını anladığımıza göre, savunmasız olup olmadığını görmek için validateString'e dönebiliriz. Daha önce tartışıldığı gibi, fonksiyon aşağıdaki gibi generateQR fonksiyonu içinde yalnızca bir kez kullanılır:

`!validateString(`
  `text,`
  `// provide verbose error message 'for admins only'`
  `role === "admin"`
    `? throw({message: 'The input "${text}" contains the following invalid characters: [${text.match(/['";]/g)}]', statusCode: 403})`
    `: "throw({message: 'Invalid input', statusCode: 403})"`
`);`

-----

#### 1. **`!validateString()`**

- `validateString()` fonksiyonu, bir **string** girdiyi doğrulamak için kullanılır.
- Eğer `validateString()` fonksiyonu `false` dönerse (yani girdi geçersizse), **negasyon operatörü (`!`)** ile bu durum tespit edilir ve gerekli hata mesajı oluşturulur.

#### 2. **`text`**

- `text`, doğrulanacak girdidir. Kullanıcıdan gelen bir string input olabilir (örneğin bir formdan veya API isteğinden alınmış).

#### 3. **`role === "admin"`**

- Kullanıcının rolünü kontrol eder. Eğer kullanıcının rolü "admin" ise, daha ayrıntılı bir hata mesajı döner.
- **Amaç:** Adminlere detaylı hata mesajı sağlamak, böylece hangi karakterlerin geçersiz olduğunu görüp buna göre aksiyon alabilirler.


4. **Hata Mesajı (Admin İçin):**

`throw({message: 'The input "${text}" contains the following invalid characters: [${text.match(/['";]/g)}]', statusCode: 403})`

- Bu mesaj, input'un içinde hangi **geçersiz karakterlerin** bulunduğunu belirtir.
    
- `text.match(/['"`;]/g)`:
    
    - `text` içinde **tek tırnak ('), çift tırnak ("), eğik tırnak (`), noktalı virgül (;)** gibi karakterleri bulur.
    - Geçersiz karakterler bir dizi içinde döner ve hata mesajında gösterilir.
- **Örnek Çıktı (Admin İçin)**: Eğer `text` şu şekildeyse:

`hello 'world;`


Hata mesajı şöyle olur:

`{` 
`message: 'The input "hello \'world;" contains the following invalid characters: [', ;]', statusCode: 403 }`


5. **Hata Mesajı (Admin Olmayanlar İçin):**

`"throw({message: 'Invalid input', statusCode: 403})"`

- Eğer kullanıcı admin değilse, daha genel bir hata mesajı döner.
    
- **Amaç:** Kullanıcıya fazla bilgi vermemek ve potansiyel saldırganların sisteme dair ipucu almasını önlemek.


#### 6. **Sonuç:**

`validateString()` fonksiyonu çağrılırken, `onError` parametresine yukarıda belirtilen hata mesajlarından biri aktarılır. Eğer `validateString()` başarısız olursa, `onError` içerisindeki `throw` ifadeleri tetiklenir ve hata fırlatılır.


### Genel İşleyiş:

1. Kullanıcının girdiği `text` kontrol edilir.
2. Eğer geçersiz bir input varsa:
    - Kullanıcı admin ise detaylı bir hata mesajı oluşturulur (geçersiz karakterler belirtilir).
    - Kullanıcı admin değilse genel bir hata mesajı döner.
3. `validateString()` başarısız olursa, `throw` ile uygun hata fırlatılır.

----


Daha önce gördüğümüz gibi, ikinci parametrenin ( onError ) eval'a giren şey olduğunu biliyoruz:


![Pasted image 20241210023300.png](/img/user/resimler/Pasted%20image%2020241210023300.png)

validateString kullanıldığında, onError parametresi için aşağıdaki kullanılır:

![Pasted image 20241210023328.png](/img/user/resimler/Pasted%20image%2020241210023328.png)

Haydi bu kodu anlamaya çalışalım. Girdi, **role** (rol) değerine bağlıdır ve bu değer **admin**'e eşit olup olmamasına göre değişir. Eğer eşit değilse, **throw({message: 'Invalid input', statusCode: 403})** doğrudan **eval** fonksiyonuna aktarılır. Bu kodda kullanıcı girdisi bulunmamaktadır, dolayısıyla üzerinde kontrolümüz yoktur. Ancak, eğer **role** (rol) değeri **admin** ise, **eval** fonksiyonuna şu kod aktarılır:

![Pasted image 20241210023424.png](/img/user/resimler/Pasted%20image%2020241210023424.png)

AI'dan bu kodu açıklamasını isteyebiliriz, ancak bu durumda buna ihtiyacımız yok, çünkü girdimizin ( ${text} ) doğrudan bu string'e geçtiğini görebiliyoruz. Dolayısıyla, bir sonraki bölümde deneyeceğimiz kod enjeksiyonuna ulaşmak için “admin” rolüne sahip olmalıyız.

> Not: Eğer JavaScript ile aşina değilseniz, bir string içerisinde backtick (``) kullanılarak yazılan `${text}` ifadesindeki `$` işareti **String Interpolation** (String Ara Değiştirme) anlamına gelir. Bu, **text** değişkeninin içeriğini o konumda string'e yerleştirir ve bu durum kod enjeksiyonuna yol açabilir.



### Hedef Fonksiyon

Bir sonraki adımımız, saldırı teorimizi test etmek ve bu işlevin savunmasız olup olmadığını doğrulamaktır. Güvenlik açığından başarılı bir şekilde faydalanmak için her bir gereksinimin karşılandığından emin olmak amacıyla saldırımızı eylem noktaları olarak planlamalıyız.

Bu, saldırılarımızı bozabilecek belirli sorunlardan kaçınmamıza ve herhangi bir sorunun tam olarak nerede ortaya çıkabileceğini bilmemize yardımcı olur. Bazı gelişmiş whitebox pentesting alıştırmalarında doğrudan istismara atlarsak, saldırımızın neden çalışmadığını teşhis etmek zor olabilir ve zamanımızın çoğunu boşa harcayabiliriz.


### Planning the Attack

Peki, eval fonksiyonuna kod enjekte etmek için neye ihtiyacımız var? Planlayalım:

- [x]  **validateString** fonksiyonuna erişim sağla
- [x]  Girdimizin fonksiyon içerisinde nasıl göründüğünü takip et
- [ ]  **Admin** rolünü edin
- [ ]  **eval** fonksiyonuna ulaştığımızı doğrula
- [ ]  Payload'u hazırla
- [ ]  Payload'un hedef fonksiyona planlandığı şekilde ulaştığını doğrula
- [ ]  Kod enjeksiyonu yap ve kod enjeksiyonunu doğrula
- [ ]  Komut çalıştırmaya veya dosya yazımına ulaş 
- [ ]  Komut çalıştırma/dosya yazımını kör şekilde doğrula
- [ ]  Bir exploit yazarak sömürü sürecini otomatikleştir


Gördüğümüz gibi, ilerlememizi kolayca takip edebilmemiz ve sorunların nerede ortaya çıkabileceğini belirleyebilmemiz için saldırımızı aşamalara ayırdık. Bir sonraki adımımız admin rolünü elde etmek, şimdi bunu nasıl yapacağımızı görelim


### Admin Role

Gerçek dünyadaki bir web uygulamasında bu, aşağıdakiler gibi çeşitli yollarla gerçekleştirilebilir:

* Bir web ayrıcalık yükseltme güvenlik açığı aracılığıyla
* Bir yetkilendirme akışı aracılığıyla
* Yönetici kullanıcıya yönelik bir XSS/CSRF saldırısı yoluyla
* Bir yönetici kullanıcı hesabını brute forcing yaparak


Ve bir admin hesabına erişmeye yol açabilecek diğer birçok güvenlik açığı. Bunu yapmak için bildiğimiz bir güvenlik açığı yoksa, o zaman bir admin kullanıcısı isteyebiliriz. Ancak, güvenlik açığının etkisi, admin hesabına sahip yalnızca birkaç kullanıcıyı etkileyeceği için daha düşük olacaktır

Bizim durumumuzda, birden fazla güvenlik açığını zincirlemekten kaçınmak ve whitebox pentesting sürecine odaklanmak için, son seçeneği kullanacağız ve bir admin rolümüz olduğunu varsayacağız. Bir admin yetkilendirme token'ı elde etmek için, daha önce getUserToken fonksiyonunda gördüğümüz gibi, sadece @hackthebox.com domain'li bir e-posta kullanmamız gerekir:

![Pasted image 20241210032120.png](/img/user/resimler/Pasted%20image%2020241210032120.png)

Bu nedenle, bir authorization token elde etmek için kullandığımız önceki isteği tekrarlayacağız, ancak e-postayı hackthebox.com domain'i olarak değiştireceğiz:

![Pasted image 20241210035244.png](/img/user/resimler/Pasted%20image%2020241210035244.png)

JWT token içindeki rol değerini okumak için jwt.io'yu kullanabiliriz ve admin rolünü başarıyla elde ettiğimizi onaylayabiliriz. Böylece, artık planımızda admin rolünü cross olarak elde edebiliriz.

Alıştırma yapın: controllers/service-controllers.js adresinde 30. satıra bir breakpoint ekleyerek ve ardından 17. satırdaki role sağ tıklayıp Add to Watch'u seçerek rolünüzü dinamik olarak doğrulamayı deneyin. Bundan sonra, yeni admin-role token'ınızı kullanarak önceki QR kodu isteğini gönderin ve uygulama kesildiğinde, Run and Debug sekmesi içinde sol bölmedeki WATCH menüsü altında rolün değerini okuyabilirsiniz.


### Reaching the Vulnerable Code

Savunmasız kod satırına nasıl ulaşabileceğimizi görmek için validateString fonksiyonuna geri dönelim:

![Pasted image 20241210035420.png](/img/user/resimler/Pasted%20image%2020241210035420.png)

Koşullar arasında bir OR operatörü kullanıldığından, eval fonksiyonuna yalnızca bir veya daha fazla koşul doğruysa ulaşılır. Daha önce tartışıldığı gibi, bunlar üç koşuldur:

1. Girdi bir string değilse (örn. bir sayı veya nesne)
2. giriş uzunluğu 0 ise
3. Girdi belirtilen düzenli ifade kalıbıyla eşleşiyorsa

Bununla birlikte, girdimizin onError stringine gitmesi de gerekir, bu nedenle boş bir string (0 uzunluk) kullanırsak veya string dışında bir şey kullanırsak, onError'a kod enjekte etmenin bir yolu olmaz. Bu nedenle, ona ulaşmak için belirtilen kötü karakterlerden birini kullanmak için üçüncü seçeneğimiz kalıyor. Yine de kodu bozmaktan kaçınmak için dikkatli olmalıyız.

Bu nedenle, bir önceki bölümde tartışılan onError stringinden ayrılmayacağı için bir noktalı virgül ; kullanmayı deneyelim. JSON payload aşağıdaki gibi olacaktır

![Pasted image 20241210035600.png](/img/user/resimler/Pasted%20image%2020241210035600.png)

İsteğimizi gönderdikten sonra aşağıdaki çıktıyı alıyoruz

![Pasted image 20241210035622.png](/img/user/resimler/Pasted%20image%2020241210035622.png)

Mükemmel! Bu, yalnızca adminlere gösterilen savunmasız verbose hata mesajıdır, yani eval fonksiyonuna ulaştık ve eval fonksiyonu uygulamayı bozmadan onError stringini başarıyla değerlendirdi. Artık savunmasız kod satırına ulaşabildiğimize göre, bir sonraki adımımız eval fonksiyonuna kod enjekte etmek için payload'umuzu hazırlamaktır ki bunu bir sonraki bölümde yapacağız.


### Code Injection 

sayfa 34
