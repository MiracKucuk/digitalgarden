---
{"dg-publish":true,"permalink":"/web-pentest-expert/htt-ps-tls-attacks/"}
---


### Introduction to HTTPS/TLS

The Hypertext Transfer Protocol (HTTP) is an application layer protocol used to access resources on the internet. Since HTTP transmits data in plaintext, it cannot provide confidentiality, integrity, or authenticity of the transmitted data. To overcome these shortcomings of HTTP, the Hypertext Transfer Protocol Secure (HTTPS), also called HTTP over TLS was created. The Transport Layer Security (TLS) protocol and its predecessor, the Secure Sockets Layer (SSL) protocol, are cryptographic protocols that provide secure communication over the internet by encrypting traffic.

Şifreleme (Encryption) genellikle farklı seviyelerde uygulanabilir. Bunlar arasında **encryption-at-rest** (dinamik olmayan veri şifreleme), **encryption-in-transit** (iletişim sırasındaki veri şifreleme) ve **end-to-end encryption** (uçtan uca şifreleme) bulunur.

- **Encryption-at-rest** (dinamik olmayan veri şifreleme), verilerin yetkisiz erişimi önlemek amacıyla depolandığı sırada şifrelenmiş bir formda saklanmasıdır. Örneğin, bir sabit diskin şifrelenmesi bu kategoriye girer.
    
- **Encryption-in-transit** (iletişim sırasındaki veri şifreleme), iletilen verilerin, aktarım öncesinde şifrelenip, alındıktan sonra çözülmesi işlemidir. Bu yöntem, veri iletimi sırasında yetkisiz erişimi önler. Bu modül, **encryption-in-transit** üzerinde yoğunlaşmaktadır, çünkü **TLS** (Aktarım Katmanı Güvenliği) **encryption-in-transit** uygular.
    
- Son olarak, **end-to-end encryption** (uçtan uca şifreleme), verilerin gerçek göndericiden nihai alıcıya kadar şifrelendiği bir yöntemdir ve bu süreçte başka hiçbir tarafın verilere erişmesine izin verilmez.

Bu modülün temel amacı, web kriptografi protokolleri, nasıl çalıştıkları ve bunları kullanırken hangi güvenlik açıklarının ortaya çıkabileceği hakkında bilgi sağlamaktır. Genel olarak, protokollerdeki güvenlik açıklarını bulmak, bireysel web uygulamalarındaki güvenlik açıklarını bulmaya kıyasla daha zordur. Bunun nedeni HTTPS ve TLS gibi protokollerin güvenlik göz önünde bulundurularak tasarlanmış ve olası güvenlik sorunlarının üstesinden gelmek için birçok kez revize edilmiş olmasıdır. Bununla birlikte, protokollerde güvenlik sorunları varsa, çok sayıda hizmet etkilendiği için etki de genellikle çok daha yüksektir. Çoğu zaman, HTTPS veya TLS'deki güvenlik sorunları spesifikasyon kusurları değil, uygulama kusurlarıdır. Bu, protokolün belirli uygulamalarının protokolü doğru uygulamadığı veya güvenlik sorunları yaratabilecek şekilde biraz sapma gösterdiği anlamına gelir.


### TLS'ye Genel Bakış ve Sürüm Geçmişi


### What is TLS?

TLS ve ondan önce SSL, e-posta, dosya aktarımı ve web taraması dahil olmak üzere internet üzerindeki iletişimi güvence altına almak için yaygın olarak kullanılmaktadır. TLS, SSL'deki zayıflıkları gidermek için geliştirilmiştir ve yıllar içinde her biri protokole yeni özellikler ve iyileştirmeler getiren birkaç revizyondan geçmiştir. Günümüzde TLS, internette güvenli iletişim için standart protokoldür

Ağ protokol yığınında (network protocol stack), **TLS** (Aktarım Katmanı Güvenliği) **TCP** ile uygulama katmanı (application layer) arasında bulunur. Uygulama katmanı protokolü, **HTTP**, **SMTP** veya **FTP** gibi herhangi bir protokol olabilir. **TLS**, uygulama katmanı protokolü için şeffaftır, yani uygulama katmanı protokolü **TLS**'in uygulanıp uygulanmadığını bilmek zorunda değildir. Özellikle, **TLS** tüm kriptografik işlemleri yönetir ve uygulama katmanı protokolü, **TLS** kullanılsa da kullanılmasa da aynı şekilde çalışabilir.


**Versiyon Tarihçesi (Version History)**

**SSL** (Secure Sockets Layer), internet üzerinden iletişimi güvenli hale getirmek için 1990'ların ortalarında Netscape tarafından geliştirildi. Hızla güvenli iletişim için standart protokol haline geldi ve web tarayıcıları ile sunucular tarafından yaygın bir şekilde benimsendi. **SSL'in üç ana versiyonu** bulunmaktadır:

1. **SSL 1.0:** SSL'in ilk versiyonuydu. Ciddi güvenlik açıkları nedeniyle hiçbir zaman halka sunulmadı.
2. **SSL 2.0:** 1995 yılında yayınlanan ve geniş çapta kullanılan ilk SSL versiyonuydu. Ancak, bazı durumlarda kullanımını zorlaştıran ve kriptografik saldırılara açık hale getiren birçok ciddi spesifikasyon hatasına sahipti.
3. **SSL 3.0:** SSL'in son versiyonuydu. 2.0 versiyonundaki spesifikasyon hatalarını düzelten tamamen yeniden tasarlanmış bir versiyondu. Ancak günümüzden bakıldığında, artık kullanım dışı bırakılmış (deprecated) kriptografik algoritmalara dayanıyor ve çeşitli saldırılara karşı savunmasız durumda.

**TLS** (Transport Layer Security), SSL'deki zayıflıklara yanıt olarak geliştirildi ve SSL'in yerini almak üzere tasarlandı. TLS, SSL'deki güvenlik açıklarını gidermek ve güvenli iletişim için daha güçlü şifreleme ve kimlik doğrulama sağlamak amacıyla geliştirildi. SSL gibi, TLS de çeşitli revizyonlardan geçti ve her bir revizyon protokole yeni özellikler ve iyileştirmeler ekledi. **TLS'in önemli versiyonları** şunları içerir:

- **TLS 1.0, 1.1, 1.2 ve 1.3:** Her biri bir önceki versiyonun güvenlik açıklarını ele alan ve daha modern şifreleme standartları sunan güncellemeler içermektedir.



**TLS Versiyonları (TLS Versions)**

1. **TLS 1.0:**  
    Bu, **TLS**'in ilk versiyonuydu ve 1999 yılında yayımlandı. **SSL 3.0**'a dayanıyordu ve onunla aynı birçok özelliği içeriyordu, ancak ek güvenlik iyileştirmeleriyle birlikte geldi.
    
2. **TLS 1.1:**  
    2006 yılında yayımlanan bu versiyon, protokole birkaç önemli iyileştirme ekledi. Bu iyileştirmeler arasında yeni kriptografik algoritmalara destek ve **man-in-the-middle attacks** (araya giren adam saldırıları, diğer adıyla **On-Path Attacks**) gibi saldırılara karşı koruma bulunuyordu.
    
3. **TLS 1.2:**  
    2008 yılında yayımlanan bu versiyon, daha güçlü kriptografik algoritmalar ve daha iyi saldırı koruması gibi ek güvenlik iyileştirmeleri getirdi. Ayrıca, el sıkışma sürecinde (handshake) sıkıştırmanın (compression) kullanılmasını müzakere etme gibi yeni özellikler tanıttı.
    
4. **TLS 1.3:**  
    Bu, 2018 yılında yayımlanan **TLS**'in en son versiyonudur. Protokolde önemli geliştirmeler içerir, örneğin: daha hızlı performans, daha güçlü şifreleme ve saldırılara karşı daha iyi koruma. Ayrıca, sadeleştirilmiş bir el sıkışma süreci (simplified handshake) ve el sıkışma sırasında şifrelemenin (encryption) kullanılmasını müzakere etme yeteneğini de içerir.

Bu modülde, SSL 2.0 ve SSL 3.0 dahil olmak üzere belirli SSL/TLS protokolü sürümlerini tamamen kıran saldırıları ele alacağız.


### What is HTTPS?
TLS'nin ne olduğuna dair temel bir anlayışa sahip olduğumuza göre, TLS'nin HTTPS ile nasıl bir ilişkisi olduğunu tartışalım. HTTPS, HTTP ile aynı şekilde çalışır, ancak HTTPS'de TLS protokol Stack'inde yer alır. Bu, HTTPS trafiğinin şifrelendiği ve bütünlüğünün korunduğu, böylece saldırganların verileri gizlice dinlemesinin veya değiştirmesinin engellendiği anlamına gelir. HTTP http:// protokol şemasını kullanırken ve varsayılan olarak 80 numaralı portu hedeflerken, HTTPS https:// adresini kullanır ve 443 numaralı portu hedefler. Farklı HTTP sürümleri olmasına rağmen, HTTPS yalnızca HTTP trafiğinin TLS ile kapsüllendiği anlamına gelir. Dolayısıyla, özel HTTPS sürümleri yoktur.


### **TLS Saldırılarına Giriş (Introduction to TLS Attacks)**

**Transport Layer Security (TLS)** protokolü ve selefi olan **Secure Sockets Layer (SSL)** protokolü, internet üzerinden güvenli iletişim sağlayan kriptografik protokollerdir. **TLS**, iletilen verilerin gizliliğini (confidentiality), bütünlüğünü (integrity) ve kimlik doğrulamasını (authenticity) korur. Bu güvenlik hizmetlerini sağlamak için **TLS**, simetrik şifreleme (symmetric encryption), asimetrik şifreleme (asymmetric encryption) ve **Message Authentication Codes (MACs)** gibi kriptografik algoritmaların bir kombinasyonunu kullanır.

Bu modülde, **TLS**'i daha yakından inceleyerek **TLS**'in nasıl çalıştığını ve **TLS** yapılandırmalarını test ederken nelere dikkat etmeniz gerektiğini anlamaya çalışacağız. Yaygın **TLS** güvenlik açıklarını ele alarak, bu açıkların hangi yanlış yapılandırmalar veya hatalardan kaynaklandığını anlayacağız. Son olarak, bu saldırıları nasıl tespit edeceğimizi, istismar edeceğimizi (exploit) ve önleyeceğimizi tartışacağız. Ayrıca, **TLS** sunucularıyla ilgili yaygın yanlış yapılandırmalar hakkında bilgi vereceğiz.



### **Padding Oracle Saldırıları (Padding Oracle Attacks)**

Bu modülde ele alınan ilk **TLS** saldırı türü, **Padding Oracle** saldırılarıdır. **Padding Oracle** saldırıları, şifrelenmiş bir mesajı (ciphertext) çözdükten sonra doldurmanın (padding) doğruluğu hakkında bilgi sızdıran savunmasız sunucuları hedef alır. Bu tür saldırılar, saldırganın şifreleme anahtarını bilmeden bir şifrelenmiş mesajı tamamen çözmesini sağlayabilir.

**TLS** üzerindeki **Padding Oracle** saldırılarına örnekler şunlardır:

- **POODLE Saldırısı (Padding Oracle On Downgraded Legacy Encryption)**
- **DROWN Saldırısı (Decrypting RSA with Obsolete and Weakened eNcryption)**
- **Bleichenbacher Saldırısı**

Bu saldırılar, protokoldeki zayıflıkları hedef alarak veri gizliliğini tehlikeye atar.


### **Compression Saldırıları (Compression Attacks)**

Bu modülde ele alınan ikinci **TLS** saldırı türü, **compression** (sıkıştırma) saldırılarıdır. **Compression**, veri iletim performansını artırmak için **HTTP** veya **TLS** seviyesinde uygulanabilir. Ancak, yanlış yapılandırılmış sunucular, şifrelenmiş bilgilerin (örneğin, oturum çerezleri veya **CSRF tokens**) sızmasına neden olabilecek şekilde istismar edilebilir.

**TLS** üzerindeki sıkıştırmaya dayalı saldırılara örnekler şunlardır:

- **CRIME Saldırısı (Compression Ratio Info-leak Made Easy)**
- **BREACH Saldırısı (Browser Reconnaissance and Exfiltration via Adaptive Compression of Hypertext)**

Bu tür saldırılar, sıkıştırma ve şifreleme mekanizmalarındaki zayıflıklardan yararlanarak hassas bilgilerin açığa çıkmasına neden olabilir.


### **Diğer Saldırılar ve Yanlış Yapılandırmalar (Misc Attacks & Misconfigurations)**

Bu modülde ele alınan son **TLS** saldırı türü, yanlış yapılandırmaları veya hataları (bugs) hedef alan çeşitli diğer saldırılardır. Bunun ünlü bir örneği, **OpenSSL** kütüphanesinde eksik uzunluk doğrulamasını istismar eden ve özel anahtarların (private key) sızdırılması yoluyla sunucunun tamamen ele geçirilmesine yol açabilen **Heartbleed** hatasıdır.

Ayrıca, güvensiz kriptografik ögeler (insecure cryptographic primitives) kullanarak **TLS** güvenliğini zayıflatabilecek farklı **TLS** yanlış yapılandırmalarını da ele alacağız. Bu tür saldırılar ve yapılandırma sorunları, güvenli iletişim için büyük bir tehdit oluşturabilir.



### **Public Key Infrastructure (PKI)**

**TLS**, hem simetrik hem de asimetrik kriptografi kullanır. **Asimetrik kriptografi** genellikle **public key infrastructure (PKI)**'ya dayanır. **TLS**'in nasıl çalıştığını tam olarak anlayabilmek için, **public key infrastructure (PKI)**, sertifikalar (certificates) ve sertifika otoriteleri (certificate authorities) gibi bazı temel terimlere sahip olmamız gerekir.

Bu terimler, **TLS**'in güvenli iletişim sağlamak için nasıl şifreleme kullandığını ve şifreleme anahtarlarının nasıl yönetildiğini anlamamızda kritik rol oynar.


### **Public Key Infrastructure (PKI)**

**Public key infrastructure (PKI)**, dijital sertifikaların yönetiminden sorumlu olan roller ve süreçlerden oluşur. Bu, sertifikaların dağıtımı, oluşturulması ve iptali gibi işlemleri içerir. Uygun bir **PKI** olmadan, **public key cryptography (açık anahtar kriptografisi)** pratikte uygulanabilir olmaz.

**Public key cryptography**'de, şifreleme anahtarı şifre çözme anahtarından farklıdır, bu nedenle bu tür kriptografi **asymmetric encryption** (asimetrik şifreleme) olarak da adlandırılır. Her katılımcının, şifreleme için kullanılan bir **public key (açık anahtar)** ve şifre çözme için kullanılan bir **private key (özel anahtar)** veya **secret key (gizli anahtar)** içeren bir anahtar çifti vardır. İsmiyle de belirttiği gibi, **public key** halk arasında bilinir, bu nedenle herkes bu anahtarı, ilgili **private key**'in sahibine mesaj göndermek için kullanabilir. **Public key** ile şifrelenmiş mesajlar yalnızca ona karşılık gelen **private key** ile çözülebilir, bu nedenle yalnızca hedef alıcı mesajı çözebilir. Bu durum, mesajları yetkisiz kişilerden korur.

Aşağıda yaygın olarak kullanılan şifreleme algoritmalarına ve türlerine genel bir bakış bulunmaktadır:

![Pasted image 20241207003011.png](/img/user/resimler/Pasted%20image%2020241207003011.png)
![Pasted image 20241207003016.png](/img/user/resimler/Pasted%20image%2020241207003016.png)

**Ancak, diğer aktörlerin açık anahtarlarının edinilmesiyle ilgili kavramsal bir problem vardır çünkü bunların geçerliliğini doğrulamak mümkün değildir.** Örneğin, Alice'in **hackthebox.com** ile özel olarak iletişim kurmak istediğini düşünelim. Bunu yapmak için, **hackthebox.com**'un açık anahtarını alır, mesajını bu anahtarla şifreler ve hedefe gönderir. Çünkü yalnızca **hackthebox.com**, şifre çözme için gerekli olan karşılık gelen **private key (özel anahtar)**'a sahiptir, bu yüzden mesaj yetkisiz aktörler tarafından çözülemez. Ancak, Alice, açık anahtarın gerçekten **hackthebox.com**'a ait olduğunu ve Alice'in **HackTheBox** kimlik bilgilerini çalmaya çalışan bir saldırganın açık anahtarı olmadığını nasıl bilebilir?

Bir saldırganın, Alice'in **HackTheBox**'un açık anahtarını almasını engellediğini ve bunun yerine Alice'e kendi açık anahtarını gönderdiğini varsayalım, aynı zamanda kaynağı taklit ederek Alice'in bunun gerçekten **HackTheBox**'ın açık anahtarı olduğunu düşünmesini sağlar. Alice, mesajını bu saldırganın açık anahtarıyla şifreler, HackTheBox'un açık anahtarı sandığı için, bu da saldırganın mesajı çözmesine ve erişmesine olanak tanır. İşte bu problemi çözmek için **sertifikalar** vardır.


### Özet : 
Bu paragraf, **açık anahtar kriptografisi** (public key cryptography) kullanıldığında karşılaşılan bir güvenlik problemine odaklanıyor. Özetle, bir kişi başkasına güvenli bir şekilde mesaj göndermek isterse, mesajı **açık anahtar** ile şifreler. Ancak, şüpheli bir durumda, bir saldırgan Alice'in açık anahtar edinme sürecini manipüle edebilir. Yani, Alice yanlışlıkla saldırganın açık anahtarını alabilir ve bu durumda mesajı şifrelerken saldırganın açık anahtarını kullanır. Bu da saldırganın mesajı deşifre etmesine ve içeriğine erişmesine neden olabilir.

Daha açık anlatmak gerekirse:

- **Alice**, **hackthebox.com** ile özel bir şekilde iletişim kurmak ister. Bunun için, **hackthebox.com**'un açık anahtarını alır ve mesajını bu anahtarla şifreler.
- Ancak bir saldırgan, Alice'in **hackthebox.com**'un açık anahtarını almak için yaptığı isteği durdurabilir ve Alice'e kendi açık anahtarını gönderebilir.
- Alice, bu açık anahtarın **hackthebox.com**'a ait olduğunu sanarak mesajını bu anahtar ile şifreler.
- Ancak, mesaj aslında saldırgana gitmiş olur, çünkü o şifreyi çözebilecek tek kişi saldırgandır.

Bu tür saldırıları engellemek için **sertifikalar** (certificates) kullanılır. Sertifikalar, bir açık anahtarın gerçekten belirli bir kuruluşa ait olduğunu doğrulamak için kullanılır. Yani, Alice **hackthebox.com**'un açık anahtarının gerçekten onlara ait olduğunu **sertifikalar** sayesinde doğrular. Bu, üçüncü şahısların sahte açık anahtarlarla Alice'i kandırmasını engeller.


![Pasted image 20241207003603.png](/img/user/resimler/Pasted%20image%2020241207003603.png)


### Certificates

Sertifikaların amacı açık anahtarları bir kimliğe bağlamaktır. Bu, açık anahtar sahibinin kimliğini kanıtlar ve böylece daha önce tartışılan sorunu çözer

Bir web sitesine erişirken, web sunucusunun sertifikasını kontrol edebiliriz. Firefox'ta bunu URL çubuğunun yanındaki kilide ve ardından Bağlantı Güvenliği > Daha Fazla Bilgi > Sertifikayı Görüntüle seçeneğine tıklayarak yapabiliriz.

Şimdi hackthebox.com için sertifikanın içeriğine bir göz atalım:

![Pasted image 20241207003744.png](/img/user/resimler/Pasted%20image%2020241207003744.png)

Sertifika, **subject** (konu) hakkında bilgi içerir. En önemli kısmı, açık anahtarın ait olduğu **domain name** (alan adı) olan **Common Name**'dir. Ayrıca, her sertifikanın bir **expiry date** (son kullanma tarihi) vardır ve geçerliliğini koruyabilmesi için bu tarih dolmadan önce yenilenmesi gerekir.

Not: Subject Alt Names bölümünde ek domain adları belirtilebilir.

Biraz aşağı kaydırırsak, sertifikanın public key'i de içerdiğini görebiliriz:

![Pasted image 20241207004044.png](/img/user/resimler/Pasted%20image%2020241207004044.png)

Bu sertifika, bir mesajı ekran görüntüsünde gösterilen public anahtarla şifrelediğimizde, yalnızca HackTheBox'ın şifresini çözebilmesini sağlar.

Dolayısıyla sertifikalar bir kimliği bir public key'e bağlamak için kullanılır. Ancak sertifikaları kim verebilir? Ve bir saldırganın kendi public key'i ve hackthebox.com domain'i ile bir sertifika oluşturmasını ve böylece HackTheBox'ı sahte bir sertifika ile taklit etmesini engelleyen nedir? İşte bu noktada Sertifika Yetkilileri devreye girer.


### Certificate Authorities

**Certificate authorities (CAs)** (Sertifika otoriteleri), sertifika vermeye açıkça yetkilendirilmiş olan kuruluşlardır. Sertifikayı **kriptografik olarak imzalayarak** bunu yaparlar. CA'nın kimliği, bir **CA Certificate** (CA Sertifikası) ile kanıtlanır. Diğer sertifikalar gibi, **CA sertifikaları** da başka bir CA tarafından imzalanır. Bu süreç, bir **root CA**'ya (kök CA) ulaşana kadar devam eder. **Root CA** ile son kullanıcı sertifikası arasındaki zincire **certificate chain** (sertifika zinciri) denir. HackTheBox'un sertifikasına tekrar bakıldığında, üst kısmında toplam üç sertifikadan oluşan bir sertifika zinciri görülebilir.

![Pasted image 20241207004723.png](/img/user/resimler/Pasted%20image%2020241207004723.png)

Bir web sitesine erişildiğinde, tarayıcı **sertifika zincirini** tamamen doğrular. Zincirdeki herhangi bir sertifika geçersiz veya güvensizse, tarayıcı kullanıcıya bir uyarı gösterir. **Root CA**'nın kimliği, **certificate store** (sertifika deposu) adı verilen ve kök CA sertifikalarının sahteciliğini önlemek için **hardcoded** (sert bir şekilde kodlanmış) bir dizi güvenilir CA ile karşılaştırılır.



### OpenSSL

OpenSSL, güvenli iletişim için kriptografik algoritmalar uygulayan bir projedir. Birçok Linux dağıtımı OpenSSL'e dayanır ve bu da onu internette şifreli iletişim için gerekli kılar. OpenSSL'deki güvenlik açıkları ve hatalar milyonlarca web sunucusunun etkilenmesine neden olmaktadır. Kendi anahtarlarımızı ve sertifikalarımızı oluşturmak, bunları farklı biçimlere dönüştürmek ve şifreleme yapmak için birçok Linux dağıtımında önceden yüklenmiş olan OpenSSL istemcisini kullanabiliriz


### Key Generation & Certificate Conversion
Aşağıdaki komutu kullanarak 2048 bit uzunluğunda yeni bir RSA anahtar çifti oluşturabilir ve bunu bir dosyada saklayabiliriz:

![Pasted image 20241207005116.png](/img/user/resimler/Pasted%20image%2020241207005116.png)

Dosyayı **cat** komutuyla görüntülediğimizde, bize **private key** (özel anahtar) gösterir.

![Pasted image 20241207005339.png](/img/user/resimler/Pasted%20image%2020241207005339.png)
![Pasted image 20241207005349.png](/img/user/resimler/Pasted%20image%2020241207005349.png)

Public anahtarı da yazdırmak için openssl kullanabiliriz:

![Pasted image 20241207005508.png](/img/user/resimler/Pasted%20image%2020241207005508.png)

Ayrıca, herhangi bir web sunucusunun sertifikasını indirebiliriz:

![Pasted image 20241207005535.png](/img/user/resimler/Pasted%20image%2020241207005535.png)

Bu, sertifikayı PEM biçiminde depolar. Ancak DER ve PKCS#7 gibi başka formatlar da vardır. PEM'den bu formatlara openssl kullanarak dönüştürebiliriz:

![Pasted image 20241207005603.png](/img/user/resimler/Pasted%20image%2020241207005603.png)


### Kendinden İmzalı Sertifika Oluşturma

Son olarak, kendi sertifikamızı oluşturabilir ve kendimiz imzalayabiliriz. Bu, bir CA'nın imzasının gerekli olmadığı anlamına gelir. Oluşturulan anahtar türünün yanı sıra algoritmayı ve sertifikanın son kullanma tarihini de belirleyebiliriz. Ayrıca private key dosyasını korumak için bir passphrase girmemiz ve sertifika için subject bilgisi sağlamamız istenir. Sertifikalarındaki bilgileri kopyalayarak HackTheBox'ı taklit etmek de dahil olmak üzere istediğimiz her türlü bilgiyi sağlayabiliriz:

![Pasted image 20241207005717.png](/img/user/resimler/Pasted%20image%2020241207005717.png)
![Pasted image 20241207005723.png](/img/user/resimler/Pasted%20image%2020241207005723.png)

Bu, sistemi hacklediğimiz ve artık HackTheBox'ı taklit edebileceğimiz anlamına mı geliyor? Hayır, sertifika kendinden imzalı olduğu için web tarayıcısı buna güvenmez ve bir uyarı görüntüler:

![Pasted image 20241207005745.png](/img/user/resimler/Pasted%20image%2020241207005745.png)

Ancak, eğer bir CA'nın private key'ini ele geçirirsek, bunu rastgele bir subject ile sertifika imzalamak için kullanabiliriz. Bu da herhangi birinin kimliğine bürünmemizi sağlayacaktır.

Bu nedenle, CA'ların private key'leri güvenli online iletişim söz konusu olduğunda en çok korunan kaynaklardan biridir.


### Şifreleme Gerçekleştirme

Son olarak, şifreleme yapmak için openssl de kullanabiliriz. Bunun için öncelikle yeni bir anahtar çifti oluşturuyoruz ve public anahtarı ayrı bir dosyaya çıkarıyoruz:

![Pasted image 20241207010717.png](/img/user/resimler/Pasted%20image%2020241207010717.png)

Daha sonra çıkarılan public anahtarı bir dosyayı şifrelemek için kullanabiliriz. Şifrelenmiş dosyanın incelenmesi binary ciphertext'i ortaya çıkarır

![Pasted image 20241207010817.png](/img/user/resimler/Pasted%20image%2020241207010817.png)

Son olarak, ilgili private key'i kullanarak şifrelenmiş dosyanın şifresini çözebiliriz:

![Pasted image 20241207010845.png](/img/user/resimler/Pasted%20image%2020241207010845.png)


### TLS 1.2 Handshake
TLS handshake, client ve server'ın TLS oturumu için tüm parametreleri müzakere ettiği süreçtir. Bağlantı için seçilen somut parametrelere bağlı olarak küçük sapmalar dışında her zaman önceden tanımlanmış bir şemayı takip eder.

### Cipher Suites

TLS'de, cipher suites (şifre paketleri) bir bağlantı için kullanılan kriptografik algoritmaları tanımlar. Bu, aşağıdaki bilgileri içerir:

* Anahtar değişim algoritması
* Kimlik doğrulama için kullanılan yöntem
* Gizliliği sağlayan şifreleme algoritması ve modu
* Bütünlük koruması sağlayan MAC algoritması

Örnek olarak, aşağıdaki TLS 1.2 şifre paketine bir göz atalım: TLS_DH_RSA_WITH_AES_128_CBC_SHA256

Adından, bu şifre paketi tarafından kullanılan algoritmaları tanımlayabiliriz:

* Anahtar değişim algoritması Diffie-Hellman'dır (DH)
* Sunucu kimlik doğrulaması RSA aracılığıyla gerçekleştirilir
* Şifreleme CBC modunda AES-128'dir
* MAC algoritması bir SHA25

Tüm **TLS 1.2 cipher suite**'leri (şifre kümeleri) bu adlandırma şemasını takip eder. Şifreleme algoritması her zaman bir **symmetric algorithm** (simetrik algoritma) olur. Bu algoritma için kullanılan **symmetric key** (simetrik anahtar), her zaman bir **asymmetric algorithm** (asimetrik algoritma) olan **key exchange algorithm** (anahtar değişim algoritması) ile değiştirilir. Bu nedenle, TLS, asimetrik şifrelemeye kıyasla önemli performans avantajları nedeniyle verileri bir simetrik anahtarla şifreler. Belirli bir bağlantı tarafından kullanılan **cipher suite**, **handshake** (el sıkışma) sırasında müzakere edilir.

**TLS_DHE** ve **TLS_ECDHE** anahtar değişim algoritmalarını kullanan **Cipher Suites**, **Perfect Forward Secrecy (PFS)** (Mükemmel İleri Gizlilik) sağlar. Bu, bir saldırganın, gelecekte bir oturum anahtarını elde etse bile geçmiş mesajları çözmesini engeller. Özellikle bu, geçmiş iletişimi, gelecekte oluşabilecek sızıntılardan korur. Bu nedenle, istemci tarafından destekleniyorsa, PFS cipher suite'leri tercih edilir.


### Handshake Overview

****Handshake** (el sıkışma) sırasında client ve server bir bağlantı kurar ve application data (uygulama verileri) için güvenli bir kanal oluşturmak amacıyla gereken tüm parametreleri müzakere eder. Handshake, iyi tanımlanmış bir şemayı takip eder ve müzakere edilen **cipher suite** (şifre kümesi) türüne göre hafifçe değişiklik gösterebilir.

Handshake, client'in **ClientHello** mesajını göndermesiyle başlar. Bu mesaj, server'a client'in güvenli bir bağlantı kurmak istediğini bildirir. Mesaj, client tarafından desteklenen en son **TLS version** (TLS sürümü) ile birlikte, client'in desteklediği **cipher suites** listesini ve diğer bilgileri içerir.

Server, bir **ServerHello** mesajıyla yanıt verir. Server, client'in sağladığı sürüme eşit veya daha düşük bir **TLS version** seçer. Ayrıca, **ClientHello**'da belirtilen **cipher suites** listesinden birini seçer. Bu bilgiler, **ServerHello** mesajına dahil edilir.

TLS sürümü ve kriptografik parametreler üzerinde anlaşmaya varıldıktan sonra, server, client'e server'ın kimliğini kanıtlamak için bir **Certificate** mesajında bir sertifika sağlar.

Eğer bir **PFS cipher suite** üzerinde anlaşılmışsa, server, **ServerKeyExchange** mesajında yeni key material (anahtar materyali) paylaşmaya devam eder. Bu mesaj, bir key share (anahtar paylaşımı) ve bir signature (imza) içerir. Ardından, **ServerHelloDone** mesajı gönderilir.

Client, bir **ClientKeyExchange** mesajıyla yanıt verir ve client'in key share'ini içerir. Bunun ardından, key exchange (anahtar değişimi) tamamlanır ve her iki taraf, paylaşılan bir **symmetric key** (simetrik anahtar) türetmek için kullanılacak bir sır paylaşır. Her iki taraf da **ChangeCipherSpec** mesajı gönderir ve bu, bundan sonraki tüm mesajların hesaplanan **symmetric key** ile şifrelenip **MAC-protected** (MAC korumalı) olduğunu belirtir. Bu noktadan itibaren tüm data (veri) şifrelenir ve korunur.

![Pasted image 20241207013854.png](/img/user/resimler/Pasted%20image%2020241207013854.png)
![Pasted image 20241207013901.png](/img/user/resimler/Pasted%20image%2020241207013901.png)



### Wireshark'ta TLS 1.2 Handshake'i Analiz Etme

Bir ağ protokolü analizörü olan Wireshark'ta TLS 1.2 handshake'e bir göz atalım. Genellikle paket yöneticisinden kurulabilir:

Daha sonra paketleri analiz etmek için Wireshark'ı bir paket yakalama (veya pcap ) dosyasına giden bir yolla başlatabiliriz:

![Pasted image 20241207014100.png](/img/user/resimler/Pasted%20image%2020241207014100.png)

Filtre çubuğuna tls protokol adını girdikten sonra, TLS handshake'i Wireshark'ta görebiliriz:

![Pasted image 20241207014123.png](/img/user/resimler/Pasted%20image%2020241207014123.png)

ClientHello mesajını genişletirken, client tarafından gönderilen TLS versiyonunu ve desteklenen cipher suitleri inceleyebiliriz:

![Pasted image 20241207014146.png](/img/user/resimler/Pasted%20image%2020241207014146.png)

ServerHello mesajında da aynısını yapmak, bu TLS bağlantısı için sunucu tarafından seçilen TLS sürümünü ve şifre paketini (cipher suite) ortaya çıkarır:

![Pasted image 20241207014214.png](/img/user/resimler/Pasted%20image%2020241207014214.png)

,Son olarak, ClientKeyExchange mesajında client tarafından gönderilen anahtar bilgisini inceleyebiliriz. Bu durumda, TLS_RSA şifre paketi seçilmiştir, dolayısıyla client tarafından gönderilen anahtar bilgisi sunucunun public anahtarı ile şifrelenmiş paylaşımlı anahtardır.

![Pasted image 20241207014256.png](/img/user/resimler/Pasted%20image%2020241207014256.png)

Not: Cipher suite PFS sağlamadığı için Server Key Exchange mesajı yoktur


### TLS 1.3

TLS 1.3, TLS 1.2'ye göre çeşitli iyileştirmeler yapmıştır. Buna güvensiz kriptografik parametreler için desteğin kaldırılması ve böylece karmaşıklığın azaltılması da dahildir. Ayrıca, daha hızlı oturum kurulmasına olanak sağlamak için handshake'de iyileştirmeler yapılmıştır.


### Cipher Suites and Cryptography

sayfa15